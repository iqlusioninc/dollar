// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package vaultsv2

import (
	_ "cosmossdk.io/api/amino"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	reflect "reflect"
	sync "sync"
)

var (
	md_UserPosition                            protoreflect.MessageDescriptor
	fd_UserPosition_position_id                protoreflect.FieldDescriptor
	fd_UserPosition_deposit_amount             protoreflect.FieldDescriptor
	fd_UserPosition_accrued_yield              protoreflect.FieldDescriptor
	fd_UserPosition_first_deposit_time         protoreflect.FieldDescriptor
	fd_UserPosition_last_activity_time         protoreflect.FieldDescriptor
	fd_UserPosition_receive_yield              protoreflect.FieldDescriptor
	fd_UserPosition_amount_pending_withdrawal  protoreflect.FieldDescriptor
	fd_UserPosition_active_withdrawal_requests protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_UserPosition = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("UserPosition")
	fd_UserPosition_position_id = md_UserPosition.Fields().ByName("position_id")
	fd_UserPosition_deposit_amount = md_UserPosition.Fields().ByName("deposit_amount")
	fd_UserPosition_accrued_yield = md_UserPosition.Fields().ByName("accrued_yield")
	fd_UserPosition_first_deposit_time = md_UserPosition.Fields().ByName("first_deposit_time")
	fd_UserPosition_last_activity_time = md_UserPosition.Fields().ByName("last_activity_time")
	fd_UserPosition_receive_yield = md_UserPosition.Fields().ByName("receive_yield")
	fd_UserPosition_amount_pending_withdrawal = md_UserPosition.Fields().ByName("amount_pending_withdrawal")
	fd_UserPosition_active_withdrawal_requests = md_UserPosition.Fields().ByName("active_withdrawal_requests")
}

var _ protoreflect.Message = (*fastReflection_UserPosition)(nil)

type fastReflection_UserPosition UserPosition

func (x *UserPosition) ProtoReflect() protoreflect.Message {
	return (*fastReflection_UserPosition)(x)
}

func (x *UserPosition) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_UserPosition_messageType fastReflection_UserPosition_messageType
var _ protoreflect.MessageType = fastReflection_UserPosition_messageType{}

type fastReflection_UserPosition_messageType struct{}

func (x fastReflection_UserPosition_messageType) Zero() protoreflect.Message {
	return (*fastReflection_UserPosition)(nil)
}
func (x fastReflection_UserPosition_messageType) New() protoreflect.Message {
	return new(fastReflection_UserPosition)
}
func (x fastReflection_UserPosition_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_UserPosition
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_UserPosition) Descriptor() protoreflect.MessageDescriptor {
	return md_UserPosition
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_UserPosition) Type() protoreflect.MessageType {
	return _fastReflection_UserPosition_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_UserPosition) New() protoreflect.Message {
	return new(fastReflection_UserPosition)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_UserPosition) Interface() protoreflect.ProtoMessage {
	return (*UserPosition)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_UserPosition) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PositionId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PositionId)
		if !f(fd_UserPosition_position_id, value) {
			return
		}
	}
	if x.DepositAmount != "" {
		value := protoreflect.ValueOfString(x.DepositAmount)
		if !f(fd_UserPosition_deposit_amount, value) {
			return
		}
	}
	if x.AccruedYield != "" {
		value := protoreflect.ValueOfString(x.AccruedYield)
		if !f(fd_UserPosition_accrued_yield, value) {
			return
		}
	}
	if x.FirstDepositTime != nil {
		value := protoreflect.ValueOfMessage(x.FirstDepositTime.ProtoReflect())
		if !f(fd_UserPosition_first_deposit_time, value) {
			return
		}
	}
	if x.LastActivityTime != nil {
		value := protoreflect.ValueOfMessage(x.LastActivityTime.ProtoReflect())
		if !f(fd_UserPosition_last_activity_time, value) {
			return
		}
	}
	if x.ReceiveYield != false {
		value := protoreflect.ValueOfBool(x.ReceiveYield)
		if !f(fd_UserPosition_receive_yield, value) {
			return
		}
	}
	if x.AmountPendingWithdrawal != "" {
		value := protoreflect.ValueOfString(x.AmountPendingWithdrawal)
		if !f(fd_UserPosition_amount_pending_withdrawal, value) {
			return
		}
	}
	if x.ActiveWithdrawalRequests != int32(0) {
		value := protoreflect.ValueOfInt32(x.ActiveWithdrawalRequests)
		if !f(fd_UserPosition_active_withdrawal_requests, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_UserPosition) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.UserPosition.position_id":
		return x.PositionId != uint64(0)
	case "noble.dollar.vaults.v2.UserPosition.deposit_amount":
		return x.DepositAmount != ""
	case "noble.dollar.vaults.v2.UserPosition.accrued_yield":
		return x.AccruedYield != ""
	case "noble.dollar.vaults.v2.UserPosition.first_deposit_time":
		return x.FirstDepositTime != nil
	case "noble.dollar.vaults.v2.UserPosition.last_activity_time":
		return x.LastActivityTime != nil
	case "noble.dollar.vaults.v2.UserPosition.receive_yield":
		return x.ReceiveYield != false
	case "noble.dollar.vaults.v2.UserPosition.amount_pending_withdrawal":
		return x.AmountPendingWithdrawal != ""
	case "noble.dollar.vaults.v2.UserPosition.active_withdrawal_requests":
		return x.ActiveWithdrawalRequests != int32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.UserPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.UserPosition does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserPosition) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.UserPosition.position_id":
		x.PositionId = uint64(0)
	case "noble.dollar.vaults.v2.UserPosition.deposit_amount":
		x.DepositAmount = ""
	case "noble.dollar.vaults.v2.UserPosition.accrued_yield":
		x.AccruedYield = ""
	case "noble.dollar.vaults.v2.UserPosition.first_deposit_time":
		x.FirstDepositTime = nil
	case "noble.dollar.vaults.v2.UserPosition.last_activity_time":
		x.LastActivityTime = nil
	case "noble.dollar.vaults.v2.UserPosition.receive_yield":
		x.ReceiveYield = false
	case "noble.dollar.vaults.v2.UserPosition.amount_pending_withdrawal":
		x.AmountPendingWithdrawal = ""
	case "noble.dollar.vaults.v2.UserPosition.active_withdrawal_requests":
		x.ActiveWithdrawalRequests = int32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.UserPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.UserPosition does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_UserPosition) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.UserPosition.position_id":
		value := x.PositionId
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v2.UserPosition.deposit_amount":
		value := x.DepositAmount
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.UserPosition.accrued_yield":
		value := x.AccruedYield
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.UserPosition.first_deposit_time":
		value := x.FirstDepositTime
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.UserPosition.last_activity_time":
		value := x.LastActivityTime
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.UserPosition.receive_yield":
		value := x.ReceiveYield
		return protoreflect.ValueOfBool(value)
	case "noble.dollar.vaults.v2.UserPosition.amount_pending_withdrawal":
		value := x.AmountPendingWithdrawal
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.UserPosition.active_withdrawal_requests":
		value := x.ActiveWithdrawalRequests
		return protoreflect.ValueOfInt32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.UserPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.UserPosition does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserPosition) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.UserPosition.position_id":
		x.PositionId = value.Uint()
	case "noble.dollar.vaults.v2.UserPosition.deposit_amount":
		x.DepositAmount = value.Interface().(string)
	case "noble.dollar.vaults.v2.UserPosition.accrued_yield":
		x.AccruedYield = value.Interface().(string)
	case "noble.dollar.vaults.v2.UserPosition.first_deposit_time":
		x.FirstDepositTime = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.UserPosition.last_activity_time":
		x.LastActivityTime = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.UserPosition.receive_yield":
		x.ReceiveYield = value.Bool()
	case "noble.dollar.vaults.v2.UserPosition.amount_pending_withdrawal":
		x.AmountPendingWithdrawal = value.Interface().(string)
	case "noble.dollar.vaults.v2.UserPosition.active_withdrawal_requests":
		x.ActiveWithdrawalRequests = int32(value.Int())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.UserPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.UserPosition does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserPosition) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.UserPosition.first_deposit_time":
		if x.FirstDepositTime == nil {
			x.FirstDepositTime = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.FirstDepositTime.ProtoReflect())
	case "noble.dollar.vaults.v2.UserPosition.last_activity_time":
		if x.LastActivityTime == nil {
			x.LastActivityTime = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.LastActivityTime.ProtoReflect())
	case "noble.dollar.vaults.v2.UserPosition.position_id":
		panic(fmt.Errorf("field position_id of message noble.dollar.vaults.v2.UserPosition is not mutable"))
	case "noble.dollar.vaults.v2.UserPosition.deposit_amount":
		panic(fmt.Errorf("field deposit_amount of message noble.dollar.vaults.v2.UserPosition is not mutable"))
	case "noble.dollar.vaults.v2.UserPosition.accrued_yield":
		panic(fmt.Errorf("field accrued_yield of message noble.dollar.vaults.v2.UserPosition is not mutable"))
	case "noble.dollar.vaults.v2.UserPosition.receive_yield":
		panic(fmt.Errorf("field receive_yield of message noble.dollar.vaults.v2.UserPosition is not mutable"))
	case "noble.dollar.vaults.v2.UserPosition.amount_pending_withdrawal":
		panic(fmt.Errorf("field amount_pending_withdrawal of message noble.dollar.vaults.v2.UserPosition is not mutable"))
	case "noble.dollar.vaults.v2.UserPosition.active_withdrawal_requests":
		panic(fmt.Errorf("field active_withdrawal_requests of message noble.dollar.vaults.v2.UserPosition is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.UserPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.UserPosition does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_UserPosition) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.UserPosition.position_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v2.UserPosition.deposit_amount":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.UserPosition.accrued_yield":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.UserPosition.first_deposit_time":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.UserPosition.last_activity_time":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.UserPosition.receive_yield":
		return protoreflect.ValueOfBool(false)
	case "noble.dollar.vaults.v2.UserPosition.amount_pending_withdrawal":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.UserPosition.active_withdrawal_requests":
		return protoreflect.ValueOfInt32(int32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.UserPosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.UserPosition does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_UserPosition) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.UserPosition", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_UserPosition) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserPosition) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_UserPosition) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_UserPosition) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*UserPosition)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PositionId != 0 {
			n += 1 + runtime.Sov(uint64(x.PositionId))
		}
		l = len(x.DepositAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AccruedYield)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.FirstDepositTime != nil {
			l = options.Size(x.FirstDepositTime)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.LastActivityTime != nil {
			l = options.Size(x.LastActivityTime)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ReceiveYield {
			n += 2
		}
		l = len(x.AmountPendingWithdrawal)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ActiveWithdrawalRequests != 0 {
			n += 1 + runtime.Sov(uint64(x.ActiveWithdrawalRequests))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*UserPosition)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ActiveWithdrawalRequests != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ActiveWithdrawalRequests))
			i--
			dAtA[i] = 0x40
		}
		if len(x.AmountPendingWithdrawal) > 0 {
			i -= len(x.AmountPendingWithdrawal)
			copy(dAtA[i:], x.AmountPendingWithdrawal)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AmountPendingWithdrawal)))
			i--
			dAtA[i] = 0x3a
		}
		if x.ReceiveYield {
			i--
			if x.ReceiveYield {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if x.LastActivityTime != nil {
			encoded, err := options.Marshal(x.LastActivityTime)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if x.FirstDepositTime != nil {
			encoded, err := options.Marshal(x.FirstDepositTime)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.AccruedYield) > 0 {
			i -= len(x.AccruedYield)
			copy(dAtA[i:], x.AccruedYield)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AccruedYield)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.DepositAmount) > 0 {
			i -= len(x.DepositAmount)
			copy(dAtA[i:], x.DepositAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DepositAmount)))
			i--
			dAtA[i] = 0x12
		}
		if x.PositionId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PositionId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*UserPosition)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: UserPosition: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: UserPosition: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
				}
				x.PositionId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PositionId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DepositAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DepositAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AccruedYield", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AccruedYield = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FirstDepositTime", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.FirstDepositTime == nil {
					x.FirstDepositTime = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.FirstDepositTime); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastActivityTime", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.LastActivityTime == nil {
					x.LastActivityTime = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LastActivityTime); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReceiveYield", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.ReceiveYield = bool(v != 0)
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AmountPendingWithdrawal", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AmountPendingWithdrawal = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ActiveWithdrawalRequests", wireType)
				}
				x.ActiveWithdrawalRequests = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ActiveWithdrawalRequests |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_AccountingSnapshot                protoreflect.MessageDescriptor
	fd_AccountingSnapshot_user           protoreflect.FieldDescriptor
	fd_AccountingSnapshot_position_id    protoreflect.FieldDescriptor
	fd_AccountingSnapshot_deposit_amount protoreflect.FieldDescriptor
	fd_AccountingSnapshot_accrued_yield  protoreflect.FieldDescriptor
	fd_AccountingSnapshot_accounting_nav protoreflect.FieldDescriptor
	fd_AccountingSnapshot_created_at     protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_AccountingSnapshot = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("AccountingSnapshot")
	fd_AccountingSnapshot_user = md_AccountingSnapshot.Fields().ByName("user")
	fd_AccountingSnapshot_position_id = md_AccountingSnapshot.Fields().ByName("position_id")
	fd_AccountingSnapshot_deposit_amount = md_AccountingSnapshot.Fields().ByName("deposit_amount")
	fd_AccountingSnapshot_accrued_yield = md_AccountingSnapshot.Fields().ByName("accrued_yield")
	fd_AccountingSnapshot_accounting_nav = md_AccountingSnapshot.Fields().ByName("accounting_nav")
	fd_AccountingSnapshot_created_at = md_AccountingSnapshot.Fields().ByName("created_at")
}

var _ protoreflect.Message = (*fastReflection_AccountingSnapshot)(nil)

type fastReflection_AccountingSnapshot AccountingSnapshot

func (x *AccountingSnapshot) ProtoReflect() protoreflect.Message {
	return (*fastReflection_AccountingSnapshot)(x)
}

func (x *AccountingSnapshot) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_AccountingSnapshot_messageType fastReflection_AccountingSnapshot_messageType
var _ protoreflect.MessageType = fastReflection_AccountingSnapshot_messageType{}

type fastReflection_AccountingSnapshot_messageType struct{}

func (x fastReflection_AccountingSnapshot_messageType) Zero() protoreflect.Message {
	return (*fastReflection_AccountingSnapshot)(nil)
}
func (x fastReflection_AccountingSnapshot_messageType) New() protoreflect.Message {
	return new(fastReflection_AccountingSnapshot)
}
func (x fastReflection_AccountingSnapshot_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_AccountingSnapshot
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_AccountingSnapshot) Descriptor() protoreflect.MessageDescriptor {
	return md_AccountingSnapshot
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_AccountingSnapshot) Type() protoreflect.MessageType {
	return _fastReflection_AccountingSnapshot_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_AccountingSnapshot) New() protoreflect.Message {
	return new(fastReflection_AccountingSnapshot)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_AccountingSnapshot) Interface() protoreflect.ProtoMessage {
	return (*AccountingSnapshot)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_AccountingSnapshot) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.User != "" {
		value := protoreflect.ValueOfString(x.User)
		if !f(fd_AccountingSnapshot_user, value) {
			return
		}
	}
	if x.PositionId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PositionId)
		if !f(fd_AccountingSnapshot_position_id, value) {
			return
		}
	}
	if x.DepositAmount != "" {
		value := protoreflect.ValueOfString(x.DepositAmount)
		if !f(fd_AccountingSnapshot_deposit_amount, value) {
			return
		}
	}
	if x.AccruedYield != "" {
		value := protoreflect.ValueOfString(x.AccruedYield)
		if !f(fd_AccountingSnapshot_accrued_yield, value) {
			return
		}
	}
	if x.AccountingNav != "" {
		value := protoreflect.ValueOfString(x.AccountingNav)
		if !f(fd_AccountingSnapshot_accounting_nav, value) {
			return
		}
	}
	if x.CreatedAt != nil {
		value := protoreflect.ValueOfMessage(x.CreatedAt.ProtoReflect())
		if !f(fd_AccountingSnapshot_created_at, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_AccountingSnapshot) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.AccountingSnapshot.user":
		return x.User != ""
	case "noble.dollar.vaults.v2.AccountingSnapshot.position_id":
		return x.PositionId != uint64(0)
	case "noble.dollar.vaults.v2.AccountingSnapshot.deposit_amount":
		return x.DepositAmount != ""
	case "noble.dollar.vaults.v2.AccountingSnapshot.accrued_yield":
		return x.AccruedYield != ""
	case "noble.dollar.vaults.v2.AccountingSnapshot.accounting_nav":
		return x.AccountingNav != ""
	case "noble.dollar.vaults.v2.AccountingSnapshot.created_at":
		return x.CreatedAt != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingSnapshot does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AccountingSnapshot) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.AccountingSnapshot.user":
		x.User = ""
	case "noble.dollar.vaults.v2.AccountingSnapshot.position_id":
		x.PositionId = uint64(0)
	case "noble.dollar.vaults.v2.AccountingSnapshot.deposit_amount":
		x.DepositAmount = ""
	case "noble.dollar.vaults.v2.AccountingSnapshot.accrued_yield":
		x.AccruedYield = ""
	case "noble.dollar.vaults.v2.AccountingSnapshot.accounting_nav":
		x.AccountingNav = ""
	case "noble.dollar.vaults.v2.AccountingSnapshot.created_at":
		x.CreatedAt = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingSnapshot does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_AccountingSnapshot) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.AccountingSnapshot.user":
		value := x.User
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.AccountingSnapshot.position_id":
		value := x.PositionId
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v2.AccountingSnapshot.deposit_amount":
		value := x.DepositAmount
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.AccountingSnapshot.accrued_yield":
		value := x.AccruedYield
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.AccountingSnapshot.accounting_nav":
		value := x.AccountingNav
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.AccountingSnapshot.created_at":
		value := x.CreatedAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingSnapshot does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AccountingSnapshot) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.AccountingSnapshot.user":
		x.User = value.Interface().(string)
	case "noble.dollar.vaults.v2.AccountingSnapshot.position_id":
		x.PositionId = value.Uint()
	case "noble.dollar.vaults.v2.AccountingSnapshot.deposit_amount":
		x.DepositAmount = value.Interface().(string)
	case "noble.dollar.vaults.v2.AccountingSnapshot.accrued_yield":
		x.AccruedYield = value.Interface().(string)
	case "noble.dollar.vaults.v2.AccountingSnapshot.accounting_nav":
		x.AccountingNav = value.Interface().(string)
	case "noble.dollar.vaults.v2.AccountingSnapshot.created_at":
		x.CreatedAt = value.Message().Interface().(*timestamppb.Timestamp)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingSnapshot does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AccountingSnapshot) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.AccountingSnapshot.created_at":
		if x.CreatedAt == nil {
			x.CreatedAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.CreatedAt.ProtoReflect())
	case "noble.dollar.vaults.v2.AccountingSnapshot.user":
		panic(fmt.Errorf("field user of message noble.dollar.vaults.v2.AccountingSnapshot is not mutable"))
	case "noble.dollar.vaults.v2.AccountingSnapshot.position_id":
		panic(fmt.Errorf("field position_id of message noble.dollar.vaults.v2.AccountingSnapshot is not mutable"))
	case "noble.dollar.vaults.v2.AccountingSnapshot.deposit_amount":
		panic(fmt.Errorf("field deposit_amount of message noble.dollar.vaults.v2.AccountingSnapshot is not mutable"))
	case "noble.dollar.vaults.v2.AccountingSnapshot.accrued_yield":
		panic(fmt.Errorf("field accrued_yield of message noble.dollar.vaults.v2.AccountingSnapshot is not mutable"))
	case "noble.dollar.vaults.v2.AccountingSnapshot.accounting_nav":
		panic(fmt.Errorf("field accounting_nav of message noble.dollar.vaults.v2.AccountingSnapshot is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingSnapshot does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_AccountingSnapshot) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.AccountingSnapshot.user":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.AccountingSnapshot.position_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v2.AccountingSnapshot.deposit_amount":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.AccountingSnapshot.accrued_yield":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.AccountingSnapshot.accounting_nav":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.AccountingSnapshot.created_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingSnapshot does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_AccountingSnapshot) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.AccountingSnapshot", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_AccountingSnapshot) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AccountingSnapshot) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_AccountingSnapshot) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_AccountingSnapshot) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*AccountingSnapshot)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.User)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PositionId != 0 {
			n += 1 + runtime.Sov(uint64(x.PositionId))
		}
		l = len(x.DepositAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AccruedYield)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AccountingNav)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CreatedAt != nil {
			l = options.Size(x.CreatedAt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*AccountingSnapshot)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CreatedAt != nil {
			encoded, err := options.Marshal(x.CreatedAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.AccountingNav) > 0 {
			i -= len(x.AccountingNav)
			copy(dAtA[i:], x.AccountingNav)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AccountingNav)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.AccruedYield) > 0 {
			i -= len(x.AccruedYield)
			copy(dAtA[i:], x.AccruedYield)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AccruedYield)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.DepositAmount) > 0 {
			i -= len(x.DepositAmount)
			copy(dAtA[i:], x.DepositAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DepositAmount)))
			i--
			dAtA[i] = 0x1a
		}
		if x.PositionId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PositionId))
			i--
			dAtA[i] = 0x10
		}
		if len(x.User) > 0 {
			i -= len(x.User)
			copy(dAtA[i:], x.User)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.User)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*AccountingSnapshot)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AccountingSnapshot: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AccountingSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.User = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
				}
				x.PositionId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PositionId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DepositAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DepositAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AccruedYield", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AccruedYield = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AccountingNav", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AccountingNav = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CreatedAt == nil {
					x.CreatedAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CreatedAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_WithdrawalRequest                      protoreflect.MessageDescriptor
	fd_WithdrawalRequest_request_id           protoreflect.FieldDescriptor
	fd_WithdrawalRequest_requester            protoreflect.FieldDescriptor
	fd_WithdrawalRequest_position_id          protoreflect.FieldDescriptor
	fd_WithdrawalRequest_withdraw_amount      protoreflect.FieldDescriptor
	fd_WithdrawalRequest_request_time         protoreflect.FieldDescriptor
	fd_WithdrawalRequest_unlock_time          protoreflect.FieldDescriptor
	fd_WithdrawalRequest_status               protoreflect.FieldDescriptor
	fd_WithdrawalRequest_estimated_amount     protoreflect.FieldDescriptor
	fd_WithdrawalRequest_request_block_height protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_WithdrawalRequest = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("WithdrawalRequest")
	fd_WithdrawalRequest_request_id = md_WithdrawalRequest.Fields().ByName("request_id")
	fd_WithdrawalRequest_requester = md_WithdrawalRequest.Fields().ByName("requester")
	fd_WithdrawalRequest_position_id = md_WithdrawalRequest.Fields().ByName("position_id")
	fd_WithdrawalRequest_withdraw_amount = md_WithdrawalRequest.Fields().ByName("withdraw_amount")
	fd_WithdrawalRequest_request_time = md_WithdrawalRequest.Fields().ByName("request_time")
	fd_WithdrawalRequest_unlock_time = md_WithdrawalRequest.Fields().ByName("unlock_time")
	fd_WithdrawalRequest_status = md_WithdrawalRequest.Fields().ByName("status")
	fd_WithdrawalRequest_estimated_amount = md_WithdrawalRequest.Fields().ByName("estimated_amount")
	fd_WithdrawalRequest_request_block_height = md_WithdrawalRequest.Fields().ByName("request_block_height")
}

var _ protoreflect.Message = (*fastReflection_WithdrawalRequest)(nil)

type fastReflection_WithdrawalRequest WithdrawalRequest

func (x *WithdrawalRequest) ProtoReflect() protoreflect.Message {
	return (*fastReflection_WithdrawalRequest)(x)
}

func (x *WithdrawalRequest) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_WithdrawalRequest_messageType fastReflection_WithdrawalRequest_messageType
var _ protoreflect.MessageType = fastReflection_WithdrawalRequest_messageType{}

type fastReflection_WithdrawalRequest_messageType struct{}

func (x fastReflection_WithdrawalRequest_messageType) Zero() protoreflect.Message {
	return (*fastReflection_WithdrawalRequest)(nil)
}
func (x fastReflection_WithdrawalRequest_messageType) New() protoreflect.Message {
	return new(fastReflection_WithdrawalRequest)
}
func (x fastReflection_WithdrawalRequest_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_WithdrawalRequest
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_WithdrawalRequest) Descriptor() protoreflect.MessageDescriptor {
	return md_WithdrawalRequest
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_WithdrawalRequest) Type() protoreflect.MessageType {
	return _fastReflection_WithdrawalRequest_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_WithdrawalRequest) New() protoreflect.Message {
	return new(fastReflection_WithdrawalRequest)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_WithdrawalRequest) Interface() protoreflect.ProtoMessage {
	return (*WithdrawalRequest)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_WithdrawalRequest) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.RequestId != "" {
		value := protoreflect.ValueOfString(x.RequestId)
		if !f(fd_WithdrawalRequest_request_id, value) {
			return
		}
	}
	if x.Requester != "" {
		value := protoreflect.ValueOfString(x.Requester)
		if !f(fd_WithdrawalRequest_requester, value) {
			return
		}
	}
	if x.PositionId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PositionId)
		if !f(fd_WithdrawalRequest_position_id, value) {
			return
		}
	}
	if x.WithdrawAmount != "" {
		value := protoreflect.ValueOfString(x.WithdrawAmount)
		if !f(fd_WithdrawalRequest_withdraw_amount, value) {
			return
		}
	}
	if x.RequestTime != nil {
		value := protoreflect.ValueOfMessage(x.RequestTime.ProtoReflect())
		if !f(fd_WithdrawalRequest_request_time, value) {
			return
		}
	}
	if x.UnlockTime != nil {
		value := protoreflect.ValueOfMessage(x.UnlockTime.ProtoReflect())
		if !f(fd_WithdrawalRequest_unlock_time, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_WithdrawalRequest_status, value) {
			return
		}
	}
	if x.EstimatedAmount != "" {
		value := protoreflect.ValueOfString(x.EstimatedAmount)
		if !f(fd_WithdrawalRequest_estimated_amount, value) {
			return
		}
	}
	if x.RequestBlockHeight != int64(0) {
		value := protoreflect.ValueOfInt64(x.RequestBlockHeight)
		if !f(fd_WithdrawalRequest_request_block_height, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_WithdrawalRequest) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_id":
		return x.RequestId != ""
	case "noble.dollar.vaults.v2.WithdrawalRequest.requester":
		return x.Requester != ""
	case "noble.dollar.vaults.v2.WithdrawalRequest.position_id":
		return x.PositionId != uint64(0)
	case "noble.dollar.vaults.v2.WithdrawalRequest.withdraw_amount":
		return x.WithdrawAmount != ""
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_time":
		return x.RequestTime != nil
	case "noble.dollar.vaults.v2.WithdrawalRequest.unlock_time":
		return x.UnlockTime != nil
	case "noble.dollar.vaults.v2.WithdrawalRequest.status":
		return x.Status != 0
	case "noble.dollar.vaults.v2.WithdrawalRequest.estimated_amount":
		return x.EstimatedAmount != ""
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_block_height":
		return x.RequestBlockHeight != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalRequest does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WithdrawalRequest) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_id":
		x.RequestId = ""
	case "noble.dollar.vaults.v2.WithdrawalRequest.requester":
		x.Requester = ""
	case "noble.dollar.vaults.v2.WithdrawalRequest.position_id":
		x.PositionId = uint64(0)
	case "noble.dollar.vaults.v2.WithdrawalRequest.withdraw_amount":
		x.WithdrawAmount = ""
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_time":
		x.RequestTime = nil
	case "noble.dollar.vaults.v2.WithdrawalRequest.unlock_time":
		x.UnlockTime = nil
	case "noble.dollar.vaults.v2.WithdrawalRequest.status":
		x.Status = 0
	case "noble.dollar.vaults.v2.WithdrawalRequest.estimated_amount":
		x.EstimatedAmount = ""
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_block_height":
		x.RequestBlockHeight = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalRequest does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_WithdrawalRequest) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_id":
		value := x.RequestId
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.WithdrawalRequest.requester":
		value := x.Requester
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.WithdrawalRequest.position_id":
		value := x.PositionId
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v2.WithdrawalRequest.withdraw_amount":
		value := x.WithdrawAmount
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_time":
		value := x.RequestTime
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.WithdrawalRequest.unlock_time":
		value := x.UnlockTime
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.WithdrawalRequest.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "noble.dollar.vaults.v2.WithdrawalRequest.estimated_amount":
		value := x.EstimatedAmount
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_block_height":
		value := x.RequestBlockHeight
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalRequest does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WithdrawalRequest) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_id":
		x.RequestId = value.Interface().(string)
	case "noble.dollar.vaults.v2.WithdrawalRequest.requester":
		x.Requester = value.Interface().(string)
	case "noble.dollar.vaults.v2.WithdrawalRequest.position_id":
		x.PositionId = value.Uint()
	case "noble.dollar.vaults.v2.WithdrawalRequest.withdraw_amount":
		x.WithdrawAmount = value.Interface().(string)
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_time":
		x.RequestTime = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.WithdrawalRequest.unlock_time":
		x.UnlockTime = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.WithdrawalRequest.status":
		x.Status = (WithdrawalRequestStatus)(value.Enum())
	case "noble.dollar.vaults.v2.WithdrawalRequest.estimated_amount":
		x.EstimatedAmount = value.Interface().(string)
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_block_height":
		x.RequestBlockHeight = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalRequest does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WithdrawalRequest) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_time":
		if x.RequestTime == nil {
			x.RequestTime = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.RequestTime.ProtoReflect())
	case "noble.dollar.vaults.v2.WithdrawalRequest.unlock_time":
		if x.UnlockTime == nil {
			x.UnlockTime = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.UnlockTime.ProtoReflect())
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_id":
		panic(fmt.Errorf("field request_id of message noble.dollar.vaults.v2.WithdrawalRequest is not mutable"))
	case "noble.dollar.vaults.v2.WithdrawalRequest.requester":
		panic(fmt.Errorf("field requester of message noble.dollar.vaults.v2.WithdrawalRequest is not mutable"))
	case "noble.dollar.vaults.v2.WithdrawalRequest.position_id":
		panic(fmt.Errorf("field position_id of message noble.dollar.vaults.v2.WithdrawalRequest is not mutable"))
	case "noble.dollar.vaults.v2.WithdrawalRequest.withdraw_amount":
		panic(fmt.Errorf("field withdraw_amount of message noble.dollar.vaults.v2.WithdrawalRequest is not mutable"))
	case "noble.dollar.vaults.v2.WithdrawalRequest.status":
		panic(fmt.Errorf("field status of message noble.dollar.vaults.v2.WithdrawalRequest is not mutable"))
	case "noble.dollar.vaults.v2.WithdrawalRequest.estimated_amount":
		panic(fmt.Errorf("field estimated_amount of message noble.dollar.vaults.v2.WithdrawalRequest is not mutable"))
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_block_height":
		panic(fmt.Errorf("field request_block_height of message noble.dollar.vaults.v2.WithdrawalRequest is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalRequest does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_WithdrawalRequest) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_id":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.WithdrawalRequest.requester":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.WithdrawalRequest.position_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v2.WithdrawalRequest.withdraw_amount":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_time":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.WithdrawalRequest.unlock_time":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.WithdrawalRequest.status":
		return protoreflect.ValueOfEnum(0)
	case "noble.dollar.vaults.v2.WithdrawalRequest.estimated_amount":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.WithdrawalRequest.request_block_height":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalRequest"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalRequest does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_WithdrawalRequest) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.WithdrawalRequest", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_WithdrawalRequest) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WithdrawalRequest) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_WithdrawalRequest) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_WithdrawalRequest) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*WithdrawalRequest)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.RequestId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Requester)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PositionId != 0 {
			n += 1 + runtime.Sov(uint64(x.PositionId))
		}
		l = len(x.WithdrawAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RequestTime != nil {
			l = options.Size(x.RequestTime)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.UnlockTime != nil {
			l = options.Size(x.UnlockTime)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		l = len(x.EstimatedAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RequestBlockHeight != 0 {
			n += 1 + runtime.Sov(uint64(x.RequestBlockHeight))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*WithdrawalRequest)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.RequestBlockHeight != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.RequestBlockHeight))
			i--
			dAtA[i] = 0x48
		}
		if len(x.EstimatedAmount) > 0 {
			i -= len(x.EstimatedAmount)
			copy(dAtA[i:], x.EstimatedAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EstimatedAmount)))
			i--
			dAtA[i] = 0x42
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x38
		}
		if x.UnlockTime != nil {
			encoded, err := options.Marshal(x.UnlockTime)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if x.RequestTime != nil {
			encoded, err := options.Marshal(x.RequestTime)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.WithdrawAmount) > 0 {
			i -= len(x.WithdrawAmount)
			copy(dAtA[i:], x.WithdrawAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.WithdrawAmount)))
			i--
			dAtA[i] = 0x22
		}
		if x.PositionId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PositionId))
			i--
			dAtA[i] = 0x18
		}
		if len(x.Requester) > 0 {
			i -= len(x.Requester)
			copy(dAtA[i:], x.Requester)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Requester)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.RequestId) > 0 {
			i -= len(x.RequestId)
			copy(dAtA[i:], x.RequestId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RequestId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*WithdrawalRequest)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: WithdrawalRequest: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: WithdrawalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RequestId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Requester = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
				}
				x.PositionId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PositionId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WithdrawAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.WithdrawAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RequestTime == nil {
					x.RequestTime = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RequestTime); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UnlockTime", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.UnlockTime == nil {
					x.UnlockTime = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.UnlockTime); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= WithdrawalRequestStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EstimatedAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EstimatedAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequestBlockHeight", wireType)
				}
				x.RequestBlockHeight = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.RequestBlockHeight |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_VaultState                                 protoreflect.MessageDescriptor
	fd_VaultState_total_deposits                  protoreflect.FieldDescriptor
	fd_VaultState_total_accrued_yield             protoreflect.FieldDescriptor
	fd_VaultState_total_nav                       protoreflect.FieldDescriptor
	fd_VaultState_total_users                     protoreflect.FieldDescriptor
	fd_VaultState_deposits_enabled                protoreflect.FieldDescriptor
	fd_VaultState_withdrawals_enabled             protoreflect.FieldDescriptor
	fd_VaultState_last_nav_update                 protoreflect.FieldDescriptor
	fd_VaultState_total_amount_pending_withdrawal protoreflect.FieldDescriptor
	fd_VaultState_pending_withdrawal_requests     protoreflect.FieldDescriptor
	fd_VaultState_total_positions                 protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_VaultState = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("VaultState")
	fd_VaultState_total_deposits = md_VaultState.Fields().ByName("total_deposits")
	fd_VaultState_total_accrued_yield = md_VaultState.Fields().ByName("total_accrued_yield")
	fd_VaultState_total_nav = md_VaultState.Fields().ByName("total_nav")
	fd_VaultState_total_users = md_VaultState.Fields().ByName("total_users")
	fd_VaultState_deposits_enabled = md_VaultState.Fields().ByName("deposits_enabled")
	fd_VaultState_withdrawals_enabled = md_VaultState.Fields().ByName("withdrawals_enabled")
	fd_VaultState_last_nav_update = md_VaultState.Fields().ByName("last_nav_update")
	fd_VaultState_total_amount_pending_withdrawal = md_VaultState.Fields().ByName("total_amount_pending_withdrawal")
	fd_VaultState_pending_withdrawal_requests = md_VaultState.Fields().ByName("pending_withdrawal_requests")
	fd_VaultState_total_positions = md_VaultState.Fields().ByName("total_positions")
}

var _ protoreflect.Message = (*fastReflection_VaultState)(nil)

type fastReflection_VaultState VaultState

func (x *VaultState) ProtoReflect() protoreflect.Message {
	return (*fastReflection_VaultState)(x)
}

func (x *VaultState) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_VaultState_messageType fastReflection_VaultState_messageType
var _ protoreflect.MessageType = fastReflection_VaultState_messageType{}

type fastReflection_VaultState_messageType struct{}

func (x fastReflection_VaultState_messageType) Zero() protoreflect.Message {
	return (*fastReflection_VaultState)(nil)
}
func (x fastReflection_VaultState_messageType) New() protoreflect.Message {
	return new(fastReflection_VaultState)
}
func (x fastReflection_VaultState_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_VaultState
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_VaultState) Descriptor() protoreflect.MessageDescriptor {
	return md_VaultState
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_VaultState) Type() protoreflect.MessageType {
	return _fastReflection_VaultState_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_VaultState) New() protoreflect.Message {
	return new(fastReflection_VaultState)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_VaultState) Interface() protoreflect.ProtoMessage {
	return (*VaultState)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_VaultState) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TotalDeposits != "" {
		value := protoreflect.ValueOfString(x.TotalDeposits)
		if !f(fd_VaultState_total_deposits, value) {
			return
		}
	}
	if x.TotalAccruedYield != "" {
		value := protoreflect.ValueOfString(x.TotalAccruedYield)
		if !f(fd_VaultState_total_accrued_yield, value) {
			return
		}
	}
	if x.TotalNav != "" {
		value := protoreflect.ValueOfString(x.TotalNav)
		if !f(fd_VaultState_total_nav, value) {
			return
		}
	}
	if x.TotalUsers != uint64(0) {
		value := protoreflect.ValueOfUint64(x.TotalUsers)
		if !f(fd_VaultState_total_users, value) {
			return
		}
	}
	if x.DepositsEnabled != false {
		value := protoreflect.ValueOfBool(x.DepositsEnabled)
		if !f(fd_VaultState_deposits_enabled, value) {
			return
		}
	}
	if x.WithdrawalsEnabled != false {
		value := protoreflect.ValueOfBool(x.WithdrawalsEnabled)
		if !f(fd_VaultState_withdrawals_enabled, value) {
			return
		}
	}
	if x.LastNavUpdate != nil {
		value := protoreflect.ValueOfMessage(x.LastNavUpdate.ProtoReflect())
		if !f(fd_VaultState_last_nav_update, value) {
			return
		}
	}
	if x.TotalAmountPendingWithdrawal != "" {
		value := protoreflect.ValueOfString(x.TotalAmountPendingWithdrawal)
		if !f(fd_VaultState_total_amount_pending_withdrawal, value) {
			return
		}
	}
	if x.PendingWithdrawalRequests != int32(0) {
		value := protoreflect.ValueOfInt32(x.PendingWithdrawalRequests)
		if !f(fd_VaultState_pending_withdrawal_requests, value) {
			return
		}
	}
	if x.TotalPositions != uint64(0) {
		value := protoreflect.ValueOfUint64(x.TotalPositions)
		if !f(fd_VaultState_total_positions, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_VaultState) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.VaultState.total_deposits":
		return x.TotalDeposits != ""
	case "noble.dollar.vaults.v2.VaultState.total_accrued_yield":
		return x.TotalAccruedYield != ""
	case "noble.dollar.vaults.v2.VaultState.total_nav":
		return x.TotalNav != ""
	case "noble.dollar.vaults.v2.VaultState.total_users":
		return x.TotalUsers != uint64(0)
	case "noble.dollar.vaults.v2.VaultState.deposits_enabled":
		return x.DepositsEnabled != false
	case "noble.dollar.vaults.v2.VaultState.withdrawals_enabled":
		return x.WithdrawalsEnabled != false
	case "noble.dollar.vaults.v2.VaultState.last_nav_update":
		return x.LastNavUpdate != nil
	case "noble.dollar.vaults.v2.VaultState.total_amount_pending_withdrawal":
		return x.TotalAmountPendingWithdrawal != ""
	case "noble.dollar.vaults.v2.VaultState.pending_withdrawal_requests":
		return x.PendingWithdrawalRequests != int32(0)
	case "noble.dollar.vaults.v2.VaultState.total_positions":
		return x.TotalPositions != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.VaultState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.VaultState does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VaultState) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.VaultState.total_deposits":
		x.TotalDeposits = ""
	case "noble.dollar.vaults.v2.VaultState.total_accrued_yield":
		x.TotalAccruedYield = ""
	case "noble.dollar.vaults.v2.VaultState.total_nav":
		x.TotalNav = ""
	case "noble.dollar.vaults.v2.VaultState.total_users":
		x.TotalUsers = uint64(0)
	case "noble.dollar.vaults.v2.VaultState.deposits_enabled":
		x.DepositsEnabled = false
	case "noble.dollar.vaults.v2.VaultState.withdrawals_enabled":
		x.WithdrawalsEnabled = false
	case "noble.dollar.vaults.v2.VaultState.last_nav_update":
		x.LastNavUpdate = nil
	case "noble.dollar.vaults.v2.VaultState.total_amount_pending_withdrawal":
		x.TotalAmountPendingWithdrawal = ""
	case "noble.dollar.vaults.v2.VaultState.pending_withdrawal_requests":
		x.PendingWithdrawalRequests = int32(0)
	case "noble.dollar.vaults.v2.VaultState.total_positions":
		x.TotalPositions = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.VaultState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.VaultState does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_VaultState) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.VaultState.total_deposits":
		value := x.TotalDeposits
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.VaultState.total_accrued_yield":
		value := x.TotalAccruedYield
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.VaultState.total_nav":
		value := x.TotalNav
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.VaultState.total_users":
		value := x.TotalUsers
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v2.VaultState.deposits_enabled":
		value := x.DepositsEnabled
		return protoreflect.ValueOfBool(value)
	case "noble.dollar.vaults.v2.VaultState.withdrawals_enabled":
		value := x.WithdrawalsEnabled
		return protoreflect.ValueOfBool(value)
	case "noble.dollar.vaults.v2.VaultState.last_nav_update":
		value := x.LastNavUpdate
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.VaultState.total_amount_pending_withdrawal":
		value := x.TotalAmountPendingWithdrawal
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.VaultState.pending_withdrawal_requests":
		value := x.PendingWithdrawalRequests
		return protoreflect.ValueOfInt32(value)
	case "noble.dollar.vaults.v2.VaultState.total_positions":
		value := x.TotalPositions
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.VaultState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.VaultState does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VaultState) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.VaultState.total_deposits":
		x.TotalDeposits = value.Interface().(string)
	case "noble.dollar.vaults.v2.VaultState.total_accrued_yield":
		x.TotalAccruedYield = value.Interface().(string)
	case "noble.dollar.vaults.v2.VaultState.total_nav":
		x.TotalNav = value.Interface().(string)
	case "noble.dollar.vaults.v2.VaultState.total_users":
		x.TotalUsers = value.Uint()
	case "noble.dollar.vaults.v2.VaultState.deposits_enabled":
		x.DepositsEnabled = value.Bool()
	case "noble.dollar.vaults.v2.VaultState.withdrawals_enabled":
		x.WithdrawalsEnabled = value.Bool()
	case "noble.dollar.vaults.v2.VaultState.last_nav_update":
		x.LastNavUpdate = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.VaultState.total_amount_pending_withdrawal":
		x.TotalAmountPendingWithdrawal = value.Interface().(string)
	case "noble.dollar.vaults.v2.VaultState.pending_withdrawal_requests":
		x.PendingWithdrawalRequests = int32(value.Int())
	case "noble.dollar.vaults.v2.VaultState.total_positions":
		x.TotalPositions = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.VaultState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.VaultState does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VaultState) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.VaultState.last_nav_update":
		if x.LastNavUpdate == nil {
			x.LastNavUpdate = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.LastNavUpdate.ProtoReflect())
	case "noble.dollar.vaults.v2.VaultState.total_deposits":
		panic(fmt.Errorf("field total_deposits of message noble.dollar.vaults.v2.VaultState is not mutable"))
	case "noble.dollar.vaults.v2.VaultState.total_accrued_yield":
		panic(fmt.Errorf("field total_accrued_yield of message noble.dollar.vaults.v2.VaultState is not mutable"))
	case "noble.dollar.vaults.v2.VaultState.total_nav":
		panic(fmt.Errorf("field total_nav of message noble.dollar.vaults.v2.VaultState is not mutable"))
	case "noble.dollar.vaults.v2.VaultState.total_users":
		panic(fmt.Errorf("field total_users of message noble.dollar.vaults.v2.VaultState is not mutable"))
	case "noble.dollar.vaults.v2.VaultState.deposits_enabled":
		panic(fmt.Errorf("field deposits_enabled of message noble.dollar.vaults.v2.VaultState is not mutable"))
	case "noble.dollar.vaults.v2.VaultState.withdrawals_enabled":
		panic(fmt.Errorf("field withdrawals_enabled of message noble.dollar.vaults.v2.VaultState is not mutable"))
	case "noble.dollar.vaults.v2.VaultState.total_amount_pending_withdrawal":
		panic(fmt.Errorf("field total_amount_pending_withdrawal of message noble.dollar.vaults.v2.VaultState is not mutable"))
	case "noble.dollar.vaults.v2.VaultState.pending_withdrawal_requests":
		panic(fmt.Errorf("field pending_withdrawal_requests of message noble.dollar.vaults.v2.VaultState is not mutable"))
	case "noble.dollar.vaults.v2.VaultState.total_positions":
		panic(fmt.Errorf("field total_positions of message noble.dollar.vaults.v2.VaultState is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.VaultState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.VaultState does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_VaultState) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.VaultState.total_deposits":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.VaultState.total_accrued_yield":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.VaultState.total_nav":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.VaultState.total_users":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v2.VaultState.deposits_enabled":
		return protoreflect.ValueOfBool(false)
	case "noble.dollar.vaults.v2.VaultState.withdrawals_enabled":
		return protoreflect.ValueOfBool(false)
	case "noble.dollar.vaults.v2.VaultState.last_nav_update":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.VaultState.total_amount_pending_withdrawal":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.VaultState.pending_withdrawal_requests":
		return protoreflect.ValueOfInt32(int32(0))
	case "noble.dollar.vaults.v2.VaultState.total_positions":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.VaultState"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.VaultState does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_VaultState) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.VaultState", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_VaultState) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_VaultState) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_VaultState) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_VaultState) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*VaultState)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TotalDeposits)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalAccruedYield)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalNav)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.TotalUsers != 0 {
			n += 1 + runtime.Sov(uint64(x.TotalUsers))
		}
		if x.DepositsEnabled {
			n += 2
		}
		if x.WithdrawalsEnabled {
			n += 2
		}
		if x.LastNavUpdate != nil {
			l = options.Size(x.LastNavUpdate)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalAmountPendingWithdrawal)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PendingWithdrawalRequests != 0 {
			n += 1 + runtime.Sov(uint64(x.PendingWithdrawalRequests))
		}
		if x.TotalPositions != 0 {
			n += 1 + runtime.Sov(uint64(x.TotalPositions))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*VaultState)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.TotalPositions != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.TotalPositions))
			i--
			dAtA[i] = 0x50
		}
		if x.PendingWithdrawalRequests != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PendingWithdrawalRequests))
			i--
			dAtA[i] = 0x48
		}
		if len(x.TotalAmountPendingWithdrawal) > 0 {
			i -= len(x.TotalAmountPendingWithdrawal)
			copy(dAtA[i:], x.TotalAmountPendingWithdrawal)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalAmountPendingWithdrawal)))
			i--
			dAtA[i] = 0x42
		}
		if x.LastNavUpdate != nil {
			encoded, err := options.Marshal(x.LastNavUpdate)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		if x.WithdrawalsEnabled {
			i--
			if x.WithdrawalsEnabled {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if x.DepositsEnabled {
			i--
			if x.DepositsEnabled {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if x.TotalUsers != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.TotalUsers))
			i--
			dAtA[i] = 0x20
		}
		if len(x.TotalNav) > 0 {
			i -= len(x.TotalNav)
			copy(dAtA[i:], x.TotalNav)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalNav)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.TotalAccruedYield) > 0 {
			i -= len(x.TotalAccruedYield)
			copy(dAtA[i:], x.TotalAccruedYield)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalAccruedYield)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.TotalDeposits) > 0 {
			i -= len(x.TotalDeposits)
			copy(dAtA[i:], x.TotalDeposits)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalDeposits)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*VaultState)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: VaultState: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: VaultState: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalDeposits", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalDeposits = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalAccruedYield", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalAccruedYield = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalNav", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalNav = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalUsers", wireType)
				}
				x.TotalUsers = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.TotalUsers |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DepositsEnabled", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.DepositsEnabled = bool(v != 0)
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WithdrawalsEnabled", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.WithdrawalsEnabled = bool(v != 0)
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastNavUpdate", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.LastNavUpdate == nil {
					x.LastNavUpdate = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LastNavUpdate); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalAmountPendingWithdrawal", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalAmountPendingWithdrawal = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PendingWithdrawalRequests", wireType)
				}
				x.PendingWithdrawalRequests = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PendingWithdrawalRequests |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalPositions", wireType)
				}
				x.TotalPositions = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.TotalPositions |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_YieldCalculation                  protoreflect.MessageDescriptor
	fd_YieldCalculation_total_deposits   protoreflect.FieldDescriptor
	fd_YieldCalculation_total_yield      protoreflect.FieldDescriptor
	fd_YieldCalculation_yield_rate       protoreflect.FieldDescriptor
	fd_YieldCalculation_calculation_time protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_YieldCalculation = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("YieldCalculation")
	fd_YieldCalculation_total_deposits = md_YieldCalculation.Fields().ByName("total_deposits")
	fd_YieldCalculation_total_yield = md_YieldCalculation.Fields().ByName("total_yield")
	fd_YieldCalculation_yield_rate = md_YieldCalculation.Fields().ByName("yield_rate")
	fd_YieldCalculation_calculation_time = md_YieldCalculation.Fields().ByName("calculation_time")
}

var _ protoreflect.Message = (*fastReflection_YieldCalculation)(nil)

type fastReflection_YieldCalculation YieldCalculation

func (x *YieldCalculation) ProtoReflect() protoreflect.Message {
	return (*fastReflection_YieldCalculation)(x)
}

func (x *YieldCalculation) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_YieldCalculation_messageType fastReflection_YieldCalculation_messageType
var _ protoreflect.MessageType = fastReflection_YieldCalculation_messageType{}

type fastReflection_YieldCalculation_messageType struct{}

func (x fastReflection_YieldCalculation_messageType) Zero() protoreflect.Message {
	return (*fastReflection_YieldCalculation)(nil)
}
func (x fastReflection_YieldCalculation_messageType) New() protoreflect.Message {
	return new(fastReflection_YieldCalculation)
}
func (x fastReflection_YieldCalculation_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_YieldCalculation
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_YieldCalculation) Descriptor() protoreflect.MessageDescriptor {
	return md_YieldCalculation
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_YieldCalculation) Type() protoreflect.MessageType {
	return _fastReflection_YieldCalculation_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_YieldCalculation) New() protoreflect.Message {
	return new(fastReflection_YieldCalculation)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_YieldCalculation) Interface() protoreflect.ProtoMessage {
	return (*YieldCalculation)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_YieldCalculation) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TotalDeposits != "" {
		value := protoreflect.ValueOfString(x.TotalDeposits)
		if !f(fd_YieldCalculation_total_deposits, value) {
			return
		}
	}
	if x.TotalYield != "" {
		value := protoreflect.ValueOfString(x.TotalYield)
		if !f(fd_YieldCalculation_total_yield, value) {
			return
		}
	}
	if x.YieldRate != "" {
		value := protoreflect.ValueOfString(x.YieldRate)
		if !f(fd_YieldCalculation_yield_rate, value) {
			return
		}
	}
	if x.CalculationTime != nil {
		value := protoreflect.ValueOfMessage(x.CalculationTime.ProtoReflect())
		if !f(fd_YieldCalculation_calculation_time, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_YieldCalculation) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.YieldCalculation.total_deposits":
		return x.TotalDeposits != ""
	case "noble.dollar.vaults.v2.YieldCalculation.total_yield":
		return x.TotalYield != ""
	case "noble.dollar.vaults.v2.YieldCalculation.yield_rate":
		return x.YieldRate != ""
	case "noble.dollar.vaults.v2.YieldCalculation.calculation_time":
		return x.CalculationTime != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldCalculation"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldCalculation does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_YieldCalculation) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.YieldCalculation.total_deposits":
		x.TotalDeposits = ""
	case "noble.dollar.vaults.v2.YieldCalculation.total_yield":
		x.TotalYield = ""
	case "noble.dollar.vaults.v2.YieldCalculation.yield_rate":
		x.YieldRate = ""
	case "noble.dollar.vaults.v2.YieldCalculation.calculation_time":
		x.CalculationTime = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldCalculation"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldCalculation does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_YieldCalculation) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.YieldCalculation.total_deposits":
		value := x.TotalDeposits
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.YieldCalculation.total_yield":
		value := x.TotalYield
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.YieldCalculation.yield_rate":
		value := x.YieldRate
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.YieldCalculation.calculation_time":
		value := x.CalculationTime
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldCalculation"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldCalculation does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_YieldCalculation) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.YieldCalculation.total_deposits":
		x.TotalDeposits = value.Interface().(string)
	case "noble.dollar.vaults.v2.YieldCalculation.total_yield":
		x.TotalYield = value.Interface().(string)
	case "noble.dollar.vaults.v2.YieldCalculation.yield_rate":
		x.YieldRate = value.Interface().(string)
	case "noble.dollar.vaults.v2.YieldCalculation.calculation_time":
		x.CalculationTime = value.Message().Interface().(*timestamppb.Timestamp)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldCalculation"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldCalculation does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_YieldCalculation) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.YieldCalculation.calculation_time":
		if x.CalculationTime == nil {
			x.CalculationTime = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.CalculationTime.ProtoReflect())
	case "noble.dollar.vaults.v2.YieldCalculation.total_deposits":
		panic(fmt.Errorf("field total_deposits of message noble.dollar.vaults.v2.YieldCalculation is not mutable"))
	case "noble.dollar.vaults.v2.YieldCalculation.total_yield":
		panic(fmt.Errorf("field total_yield of message noble.dollar.vaults.v2.YieldCalculation is not mutable"))
	case "noble.dollar.vaults.v2.YieldCalculation.yield_rate":
		panic(fmt.Errorf("field yield_rate of message noble.dollar.vaults.v2.YieldCalculation is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldCalculation"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldCalculation does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_YieldCalculation) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.YieldCalculation.total_deposits":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.YieldCalculation.total_yield":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.YieldCalculation.yield_rate":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.YieldCalculation.calculation_time":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldCalculation"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldCalculation does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_YieldCalculation) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.YieldCalculation", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_YieldCalculation) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_YieldCalculation) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_YieldCalculation) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_YieldCalculation) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*YieldCalculation)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TotalDeposits)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalYield)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.YieldRate)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CalculationTime != nil {
			l = options.Size(x.CalculationTime)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*YieldCalculation)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CalculationTime != nil {
			encoded, err := options.Marshal(x.CalculationTime)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.YieldRate) > 0 {
			i -= len(x.YieldRate)
			copy(dAtA[i:], x.YieldRate)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.YieldRate)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.TotalYield) > 0 {
			i -= len(x.TotalYield)
			copy(dAtA[i:], x.TotalYield)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalYield)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.TotalDeposits) > 0 {
			i -= len(x.TotalDeposits)
			copy(dAtA[i:], x.TotalDeposits)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalDeposits)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*YieldCalculation)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: YieldCalculation: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: YieldCalculation: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalDeposits", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalDeposits = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalYield", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalYield = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field YieldRate", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.YieldRate = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CalculationTime", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CalculationTime == nil {
					x.CalculationTime = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CalculationTime); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_DepositResult                  protoreflect.MessageDescriptor
	fd_DepositResult_amount_deposited protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_DepositResult = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("DepositResult")
	fd_DepositResult_amount_deposited = md_DepositResult.Fields().ByName("amount_deposited")
}

var _ protoreflect.Message = (*fastReflection_DepositResult)(nil)

type fastReflection_DepositResult DepositResult

func (x *DepositResult) ProtoReflect() protoreflect.Message {
	return (*fastReflection_DepositResult)(x)
}

func (x *DepositResult) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_DepositResult_messageType fastReflection_DepositResult_messageType
var _ protoreflect.MessageType = fastReflection_DepositResult_messageType{}

type fastReflection_DepositResult_messageType struct{}

func (x fastReflection_DepositResult_messageType) Zero() protoreflect.Message {
	return (*fastReflection_DepositResult)(nil)
}
func (x fastReflection_DepositResult_messageType) New() protoreflect.Message {
	return new(fastReflection_DepositResult)
}
func (x fastReflection_DepositResult_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_DepositResult
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_DepositResult) Descriptor() protoreflect.MessageDescriptor {
	return md_DepositResult
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_DepositResult) Type() protoreflect.MessageType {
	return _fastReflection_DepositResult_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_DepositResult) New() protoreflect.Message {
	return new(fastReflection_DepositResult)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_DepositResult) Interface() protoreflect.ProtoMessage {
	return (*DepositResult)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_DepositResult) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.AmountDeposited != "" {
		value := protoreflect.ValueOfString(x.AmountDeposited)
		if !f(fd_DepositResult_amount_deposited, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_DepositResult) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositResult.amount_deposited":
		return x.AmountDeposited != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositResult does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositResult) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositResult.amount_deposited":
		x.AmountDeposited = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositResult does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_DepositResult) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.DepositResult.amount_deposited":
		value := x.AmountDeposited
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositResult does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositResult) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositResult.amount_deposited":
		x.AmountDeposited = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositResult does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositResult) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositResult.amount_deposited":
		panic(fmt.Errorf("field amount_deposited of message noble.dollar.vaults.v2.DepositResult is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositResult does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_DepositResult) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositResult.amount_deposited":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositResult does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_DepositResult) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.DepositResult", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_DepositResult) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositResult) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_DepositResult) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_DepositResult) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*DepositResult)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.AmountDeposited)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*DepositResult)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AmountDeposited) > 0 {
			i -= len(x.AmountDeposited)
			copy(dAtA[i:], x.AmountDeposited)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AmountDeposited)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*DepositResult)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DepositResult: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DepositResult: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AmountDeposited", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AmountDeposited = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_WithdrawalResult                       protoreflect.MessageDescriptor
	fd_WithdrawalResult_principal_withdrawn   protoreflect.FieldDescriptor
	fd_WithdrawalResult_yield_withdrawn       protoreflect.FieldDescriptor
	fd_WithdrawalResult_fees_paid             protoreflect.FieldDescriptor
	fd_WithdrawalResult_total_amount_received protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_WithdrawalResult = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("WithdrawalResult")
	fd_WithdrawalResult_principal_withdrawn = md_WithdrawalResult.Fields().ByName("principal_withdrawn")
	fd_WithdrawalResult_yield_withdrawn = md_WithdrawalResult.Fields().ByName("yield_withdrawn")
	fd_WithdrawalResult_fees_paid = md_WithdrawalResult.Fields().ByName("fees_paid")
	fd_WithdrawalResult_total_amount_received = md_WithdrawalResult.Fields().ByName("total_amount_received")
}

var _ protoreflect.Message = (*fastReflection_WithdrawalResult)(nil)

type fastReflection_WithdrawalResult WithdrawalResult

func (x *WithdrawalResult) ProtoReflect() protoreflect.Message {
	return (*fastReflection_WithdrawalResult)(x)
}

func (x *WithdrawalResult) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_WithdrawalResult_messageType fastReflection_WithdrawalResult_messageType
var _ protoreflect.MessageType = fastReflection_WithdrawalResult_messageType{}

type fastReflection_WithdrawalResult_messageType struct{}

func (x fastReflection_WithdrawalResult_messageType) Zero() protoreflect.Message {
	return (*fastReflection_WithdrawalResult)(nil)
}
func (x fastReflection_WithdrawalResult_messageType) New() protoreflect.Message {
	return new(fastReflection_WithdrawalResult)
}
func (x fastReflection_WithdrawalResult_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_WithdrawalResult
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_WithdrawalResult) Descriptor() protoreflect.MessageDescriptor {
	return md_WithdrawalResult
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_WithdrawalResult) Type() protoreflect.MessageType {
	return _fastReflection_WithdrawalResult_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_WithdrawalResult) New() protoreflect.Message {
	return new(fastReflection_WithdrawalResult)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_WithdrawalResult) Interface() protoreflect.ProtoMessage {
	return (*WithdrawalResult)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_WithdrawalResult) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PrincipalWithdrawn != "" {
		value := protoreflect.ValueOfString(x.PrincipalWithdrawn)
		if !f(fd_WithdrawalResult_principal_withdrawn, value) {
			return
		}
	}
	if x.YieldWithdrawn != "" {
		value := protoreflect.ValueOfString(x.YieldWithdrawn)
		if !f(fd_WithdrawalResult_yield_withdrawn, value) {
			return
		}
	}
	if x.FeesPaid != "" {
		value := protoreflect.ValueOfString(x.FeesPaid)
		if !f(fd_WithdrawalResult_fees_paid, value) {
			return
		}
	}
	if x.TotalAmountReceived != "" {
		value := protoreflect.ValueOfString(x.TotalAmountReceived)
		if !f(fd_WithdrawalResult_total_amount_received, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_WithdrawalResult) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalResult.principal_withdrawn":
		return x.PrincipalWithdrawn != ""
	case "noble.dollar.vaults.v2.WithdrawalResult.yield_withdrawn":
		return x.YieldWithdrawn != ""
	case "noble.dollar.vaults.v2.WithdrawalResult.fees_paid":
		return x.FeesPaid != ""
	case "noble.dollar.vaults.v2.WithdrawalResult.total_amount_received":
		return x.TotalAmountReceived != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalResult does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WithdrawalResult) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalResult.principal_withdrawn":
		x.PrincipalWithdrawn = ""
	case "noble.dollar.vaults.v2.WithdrawalResult.yield_withdrawn":
		x.YieldWithdrawn = ""
	case "noble.dollar.vaults.v2.WithdrawalResult.fees_paid":
		x.FeesPaid = ""
	case "noble.dollar.vaults.v2.WithdrawalResult.total_amount_received":
		x.TotalAmountReceived = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalResult does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_WithdrawalResult) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalResult.principal_withdrawn":
		value := x.PrincipalWithdrawn
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.WithdrawalResult.yield_withdrawn":
		value := x.YieldWithdrawn
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.WithdrawalResult.fees_paid":
		value := x.FeesPaid
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.WithdrawalResult.total_amount_received":
		value := x.TotalAmountReceived
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalResult does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WithdrawalResult) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalResult.principal_withdrawn":
		x.PrincipalWithdrawn = value.Interface().(string)
	case "noble.dollar.vaults.v2.WithdrawalResult.yield_withdrawn":
		x.YieldWithdrawn = value.Interface().(string)
	case "noble.dollar.vaults.v2.WithdrawalResult.fees_paid":
		x.FeesPaid = value.Interface().(string)
	case "noble.dollar.vaults.v2.WithdrawalResult.total_amount_received":
		x.TotalAmountReceived = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalResult does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WithdrawalResult) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalResult.principal_withdrawn":
		panic(fmt.Errorf("field principal_withdrawn of message noble.dollar.vaults.v2.WithdrawalResult is not mutable"))
	case "noble.dollar.vaults.v2.WithdrawalResult.yield_withdrawn":
		panic(fmt.Errorf("field yield_withdrawn of message noble.dollar.vaults.v2.WithdrawalResult is not mutable"))
	case "noble.dollar.vaults.v2.WithdrawalResult.fees_paid":
		panic(fmt.Errorf("field fees_paid of message noble.dollar.vaults.v2.WithdrawalResult is not mutable"))
	case "noble.dollar.vaults.v2.WithdrawalResult.total_amount_received":
		panic(fmt.Errorf("field total_amount_received of message noble.dollar.vaults.v2.WithdrawalResult is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalResult does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_WithdrawalResult) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.WithdrawalResult.principal_withdrawn":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.WithdrawalResult.yield_withdrawn":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.WithdrawalResult.fees_paid":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.WithdrawalResult.total_amount_received":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.WithdrawalResult"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.WithdrawalResult does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_WithdrawalResult) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.WithdrawalResult", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_WithdrawalResult) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_WithdrawalResult) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_WithdrawalResult) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_WithdrawalResult) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*WithdrawalResult)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PrincipalWithdrawn)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.YieldWithdrawn)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.FeesPaid)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalAmountReceived)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*WithdrawalResult)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TotalAmountReceived) > 0 {
			i -= len(x.TotalAmountReceived)
			copy(dAtA[i:], x.TotalAmountReceived)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalAmountReceived)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.FeesPaid) > 0 {
			i -= len(x.FeesPaid)
			copy(dAtA[i:], x.FeesPaid)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FeesPaid)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.YieldWithdrawn) > 0 {
			i -= len(x.YieldWithdrawn)
			copy(dAtA[i:], x.YieldWithdrawn)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.YieldWithdrawn)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.PrincipalWithdrawn) > 0 {
			i -= len(x.PrincipalWithdrawn)
			copy(dAtA[i:], x.PrincipalWithdrawn)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrincipalWithdrawn)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*WithdrawalResult)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: WithdrawalResult: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: WithdrawalResult: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrincipalWithdrawn", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrincipalWithdrawn = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field YieldWithdrawn", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.YieldWithdrawn = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FeesPaid", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FeesPaid = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalAmountReceived", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalAmountReceived = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_YieldDistribution                     protoreflect.MessageDescriptor
	fd_YieldDistribution_total_yield         protoreflect.FieldDescriptor
	fd_YieldDistribution_yield_rate          protoreflect.FieldDescriptor
	fd_YieldDistribution_distribution_time   protoreflect.FieldDescriptor
	fd_YieldDistribution_eligible_depositors protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_YieldDistribution = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("YieldDistribution")
	fd_YieldDistribution_total_yield = md_YieldDistribution.Fields().ByName("total_yield")
	fd_YieldDistribution_yield_rate = md_YieldDistribution.Fields().ByName("yield_rate")
	fd_YieldDistribution_distribution_time = md_YieldDistribution.Fields().ByName("distribution_time")
	fd_YieldDistribution_eligible_depositors = md_YieldDistribution.Fields().ByName("eligible_depositors")
}

var _ protoreflect.Message = (*fastReflection_YieldDistribution)(nil)

type fastReflection_YieldDistribution YieldDistribution

func (x *YieldDistribution) ProtoReflect() protoreflect.Message {
	return (*fastReflection_YieldDistribution)(x)
}

func (x *YieldDistribution) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_YieldDistribution_messageType fastReflection_YieldDistribution_messageType
var _ protoreflect.MessageType = fastReflection_YieldDistribution_messageType{}

type fastReflection_YieldDistribution_messageType struct{}

func (x fastReflection_YieldDistribution_messageType) Zero() protoreflect.Message {
	return (*fastReflection_YieldDistribution)(nil)
}
func (x fastReflection_YieldDistribution_messageType) New() protoreflect.Message {
	return new(fastReflection_YieldDistribution)
}
func (x fastReflection_YieldDistribution_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_YieldDistribution
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_YieldDistribution) Descriptor() protoreflect.MessageDescriptor {
	return md_YieldDistribution
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_YieldDistribution) Type() protoreflect.MessageType {
	return _fastReflection_YieldDistribution_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_YieldDistribution) New() protoreflect.Message {
	return new(fastReflection_YieldDistribution)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_YieldDistribution) Interface() protoreflect.ProtoMessage {
	return (*YieldDistribution)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_YieldDistribution) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TotalYield != "" {
		value := protoreflect.ValueOfString(x.TotalYield)
		if !f(fd_YieldDistribution_total_yield, value) {
			return
		}
	}
	if x.YieldRate != "" {
		value := protoreflect.ValueOfString(x.YieldRate)
		if !f(fd_YieldDistribution_yield_rate, value) {
			return
		}
	}
	if x.DistributionTime != nil {
		value := protoreflect.ValueOfMessage(x.DistributionTime.ProtoReflect())
		if !f(fd_YieldDistribution_distribution_time, value) {
			return
		}
	}
	if x.EligibleDepositors != uint64(0) {
		value := protoreflect.ValueOfUint64(x.EligibleDepositors)
		if !f(fd_YieldDistribution_eligible_depositors, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_YieldDistribution) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.YieldDistribution.total_yield":
		return x.TotalYield != ""
	case "noble.dollar.vaults.v2.YieldDistribution.yield_rate":
		return x.YieldRate != ""
	case "noble.dollar.vaults.v2.YieldDistribution.distribution_time":
		return x.DistributionTime != nil
	case "noble.dollar.vaults.v2.YieldDistribution.eligible_depositors":
		return x.EligibleDepositors != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldDistribution"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldDistribution does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_YieldDistribution) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.YieldDistribution.total_yield":
		x.TotalYield = ""
	case "noble.dollar.vaults.v2.YieldDistribution.yield_rate":
		x.YieldRate = ""
	case "noble.dollar.vaults.v2.YieldDistribution.distribution_time":
		x.DistributionTime = nil
	case "noble.dollar.vaults.v2.YieldDistribution.eligible_depositors":
		x.EligibleDepositors = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldDistribution"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldDistribution does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_YieldDistribution) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.YieldDistribution.total_yield":
		value := x.TotalYield
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.YieldDistribution.yield_rate":
		value := x.YieldRate
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.YieldDistribution.distribution_time":
		value := x.DistributionTime
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.YieldDistribution.eligible_depositors":
		value := x.EligibleDepositors
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldDistribution"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldDistribution does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_YieldDistribution) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.YieldDistribution.total_yield":
		x.TotalYield = value.Interface().(string)
	case "noble.dollar.vaults.v2.YieldDistribution.yield_rate":
		x.YieldRate = value.Interface().(string)
	case "noble.dollar.vaults.v2.YieldDistribution.distribution_time":
		x.DistributionTime = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.YieldDistribution.eligible_depositors":
		x.EligibleDepositors = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldDistribution"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldDistribution does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_YieldDistribution) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.YieldDistribution.distribution_time":
		if x.DistributionTime == nil {
			x.DistributionTime = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.DistributionTime.ProtoReflect())
	case "noble.dollar.vaults.v2.YieldDistribution.total_yield":
		panic(fmt.Errorf("field total_yield of message noble.dollar.vaults.v2.YieldDistribution is not mutable"))
	case "noble.dollar.vaults.v2.YieldDistribution.yield_rate":
		panic(fmt.Errorf("field yield_rate of message noble.dollar.vaults.v2.YieldDistribution is not mutable"))
	case "noble.dollar.vaults.v2.YieldDistribution.eligible_depositors":
		panic(fmt.Errorf("field eligible_depositors of message noble.dollar.vaults.v2.YieldDistribution is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldDistribution"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldDistribution does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_YieldDistribution) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.YieldDistribution.total_yield":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.YieldDistribution.yield_rate":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.YieldDistribution.distribution_time":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.YieldDistribution.eligible_depositors":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.YieldDistribution"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.YieldDistribution does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_YieldDistribution) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.YieldDistribution", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_YieldDistribution) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_YieldDistribution) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_YieldDistribution) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_YieldDistribution) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*YieldDistribution)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TotalYield)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.YieldRate)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.DistributionTime != nil {
			l = options.Size(x.DistributionTime)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.EligibleDepositors != 0 {
			n += 1 + runtime.Sov(uint64(x.EligibleDepositors))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*YieldDistribution)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.EligibleDepositors != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.EligibleDepositors))
			i--
			dAtA[i] = 0x20
		}
		if x.DistributionTime != nil {
			encoded, err := options.Marshal(x.DistributionTime)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.YieldRate) > 0 {
			i -= len(x.YieldRate)
			copy(dAtA[i:], x.YieldRate)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.YieldRate)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.TotalYield) > 0 {
			i -= len(x.TotalYield)
			copy(dAtA[i:], x.TotalYield)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalYield)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*YieldDistribution)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: YieldDistribution: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: YieldDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalYield", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalYield = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field YieldRate", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.YieldRate = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DistributionTime", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.DistributionTime == nil {
					x.DistributionTime = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.DistributionTime); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EligibleDepositors", wireType)
				}
				x.EligibleDepositors = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.EligibleDepositors |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_DepositLimit                             protoreflect.MessageDescriptor
	fd_DepositLimit_max_user_deposit_per_window protoreflect.FieldDescriptor
	fd_DepositLimit_max_block_deposit_volume    protoreflect.FieldDescriptor
	fd_DepositLimit_global_deposit_cap          protoreflect.FieldDescriptor
	fd_DepositLimit_deposit_cooldown_blocks     protoreflect.FieldDescriptor
	fd_DepositLimit_velocity_window_blocks      protoreflect.FieldDescriptor
	fd_DepositLimit_max_deposits_per_window     protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_DepositLimit = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("DepositLimit")
	fd_DepositLimit_max_user_deposit_per_window = md_DepositLimit.Fields().ByName("max_user_deposit_per_window")
	fd_DepositLimit_max_block_deposit_volume = md_DepositLimit.Fields().ByName("max_block_deposit_volume")
	fd_DepositLimit_global_deposit_cap = md_DepositLimit.Fields().ByName("global_deposit_cap")
	fd_DepositLimit_deposit_cooldown_blocks = md_DepositLimit.Fields().ByName("deposit_cooldown_blocks")
	fd_DepositLimit_velocity_window_blocks = md_DepositLimit.Fields().ByName("velocity_window_blocks")
	fd_DepositLimit_max_deposits_per_window = md_DepositLimit.Fields().ByName("max_deposits_per_window")
}

var _ protoreflect.Message = (*fastReflection_DepositLimit)(nil)

type fastReflection_DepositLimit DepositLimit

func (x *DepositLimit) ProtoReflect() protoreflect.Message {
	return (*fastReflection_DepositLimit)(x)
}

func (x *DepositLimit) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_DepositLimit_messageType fastReflection_DepositLimit_messageType
var _ protoreflect.MessageType = fastReflection_DepositLimit_messageType{}

type fastReflection_DepositLimit_messageType struct{}

func (x fastReflection_DepositLimit_messageType) Zero() protoreflect.Message {
	return (*fastReflection_DepositLimit)(nil)
}
func (x fastReflection_DepositLimit_messageType) New() protoreflect.Message {
	return new(fastReflection_DepositLimit)
}
func (x fastReflection_DepositLimit_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_DepositLimit
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_DepositLimit) Descriptor() protoreflect.MessageDescriptor {
	return md_DepositLimit
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_DepositLimit) Type() protoreflect.MessageType {
	return _fastReflection_DepositLimit_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_DepositLimit) New() protoreflect.Message {
	return new(fastReflection_DepositLimit)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_DepositLimit) Interface() protoreflect.ProtoMessage {
	return (*DepositLimit)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_DepositLimit) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.MaxUserDepositPerWindow != "" {
		value := protoreflect.ValueOfString(x.MaxUserDepositPerWindow)
		if !f(fd_DepositLimit_max_user_deposit_per_window, value) {
			return
		}
	}
	if x.MaxBlockDepositVolume != "" {
		value := protoreflect.ValueOfString(x.MaxBlockDepositVolume)
		if !f(fd_DepositLimit_max_block_deposit_volume, value) {
			return
		}
	}
	if x.GlobalDepositCap != "" {
		value := protoreflect.ValueOfString(x.GlobalDepositCap)
		if !f(fd_DepositLimit_global_deposit_cap, value) {
			return
		}
	}
	if x.DepositCooldownBlocks != int64(0) {
		value := protoreflect.ValueOfInt64(x.DepositCooldownBlocks)
		if !f(fd_DepositLimit_deposit_cooldown_blocks, value) {
			return
		}
	}
	if x.VelocityWindowBlocks != int64(0) {
		value := protoreflect.ValueOfInt64(x.VelocityWindowBlocks)
		if !f(fd_DepositLimit_velocity_window_blocks, value) {
			return
		}
	}
	if x.MaxDepositsPerWindow != uint32(0) {
		value := protoreflect.ValueOfUint32(x.MaxDepositsPerWindow)
		if !f(fd_DepositLimit_max_deposits_per_window, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_DepositLimit) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositLimit.max_user_deposit_per_window":
		return x.MaxUserDepositPerWindow != ""
	case "noble.dollar.vaults.v2.DepositLimit.max_block_deposit_volume":
		return x.MaxBlockDepositVolume != ""
	case "noble.dollar.vaults.v2.DepositLimit.global_deposit_cap":
		return x.GlobalDepositCap != ""
	case "noble.dollar.vaults.v2.DepositLimit.deposit_cooldown_blocks":
		return x.DepositCooldownBlocks != int64(0)
	case "noble.dollar.vaults.v2.DepositLimit.velocity_window_blocks":
		return x.VelocityWindowBlocks != int64(0)
	case "noble.dollar.vaults.v2.DepositLimit.max_deposits_per_window":
		return x.MaxDepositsPerWindow != uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositLimit"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositLimit does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositLimit) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositLimit.max_user_deposit_per_window":
		x.MaxUserDepositPerWindow = ""
	case "noble.dollar.vaults.v2.DepositLimit.max_block_deposit_volume":
		x.MaxBlockDepositVolume = ""
	case "noble.dollar.vaults.v2.DepositLimit.global_deposit_cap":
		x.GlobalDepositCap = ""
	case "noble.dollar.vaults.v2.DepositLimit.deposit_cooldown_blocks":
		x.DepositCooldownBlocks = int64(0)
	case "noble.dollar.vaults.v2.DepositLimit.velocity_window_blocks":
		x.VelocityWindowBlocks = int64(0)
	case "noble.dollar.vaults.v2.DepositLimit.max_deposits_per_window":
		x.MaxDepositsPerWindow = uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositLimit"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositLimit does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_DepositLimit) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.DepositLimit.max_user_deposit_per_window":
		value := x.MaxUserDepositPerWindow
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.DepositLimit.max_block_deposit_volume":
		value := x.MaxBlockDepositVolume
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.DepositLimit.global_deposit_cap":
		value := x.GlobalDepositCap
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.DepositLimit.deposit_cooldown_blocks":
		value := x.DepositCooldownBlocks
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.DepositLimit.velocity_window_blocks":
		value := x.VelocityWindowBlocks
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.DepositLimit.max_deposits_per_window":
		value := x.MaxDepositsPerWindow
		return protoreflect.ValueOfUint32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositLimit"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositLimit does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositLimit) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositLimit.max_user_deposit_per_window":
		x.MaxUserDepositPerWindow = value.Interface().(string)
	case "noble.dollar.vaults.v2.DepositLimit.max_block_deposit_volume":
		x.MaxBlockDepositVolume = value.Interface().(string)
	case "noble.dollar.vaults.v2.DepositLimit.global_deposit_cap":
		x.GlobalDepositCap = value.Interface().(string)
	case "noble.dollar.vaults.v2.DepositLimit.deposit_cooldown_blocks":
		x.DepositCooldownBlocks = value.Int()
	case "noble.dollar.vaults.v2.DepositLimit.velocity_window_blocks":
		x.VelocityWindowBlocks = value.Int()
	case "noble.dollar.vaults.v2.DepositLimit.max_deposits_per_window":
		x.MaxDepositsPerWindow = uint32(value.Uint())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositLimit"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositLimit does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositLimit) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositLimit.max_user_deposit_per_window":
		panic(fmt.Errorf("field max_user_deposit_per_window of message noble.dollar.vaults.v2.DepositLimit is not mutable"))
	case "noble.dollar.vaults.v2.DepositLimit.max_block_deposit_volume":
		panic(fmt.Errorf("field max_block_deposit_volume of message noble.dollar.vaults.v2.DepositLimit is not mutable"))
	case "noble.dollar.vaults.v2.DepositLimit.global_deposit_cap":
		panic(fmt.Errorf("field global_deposit_cap of message noble.dollar.vaults.v2.DepositLimit is not mutable"))
	case "noble.dollar.vaults.v2.DepositLimit.deposit_cooldown_blocks":
		panic(fmt.Errorf("field deposit_cooldown_blocks of message noble.dollar.vaults.v2.DepositLimit is not mutable"))
	case "noble.dollar.vaults.v2.DepositLimit.velocity_window_blocks":
		panic(fmt.Errorf("field velocity_window_blocks of message noble.dollar.vaults.v2.DepositLimit is not mutable"))
	case "noble.dollar.vaults.v2.DepositLimit.max_deposits_per_window":
		panic(fmt.Errorf("field max_deposits_per_window of message noble.dollar.vaults.v2.DepositLimit is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositLimit"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositLimit does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_DepositLimit) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositLimit.max_user_deposit_per_window":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.DepositLimit.max_block_deposit_volume":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.DepositLimit.global_deposit_cap":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.DepositLimit.deposit_cooldown_blocks":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.DepositLimit.velocity_window_blocks":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.DepositLimit.max_deposits_per_window":
		return protoreflect.ValueOfUint32(uint32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositLimit"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositLimit does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_DepositLimit) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.DepositLimit", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_DepositLimit) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositLimit) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_DepositLimit) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_DepositLimit) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*DepositLimit)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.MaxUserDepositPerWindow)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MaxBlockDepositVolume)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.GlobalDepositCap)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.DepositCooldownBlocks != 0 {
			n += 1 + runtime.Sov(uint64(x.DepositCooldownBlocks))
		}
		if x.VelocityWindowBlocks != 0 {
			n += 1 + runtime.Sov(uint64(x.VelocityWindowBlocks))
		}
		if x.MaxDepositsPerWindow != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxDepositsPerWindow))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*DepositLimit)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.MaxDepositsPerWindow != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxDepositsPerWindow))
			i--
			dAtA[i] = 0x30
		}
		if x.VelocityWindowBlocks != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.VelocityWindowBlocks))
			i--
			dAtA[i] = 0x28
		}
		if x.DepositCooldownBlocks != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.DepositCooldownBlocks))
			i--
			dAtA[i] = 0x20
		}
		if len(x.GlobalDepositCap) > 0 {
			i -= len(x.GlobalDepositCap)
			copy(dAtA[i:], x.GlobalDepositCap)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.GlobalDepositCap)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.MaxBlockDepositVolume) > 0 {
			i -= len(x.MaxBlockDepositVolume)
			copy(dAtA[i:], x.MaxBlockDepositVolume)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MaxBlockDepositVolume)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.MaxUserDepositPerWindow) > 0 {
			i -= len(x.MaxUserDepositPerWindow)
			copy(dAtA[i:], x.MaxUserDepositPerWindow)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MaxUserDepositPerWindow)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*DepositLimit)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DepositLimit: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DepositLimit: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxUserDepositPerWindow", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MaxUserDepositPerWindow = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxBlockDepositVolume", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MaxBlockDepositVolume = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GlobalDepositCap", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.GlobalDepositCap = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DepositCooldownBlocks", wireType)
				}
				x.DepositCooldownBlocks = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.DepositCooldownBlocks |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VelocityWindowBlocks", wireType)
				}
				x.VelocityWindowBlocks = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.VelocityWindowBlocks |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxDepositsPerWindow", wireType)
				}
				x.MaxDepositsPerWindow = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxDepositsPerWindow |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_DepositVelocity                       protoreflect.MessageDescriptor
	fd_DepositVelocity_last_deposit_block    protoreflect.FieldDescriptor
	fd_DepositVelocity_recent_deposit_count  protoreflect.FieldDescriptor
	fd_DepositVelocity_recent_deposit_volume protoreflect.FieldDescriptor
	fd_DepositVelocity_time_window_blocks    protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_DepositVelocity = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("DepositVelocity")
	fd_DepositVelocity_last_deposit_block = md_DepositVelocity.Fields().ByName("last_deposit_block")
	fd_DepositVelocity_recent_deposit_count = md_DepositVelocity.Fields().ByName("recent_deposit_count")
	fd_DepositVelocity_recent_deposit_volume = md_DepositVelocity.Fields().ByName("recent_deposit_volume")
	fd_DepositVelocity_time_window_blocks = md_DepositVelocity.Fields().ByName("time_window_blocks")
}

var _ protoreflect.Message = (*fastReflection_DepositVelocity)(nil)

type fastReflection_DepositVelocity DepositVelocity

func (x *DepositVelocity) ProtoReflect() protoreflect.Message {
	return (*fastReflection_DepositVelocity)(x)
}

func (x *DepositVelocity) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_DepositVelocity_messageType fastReflection_DepositVelocity_messageType
var _ protoreflect.MessageType = fastReflection_DepositVelocity_messageType{}

type fastReflection_DepositVelocity_messageType struct{}

func (x fastReflection_DepositVelocity_messageType) Zero() protoreflect.Message {
	return (*fastReflection_DepositVelocity)(nil)
}
func (x fastReflection_DepositVelocity_messageType) New() protoreflect.Message {
	return new(fastReflection_DepositVelocity)
}
func (x fastReflection_DepositVelocity_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_DepositVelocity
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_DepositVelocity) Descriptor() protoreflect.MessageDescriptor {
	return md_DepositVelocity
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_DepositVelocity) Type() protoreflect.MessageType {
	return _fastReflection_DepositVelocity_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_DepositVelocity) New() protoreflect.Message {
	return new(fastReflection_DepositVelocity)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_DepositVelocity) Interface() protoreflect.ProtoMessage {
	return (*DepositVelocity)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_DepositVelocity) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.LastDepositBlock != int64(0) {
		value := protoreflect.ValueOfInt64(x.LastDepositBlock)
		if !f(fd_DepositVelocity_last_deposit_block, value) {
			return
		}
	}
	if x.RecentDepositCount != uint32(0) {
		value := protoreflect.ValueOfUint32(x.RecentDepositCount)
		if !f(fd_DepositVelocity_recent_deposit_count, value) {
			return
		}
	}
	if x.RecentDepositVolume != "" {
		value := protoreflect.ValueOfString(x.RecentDepositVolume)
		if !f(fd_DepositVelocity_recent_deposit_volume, value) {
			return
		}
	}
	if x.TimeWindowBlocks != int64(0) {
		value := protoreflect.ValueOfInt64(x.TimeWindowBlocks)
		if !f(fd_DepositVelocity_time_window_blocks, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_DepositVelocity) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositVelocity.last_deposit_block":
		return x.LastDepositBlock != int64(0)
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_count":
		return x.RecentDepositCount != uint32(0)
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_volume":
		return x.RecentDepositVolume != ""
	case "noble.dollar.vaults.v2.DepositVelocity.time_window_blocks":
		return x.TimeWindowBlocks != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositVelocity"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositVelocity does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositVelocity) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositVelocity.last_deposit_block":
		x.LastDepositBlock = int64(0)
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_count":
		x.RecentDepositCount = uint32(0)
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_volume":
		x.RecentDepositVolume = ""
	case "noble.dollar.vaults.v2.DepositVelocity.time_window_blocks":
		x.TimeWindowBlocks = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositVelocity"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositVelocity does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_DepositVelocity) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.DepositVelocity.last_deposit_block":
		value := x.LastDepositBlock
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_count":
		value := x.RecentDepositCount
		return protoreflect.ValueOfUint32(value)
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_volume":
		value := x.RecentDepositVolume
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.DepositVelocity.time_window_blocks":
		value := x.TimeWindowBlocks
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositVelocity"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositVelocity does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositVelocity) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositVelocity.last_deposit_block":
		x.LastDepositBlock = value.Int()
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_count":
		x.RecentDepositCount = uint32(value.Uint())
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_volume":
		x.RecentDepositVolume = value.Interface().(string)
	case "noble.dollar.vaults.v2.DepositVelocity.time_window_blocks":
		x.TimeWindowBlocks = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositVelocity"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositVelocity does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositVelocity) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositVelocity.last_deposit_block":
		panic(fmt.Errorf("field last_deposit_block of message noble.dollar.vaults.v2.DepositVelocity is not mutable"))
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_count":
		panic(fmt.Errorf("field recent_deposit_count of message noble.dollar.vaults.v2.DepositVelocity is not mutable"))
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_volume":
		panic(fmt.Errorf("field recent_deposit_volume of message noble.dollar.vaults.v2.DepositVelocity is not mutable"))
	case "noble.dollar.vaults.v2.DepositVelocity.time_window_blocks":
		panic(fmt.Errorf("field time_window_blocks of message noble.dollar.vaults.v2.DepositVelocity is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositVelocity"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositVelocity does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_DepositVelocity) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.DepositVelocity.last_deposit_block":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_count":
		return protoreflect.ValueOfUint32(uint32(0))
	case "noble.dollar.vaults.v2.DepositVelocity.recent_deposit_volume":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.DepositVelocity.time_window_blocks":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.DepositVelocity"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.DepositVelocity does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_DepositVelocity) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.DepositVelocity", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_DepositVelocity) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositVelocity) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_DepositVelocity) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_DepositVelocity) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*DepositVelocity)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.LastDepositBlock != 0 {
			n += 1 + runtime.Sov(uint64(x.LastDepositBlock))
		}
		if x.RecentDepositCount != 0 {
			n += 1 + runtime.Sov(uint64(x.RecentDepositCount))
		}
		l = len(x.RecentDepositVolume)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.TimeWindowBlocks != 0 {
			n += 1 + runtime.Sov(uint64(x.TimeWindowBlocks))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*DepositVelocity)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.TimeWindowBlocks != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.TimeWindowBlocks))
			i--
			dAtA[i] = 0x20
		}
		if len(x.RecentDepositVolume) > 0 {
			i -= len(x.RecentDepositVolume)
			copy(dAtA[i:], x.RecentDepositVolume)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RecentDepositVolume)))
			i--
			dAtA[i] = 0x1a
		}
		if x.RecentDepositCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.RecentDepositCount))
			i--
			dAtA[i] = 0x10
		}
		if x.LastDepositBlock != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.LastDepositBlock))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*DepositVelocity)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DepositVelocity: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DepositVelocity: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastDepositBlock", wireType)
				}
				x.LastDepositBlock = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.LastDepositBlock |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RecentDepositCount", wireType)
				}
				x.RecentDepositCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.RecentDepositCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RecentDepositVolume", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RecentDepositVolume = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TimeWindowBlocks", wireType)
				}
				x.TimeWindowBlocks = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.TimeWindowBlocks |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_TWAPConfig                       protoreflect.MessageDescriptor
	fd_TWAPConfig_enabled               protoreflect.FieldDescriptor
	fd_TWAPConfig_window_size           protoreflect.FieldDescriptor
	fd_TWAPConfig_min_snapshot_interval protoreflect.FieldDescriptor
	fd_TWAPConfig_max_snapshot_age      protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_TWAPConfig = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("TWAPConfig")
	fd_TWAPConfig_enabled = md_TWAPConfig.Fields().ByName("enabled")
	fd_TWAPConfig_window_size = md_TWAPConfig.Fields().ByName("window_size")
	fd_TWAPConfig_min_snapshot_interval = md_TWAPConfig.Fields().ByName("min_snapshot_interval")
	fd_TWAPConfig_max_snapshot_age = md_TWAPConfig.Fields().ByName("max_snapshot_age")
}

var _ protoreflect.Message = (*fastReflection_TWAPConfig)(nil)

type fastReflection_TWAPConfig TWAPConfig

func (x *TWAPConfig) ProtoReflect() protoreflect.Message {
	return (*fastReflection_TWAPConfig)(x)
}

func (x *TWAPConfig) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_TWAPConfig_messageType fastReflection_TWAPConfig_messageType
var _ protoreflect.MessageType = fastReflection_TWAPConfig_messageType{}

type fastReflection_TWAPConfig_messageType struct{}

func (x fastReflection_TWAPConfig_messageType) Zero() protoreflect.Message {
	return (*fastReflection_TWAPConfig)(nil)
}
func (x fastReflection_TWAPConfig_messageType) New() protoreflect.Message {
	return new(fastReflection_TWAPConfig)
}
func (x fastReflection_TWAPConfig_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_TWAPConfig
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_TWAPConfig) Descriptor() protoreflect.MessageDescriptor {
	return md_TWAPConfig
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_TWAPConfig) Type() protoreflect.MessageType {
	return _fastReflection_TWAPConfig_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_TWAPConfig) New() protoreflect.Message {
	return new(fastReflection_TWAPConfig)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_TWAPConfig) Interface() protoreflect.ProtoMessage {
	return (*TWAPConfig)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_TWAPConfig) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Enabled != false {
		value := protoreflect.ValueOfBool(x.Enabled)
		if !f(fd_TWAPConfig_enabled, value) {
			return
		}
	}
	if x.WindowSize != uint32(0) {
		value := protoreflect.ValueOfUint32(x.WindowSize)
		if !f(fd_TWAPConfig_window_size, value) {
			return
		}
	}
	if x.MinSnapshotInterval != int64(0) {
		value := protoreflect.ValueOfInt64(x.MinSnapshotInterval)
		if !f(fd_TWAPConfig_min_snapshot_interval, value) {
			return
		}
	}
	if x.MaxSnapshotAge != int64(0) {
		value := protoreflect.ValueOfInt64(x.MaxSnapshotAge)
		if !f(fd_TWAPConfig_max_snapshot_age, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_TWAPConfig) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.TWAPConfig.enabled":
		return x.Enabled != false
	case "noble.dollar.vaults.v2.TWAPConfig.window_size":
		return x.WindowSize != uint32(0)
	case "noble.dollar.vaults.v2.TWAPConfig.min_snapshot_interval":
		return x.MinSnapshotInterval != int64(0)
	case "noble.dollar.vaults.v2.TWAPConfig.max_snapshot_age":
		return x.MaxSnapshotAge != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.TWAPConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.TWAPConfig does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TWAPConfig) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.TWAPConfig.enabled":
		x.Enabled = false
	case "noble.dollar.vaults.v2.TWAPConfig.window_size":
		x.WindowSize = uint32(0)
	case "noble.dollar.vaults.v2.TWAPConfig.min_snapshot_interval":
		x.MinSnapshotInterval = int64(0)
	case "noble.dollar.vaults.v2.TWAPConfig.max_snapshot_age":
		x.MaxSnapshotAge = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.TWAPConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.TWAPConfig does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_TWAPConfig) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.TWAPConfig.enabled":
		value := x.Enabled
		return protoreflect.ValueOfBool(value)
	case "noble.dollar.vaults.v2.TWAPConfig.window_size":
		value := x.WindowSize
		return protoreflect.ValueOfUint32(value)
	case "noble.dollar.vaults.v2.TWAPConfig.min_snapshot_interval":
		value := x.MinSnapshotInterval
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.TWAPConfig.max_snapshot_age":
		value := x.MaxSnapshotAge
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.TWAPConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.TWAPConfig does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TWAPConfig) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.TWAPConfig.enabled":
		x.Enabled = value.Bool()
	case "noble.dollar.vaults.v2.TWAPConfig.window_size":
		x.WindowSize = uint32(value.Uint())
	case "noble.dollar.vaults.v2.TWAPConfig.min_snapshot_interval":
		x.MinSnapshotInterval = value.Int()
	case "noble.dollar.vaults.v2.TWAPConfig.max_snapshot_age":
		x.MaxSnapshotAge = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.TWAPConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.TWAPConfig does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TWAPConfig) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.TWAPConfig.enabled":
		panic(fmt.Errorf("field enabled of message noble.dollar.vaults.v2.TWAPConfig is not mutable"))
	case "noble.dollar.vaults.v2.TWAPConfig.window_size":
		panic(fmt.Errorf("field window_size of message noble.dollar.vaults.v2.TWAPConfig is not mutable"))
	case "noble.dollar.vaults.v2.TWAPConfig.min_snapshot_interval":
		panic(fmt.Errorf("field min_snapshot_interval of message noble.dollar.vaults.v2.TWAPConfig is not mutable"))
	case "noble.dollar.vaults.v2.TWAPConfig.max_snapshot_age":
		panic(fmt.Errorf("field max_snapshot_age of message noble.dollar.vaults.v2.TWAPConfig is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.TWAPConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.TWAPConfig does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_TWAPConfig) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.TWAPConfig.enabled":
		return protoreflect.ValueOfBool(false)
	case "noble.dollar.vaults.v2.TWAPConfig.window_size":
		return protoreflect.ValueOfUint32(uint32(0))
	case "noble.dollar.vaults.v2.TWAPConfig.min_snapshot_interval":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.TWAPConfig.max_snapshot_age":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.TWAPConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.TWAPConfig does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_TWAPConfig) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.TWAPConfig", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_TWAPConfig) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TWAPConfig) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_TWAPConfig) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_TWAPConfig) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*TWAPConfig)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Enabled {
			n += 2
		}
		if x.WindowSize != 0 {
			n += 1 + runtime.Sov(uint64(x.WindowSize))
		}
		if x.MinSnapshotInterval != 0 {
			n += 1 + runtime.Sov(uint64(x.MinSnapshotInterval))
		}
		if x.MaxSnapshotAge != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxSnapshotAge))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*TWAPConfig)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.MaxSnapshotAge != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxSnapshotAge))
			i--
			dAtA[i] = 0x20
		}
		if x.MinSnapshotInterval != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MinSnapshotInterval))
			i--
			dAtA[i] = 0x18
		}
		if x.WindowSize != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.WindowSize))
			i--
			dAtA[i] = 0x10
		}
		if x.Enabled {
			i--
			if x.Enabled {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*TWAPConfig)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: TWAPConfig: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: TWAPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Enabled = bool(v != 0)
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WindowSize", wireType)
				}
				x.WindowSize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.WindowSize |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MinSnapshotInterval", wireType)
				}
				x.MinSnapshotInterval = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MinSnapshotInterval |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxSnapshotAge", wireType)
				}
				x.MaxSnapshotAge = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxSnapshotAge |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_NAVSnapshot              protoreflect.MessageDescriptor
	fd_NAVSnapshot_nav          protoreflect.FieldDescriptor
	fd_NAVSnapshot_timestamp    protoreflect.FieldDescriptor
	fd_NAVSnapshot_block_height protoreflect.FieldDescriptor
	fd_NAVSnapshot_total_shares protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_NAVSnapshot = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("NAVSnapshot")
	fd_NAVSnapshot_nav = md_NAVSnapshot.Fields().ByName("nav")
	fd_NAVSnapshot_timestamp = md_NAVSnapshot.Fields().ByName("timestamp")
	fd_NAVSnapshot_block_height = md_NAVSnapshot.Fields().ByName("block_height")
	fd_NAVSnapshot_total_shares = md_NAVSnapshot.Fields().ByName("total_shares")
}

var _ protoreflect.Message = (*fastReflection_NAVSnapshot)(nil)

type fastReflection_NAVSnapshot NAVSnapshot

func (x *NAVSnapshot) ProtoReflect() protoreflect.Message {
	return (*fastReflection_NAVSnapshot)(x)
}

func (x *NAVSnapshot) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_NAVSnapshot_messageType fastReflection_NAVSnapshot_messageType
var _ protoreflect.MessageType = fastReflection_NAVSnapshot_messageType{}

type fastReflection_NAVSnapshot_messageType struct{}

func (x fastReflection_NAVSnapshot_messageType) Zero() protoreflect.Message {
	return (*fastReflection_NAVSnapshot)(nil)
}
func (x fastReflection_NAVSnapshot_messageType) New() protoreflect.Message {
	return new(fastReflection_NAVSnapshot)
}
func (x fastReflection_NAVSnapshot_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_NAVSnapshot
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_NAVSnapshot) Descriptor() protoreflect.MessageDescriptor {
	return md_NAVSnapshot
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_NAVSnapshot) Type() protoreflect.MessageType {
	return _fastReflection_NAVSnapshot_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_NAVSnapshot) New() protoreflect.Message {
	return new(fastReflection_NAVSnapshot)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_NAVSnapshot) Interface() protoreflect.ProtoMessage {
	return (*NAVSnapshot)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_NAVSnapshot) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nav != "" {
		value := protoreflect.ValueOfString(x.Nav)
		if !f(fd_NAVSnapshot_nav, value) {
			return
		}
	}
	if x.Timestamp != nil {
		value := protoreflect.ValueOfMessage(x.Timestamp.ProtoReflect())
		if !f(fd_NAVSnapshot_timestamp, value) {
			return
		}
	}
	if x.BlockHeight != int64(0) {
		value := protoreflect.ValueOfInt64(x.BlockHeight)
		if !f(fd_NAVSnapshot_block_height, value) {
			return
		}
	}
	if x.TotalShares != "" {
		value := protoreflect.ValueOfString(x.TotalShares)
		if !f(fd_NAVSnapshot_total_shares, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_NAVSnapshot) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NAVSnapshot.nav":
		return x.Nav != ""
	case "noble.dollar.vaults.v2.NAVSnapshot.timestamp":
		return x.Timestamp != nil
	case "noble.dollar.vaults.v2.NAVSnapshot.block_height":
		return x.BlockHeight != int64(0)
	case "noble.dollar.vaults.v2.NAVSnapshot.total_shares":
		return x.TotalShares != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVSnapshot does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NAVSnapshot) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NAVSnapshot.nav":
		x.Nav = ""
	case "noble.dollar.vaults.v2.NAVSnapshot.timestamp":
		x.Timestamp = nil
	case "noble.dollar.vaults.v2.NAVSnapshot.block_height":
		x.BlockHeight = int64(0)
	case "noble.dollar.vaults.v2.NAVSnapshot.total_shares":
		x.TotalShares = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVSnapshot does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_NAVSnapshot) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.NAVSnapshot.nav":
		value := x.Nav
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.NAVSnapshot.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.NAVSnapshot.block_height":
		value := x.BlockHeight
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.NAVSnapshot.total_shares":
		value := x.TotalShares
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVSnapshot does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NAVSnapshot) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NAVSnapshot.nav":
		x.Nav = value.Interface().(string)
	case "noble.dollar.vaults.v2.NAVSnapshot.timestamp":
		x.Timestamp = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.NAVSnapshot.block_height":
		x.BlockHeight = value.Int()
	case "noble.dollar.vaults.v2.NAVSnapshot.total_shares":
		x.TotalShares = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVSnapshot does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NAVSnapshot) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NAVSnapshot.timestamp":
		if x.Timestamp == nil {
			x.Timestamp = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.Timestamp.ProtoReflect())
	case "noble.dollar.vaults.v2.NAVSnapshot.nav":
		panic(fmt.Errorf("field nav of message noble.dollar.vaults.v2.NAVSnapshot is not mutable"))
	case "noble.dollar.vaults.v2.NAVSnapshot.block_height":
		panic(fmt.Errorf("field block_height of message noble.dollar.vaults.v2.NAVSnapshot is not mutable"))
	case "noble.dollar.vaults.v2.NAVSnapshot.total_shares":
		panic(fmt.Errorf("field total_shares of message noble.dollar.vaults.v2.NAVSnapshot is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVSnapshot does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_NAVSnapshot) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NAVSnapshot.nav":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.NAVSnapshot.timestamp":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.NAVSnapshot.block_height":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.NAVSnapshot.total_shares":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVSnapshot does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_NAVSnapshot) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.NAVSnapshot", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_NAVSnapshot) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NAVSnapshot) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_NAVSnapshot) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_NAVSnapshot) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*NAVSnapshot)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nav)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Timestamp != nil {
			l = options.Size(x.Timestamp)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BlockHeight != 0 {
			n += 1 + runtime.Sov(uint64(x.BlockHeight))
		}
		l = len(x.TotalShares)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*NAVSnapshot)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TotalShares) > 0 {
			i -= len(x.TotalShares)
			copy(dAtA[i:], x.TotalShares)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalShares)))
			i--
			dAtA[i] = 0x22
		}
		if x.BlockHeight != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BlockHeight))
			i--
			dAtA[i] = 0x18
		}
		if x.Timestamp != nil {
			encoded, err := options.Marshal(x.Timestamp)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nav) > 0 {
			i -= len(x.Nav)
			copy(dAtA[i:], x.Nav)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nav)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*NAVSnapshot)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: NAVSnapshot: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: NAVSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nav", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nav = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Timestamp == nil {
					x.Timestamp = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Timestamp); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
				}
				x.BlockHeight = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BlockHeight |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalShares", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalShares = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_AccountingCursor                          protoreflect.MessageDescriptor
	fd_AccountingCursor_last_processed_user      protoreflect.FieldDescriptor
	fd_AccountingCursor_accounting_nav           protoreflect.FieldDescriptor
	fd_AccountingCursor_accounting_nav_timestamp protoreflect.FieldDescriptor
	fd_AccountingCursor_positions_processed      protoreflect.FieldDescriptor
	fd_AccountingCursor_total_positions          protoreflect.FieldDescriptor
	fd_AccountingCursor_in_progress              protoreflect.FieldDescriptor
	fd_AccountingCursor_started_at               protoreflect.FieldDescriptor
	fd_AccountingCursor_accumulated_residual     protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_vaults_proto_init()
	md_AccountingCursor = File_noble_dollar_vaults_v2_vaults_proto.Messages().ByName("AccountingCursor")
	fd_AccountingCursor_last_processed_user = md_AccountingCursor.Fields().ByName("last_processed_user")
	fd_AccountingCursor_accounting_nav = md_AccountingCursor.Fields().ByName("accounting_nav")
	fd_AccountingCursor_accounting_nav_timestamp = md_AccountingCursor.Fields().ByName("accounting_nav_timestamp")
	fd_AccountingCursor_positions_processed = md_AccountingCursor.Fields().ByName("positions_processed")
	fd_AccountingCursor_total_positions = md_AccountingCursor.Fields().ByName("total_positions")
	fd_AccountingCursor_in_progress = md_AccountingCursor.Fields().ByName("in_progress")
	fd_AccountingCursor_started_at = md_AccountingCursor.Fields().ByName("started_at")
	fd_AccountingCursor_accumulated_residual = md_AccountingCursor.Fields().ByName("accumulated_residual")
}

var _ protoreflect.Message = (*fastReflection_AccountingCursor)(nil)

type fastReflection_AccountingCursor AccountingCursor

func (x *AccountingCursor) ProtoReflect() protoreflect.Message {
	return (*fastReflection_AccountingCursor)(x)
}

func (x *AccountingCursor) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_AccountingCursor_messageType fastReflection_AccountingCursor_messageType
var _ protoreflect.MessageType = fastReflection_AccountingCursor_messageType{}

type fastReflection_AccountingCursor_messageType struct{}

func (x fastReflection_AccountingCursor_messageType) Zero() protoreflect.Message {
	return (*fastReflection_AccountingCursor)(nil)
}
func (x fastReflection_AccountingCursor_messageType) New() protoreflect.Message {
	return new(fastReflection_AccountingCursor)
}
func (x fastReflection_AccountingCursor_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_AccountingCursor
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_AccountingCursor) Descriptor() protoreflect.MessageDescriptor {
	return md_AccountingCursor
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_AccountingCursor) Type() protoreflect.MessageType {
	return _fastReflection_AccountingCursor_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_AccountingCursor) New() protoreflect.Message {
	return new(fastReflection_AccountingCursor)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_AccountingCursor) Interface() protoreflect.ProtoMessage {
	return (*AccountingCursor)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_AccountingCursor) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.LastProcessedUser != "" {
		value := protoreflect.ValueOfString(x.LastProcessedUser)
		if !f(fd_AccountingCursor_last_processed_user, value) {
			return
		}
	}
	if x.AccountingNav != "" {
		value := protoreflect.ValueOfString(x.AccountingNav)
		if !f(fd_AccountingCursor_accounting_nav, value) {
			return
		}
	}
	if x.AccountingNavTimestamp != nil {
		value := protoreflect.ValueOfMessage(x.AccountingNavTimestamp.ProtoReflect())
		if !f(fd_AccountingCursor_accounting_nav_timestamp, value) {
			return
		}
	}
	if x.PositionsProcessed != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PositionsProcessed)
		if !f(fd_AccountingCursor_positions_processed, value) {
			return
		}
	}
	if x.TotalPositions != uint64(0) {
		value := protoreflect.ValueOfUint64(x.TotalPositions)
		if !f(fd_AccountingCursor_total_positions, value) {
			return
		}
	}
	if x.InProgress != false {
		value := protoreflect.ValueOfBool(x.InProgress)
		if !f(fd_AccountingCursor_in_progress, value) {
			return
		}
	}
	if x.StartedAt != nil {
		value := protoreflect.ValueOfMessage(x.StartedAt.ProtoReflect())
		if !f(fd_AccountingCursor_started_at, value) {
			return
		}
	}
	if x.AccumulatedResidual != "" {
		value := protoreflect.ValueOfString(x.AccumulatedResidual)
		if !f(fd_AccountingCursor_accumulated_residual, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_AccountingCursor) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.AccountingCursor.last_processed_user":
		return x.LastProcessedUser != ""
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav":
		return x.AccountingNav != ""
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav_timestamp":
		return x.AccountingNavTimestamp != nil
	case "noble.dollar.vaults.v2.AccountingCursor.positions_processed":
		return x.PositionsProcessed != uint64(0)
	case "noble.dollar.vaults.v2.AccountingCursor.total_positions":
		return x.TotalPositions != uint64(0)
	case "noble.dollar.vaults.v2.AccountingCursor.in_progress":
		return x.InProgress != false
	case "noble.dollar.vaults.v2.AccountingCursor.started_at":
		return x.StartedAt != nil
	case "noble.dollar.vaults.v2.AccountingCursor.accumulated_residual":
		return x.AccumulatedResidual != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingCursor"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingCursor does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AccountingCursor) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.AccountingCursor.last_processed_user":
		x.LastProcessedUser = ""
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav":
		x.AccountingNav = ""
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav_timestamp":
		x.AccountingNavTimestamp = nil
	case "noble.dollar.vaults.v2.AccountingCursor.positions_processed":
		x.PositionsProcessed = uint64(0)
	case "noble.dollar.vaults.v2.AccountingCursor.total_positions":
		x.TotalPositions = uint64(0)
	case "noble.dollar.vaults.v2.AccountingCursor.in_progress":
		x.InProgress = false
	case "noble.dollar.vaults.v2.AccountingCursor.started_at":
		x.StartedAt = nil
	case "noble.dollar.vaults.v2.AccountingCursor.accumulated_residual":
		x.AccumulatedResidual = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingCursor"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingCursor does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_AccountingCursor) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.AccountingCursor.last_processed_user":
		value := x.LastProcessedUser
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav":
		value := x.AccountingNav
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav_timestamp":
		value := x.AccountingNavTimestamp
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.AccountingCursor.positions_processed":
		value := x.PositionsProcessed
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v2.AccountingCursor.total_positions":
		value := x.TotalPositions
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v2.AccountingCursor.in_progress":
		value := x.InProgress
		return protoreflect.ValueOfBool(value)
	case "noble.dollar.vaults.v2.AccountingCursor.started_at":
		value := x.StartedAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.AccountingCursor.accumulated_residual":
		value := x.AccumulatedResidual
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingCursor"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingCursor does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AccountingCursor) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.AccountingCursor.last_processed_user":
		x.LastProcessedUser = value.Interface().(string)
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav":
		x.AccountingNav = value.Interface().(string)
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav_timestamp":
		x.AccountingNavTimestamp = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.AccountingCursor.positions_processed":
		x.PositionsProcessed = value.Uint()
	case "noble.dollar.vaults.v2.AccountingCursor.total_positions":
		x.TotalPositions = value.Uint()
	case "noble.dollar.vaults.v2.AccountingCursor.in_progress":
		x.InProgress = value.Bool()
	case "noble.dollar.vaults.v2.AccountingCursor.started_at":
		x.StartedAt = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.AccountingCursor.accumulated_residual":
		x.AccumulatedResidual = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingCursor"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingCursor does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AccountingCursor) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav_timestamp":
		if x.AccountingNavTimestamp == nil {
			x.AccountingNavTimestamp = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.AccountingNavTimestamp.ProtoReflect())
	case "noble.dollar.vaults.v2.AccountingCursor.started_at":
		if x.StartedAt == nil {
			x.StartedAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.StartedAt.ProtoReflect())
	case "noble.dollar.vaults.v2.AccountingCursor.last_processed_user":
		panic(fmt.Errorf("field last_processed_user of message noble.dollar.vaults.v2.AccountingCursor is not mutable"))
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav":
		panic(fmt.Errorf("field accounting_nav of message noble.dollar.vaults.v2.AccountingCursor is not mutable"))
	case "noble.dollar.vaults.v2.AccountingCursor.positions_processed":
		panic(fmt.Errorf("field positions_processed of message noble.dollar.vaults.v2.AccountingCursor is not mutable"))
	case "noble.dollar.vaults.v2.AccountingCursor.total_positions":
		panic(fmt.Errorf("field total_positions of message noble.dollar.vaults.v2.AccountingCursor is not mutable"))
	case "noble.dollar.vaults.v2.AccountingCursor.in_progress":
		panic(fmt.Errorf("field in_progress of message noble.dollar.vaults.v2.AccountingCursor is not mutable"))
	case "noble.dollar.vaults.v2.AccountingCursor.accumulated_residual":
		panic(fmt.Errorf("field accumulated_residual of message noble.dollar.vaults.v2.AccountingCursor is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingCursor"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingCursor does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_AccountingCursor) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.AccountingCursor.last_processed_user":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.AccountingCursor.accounting_nav_timestamp":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.AccountingCursor.positions_processed":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v2.AccountingCursor.total_positions":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v2.AccountingCursor.in_progress":
		return protoreflect.ValueOfBool(false)
	case "noble.dollar.vaults.v2.AccountingCursor.started_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.AccountingCursor.accumulated_residual":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.AccountingCursor"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.AccountingCursor does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_AccountingCursor) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.AccountingCursor", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_AccountingCursor) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AccountingCursor) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_AccountingCursor) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_AccountingCursor) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*AccountingCursor)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.LastProcessedUser)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AccountingNav)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.AccountingNavTimestamp != nil {
			l = options.Size(x.AccountingNavTimestamp)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PositionsProcessed != 0 {
			n += 1 + runtime.Sov(uint64(x.PositionsProcessed))
		}
		if x.TotalPositions != 0 {
			n += 1 + runtime.Sov(uint64(x.TotalPositions))
		}
		if x.InProgress {
			n += 2
		}
		if x.StartedAt != nil {
			l = options.Size(x.StartedAt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AccumulatedResidual)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*AccountingCursor)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AccumulatedResidual) > 0 {
			i -= len(x.AccumulatedResidual)
			copy(dAtA[i:], x.AccumulatedResidual)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AccumulatedResidual)))
			i--
			dAtA[i] = 0x42
		}
		if x.StartedAt != nil {
			encoded, err := options.Marshal(x.StartedAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		if x.InProgress {
			i--
			if x.InProgress {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if x.TotalPositions != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.TotalPositions))
			i--
			dAtA[i] = 0x28
		}
		if x.PositionsProcessed != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PositionsProcessed))
			i--
			dAtA[i] = 0x20
		}
		if x.AccountingNavTimestamp != nil {
			encoded, err := options.Marshal(x.AccountingNavTimestamp)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.AccountingNav) > 0 {
			i -= len(x.AccountingNav)
			copy(dAtA[i:], x.AccountingNav)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AccountingNav)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.LastProcessedUser) > 0 {
			i -= len(x.LastProcessedUser)
			copy(dAtA[i:], x.LastProcessedUser)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LastProcessedUser)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*AccountingCursor)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AccountingCursor: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AccountingCursor: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastProcessedUser", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LastProcessedUser = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AccountingNav", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AccountingNav = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AccountingNavTimestamp", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.AccountingNavTimestamp == nil {
					x.AccountingNavTimestamp = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.AccountingNavTimestamp); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PositionsProcessed", wireType)
				}
				x.PositionsProcessed = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PositionsProcessed |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalPositions", wireType)
				}
				x.TotalPositions = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.TotalPositions |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InProgress", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.InProgress = bool(v != 0)
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.StartedAt == nil {
					x.StartedAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.StartedAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AccumulatedResidual", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AccumulatedResidual = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: noble/dollar/vaults/v2/vaults.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// WithdrawalRequestStatus represents the status of a withdrawal request
type WithdrawalRequestStatus int32

const (
	// Request is pending (waiting for unlock time)
	WithdrawalRequestStatus_WITHDRAWAL_REQUEST_STATUS_PENDING WithdrawalRequestStatus = 0
	// Request is ready to be processed
	WithdrawalRequestStatus_WITHDRAWAL_REQUEST_STATUS_READY WithdrawalRequestStatus = 1
	// Request has been processed
	WithdrawalRequestStatus_WITHDRAWAL_REQUEST_STATUS_PROCESSED WithdrawalRequestStatus = 2
	// Request was cancelled by user
	WithdrawalRequestStatus_WITHDRAWAL_REQUEST_STATUS_CANCELLED WithdrawalRequestStatus = 3
	// Request expired without processing
	WithdrawalRequestStatus_WITHDRAWAL_REQUEST_STATUS_EXPIRED WithdrawalRequestStatus = 4
)

// Enum value maps for WithdrawalRequestStatus.
var (
	WithdrawalRequestStatus_name = map[int32]string{
		0: "WITHDRAWAL_REQUEST_STATUS_PENDING",
		1: "WITHDRAWAL_REQUEST_STATUS_READY",
		2: "WITHDRAWAL_REQUEST_STATUS_PROCESSED",
		3: "WITHDRAWAL_REQUEST_STATUS_CANCELLED",
		4: "WITHDRAWAL_REQUEST_STATUS_EXPIRED",
	}
	WithdrawalRequestStatus_value = map[string]int32{
		"WITHDRAWAL_REQUEST_STATUS_PENDING":   0,
		"WITHDRAWAL_REQUEST_STATUS_READY":     1,
		"WITHDRAWAL_REQUEST_STATUS_PROCESSED": 2,
		"WITHDRAWAL_REQUEST_STATUS_CANCELLED": 3,
		"WITHDRAWAL_REQUEST_STATUS_EXPIRED":   4,
	}
)

func (x WithdrawalRequestStatus) Enum() *WithdrawalRequestStatus {
	p := new(WithdrawalRequestStatus)
	*p = x
	return p
}

func (x WithdrawalRequestStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WithdrawalRequestStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_noble_dollar_vaults_v2_vaults_proto_enumTypes[0].Descriptor()
}

func (WithdrawalRequestStatus) Type() protoreflect.EnumType {
	return &file_noble_dollar_vaults_v2_vaults_proto_enumTypes[0]
}

func (x WithdrawalRequestStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WithdrawalRequestStatus.Descriptor instead.
func (WithdrawalRequestStatus) EnumDescriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{0}
}

// UserPosition represents a user's position in the V2 yield-tracking vault system
// Users can have multiple independent positions, each identified by position_id
type UserPosition struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Unique position ID for this user (auto-incremented per user)
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Current deposit amount (principal)
	DepositAmount string `protobuf:"bytes,2,opt,name=deposit_amount,json=depositAmount,proto3" json:"deposit_amount,omitempty"`
	// Accrued yield on the position
	AccruedYield string `protobuf:"bytes,3,opt,name=accrued_yield,json=accruedYield,proto3" json:"accrued_yield,omitempty"`
	// Timestamp of first deposit
	FirstDepositTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=first_deposit_time,json=firstDepositTime,proto3" json:"first_deposit_time,omitempty"`
	// Timestamp of last deposit/withdrawal
	LastActivityTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=last_activity_time,json=lastActivityTime,proto3" json:"last_activity_time,omitempty"`
	// Whether user wants to receive yield (vs contributing to fee pool)
	ReceiveYield bool `protobuf:"varint,6,opt,name=receive_yield,json=receiveYield,proto3" json:"receive_yield,omitempty"`
	// Amount pending withdrawal
	AmountPendingWithdrawal string `protobuf:"bytes,7,opt,name=amount_pending_withdrawal,json=amountPendingWithdrawal,proto3" json:"amount_pending_withdrawal,omitempty"`
	// Number of active withdrawal requests
	ActiveWithdrawalRequests int32 `protobuf:"varint,8,opt,name=active_withdrawal_requests,json=activeWithdrawalRequests,proto3" json:"active_withdrawal_requests,omitempty"`
}

func (x *UserPosition) Reset() {
	*x = UserPosition{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserPosition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserPosition) ProtoMessage() {}

// Deprecated: Use UserPosition.ProtoReflect.Descriptor instead.
func (*UserPosition) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{0}
}

func (x *UserPosition) GetPositionId() uint64 {
	if x != nil {
		return x.PositionId
	}
	return 0
}

func (x *UserPosition) GetDepositAmount() string {
	if x != nil {
		return x.DepositAmount
	}
	return ""
}

func (x *UserPosition) GetAccruedYield() string {
	if x != nil {
		return x.AccruedYield
	}
	return ""
}

func (x *UserPosition) GetFirstDepositTime() *timestamppb.Timestamp {
	if x != nil {
		return x.FirstDepositTime
	}
	return nil
}

func (x *UserPosition) GetLastActivityTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastActivityTime
	}
	return nil
}

func (x *UserPosition) GetReceiveYield() bool {
	if x != nil {
		return x.ReceiveYield
	}
	return false
}

func (x *UserPosition) GetAmountPendingWithdrawal() string {
	if x != nil {
		return x.AmountPendingWithdrawal
	}
	return ""
}

func (x *UserPosition) GetActiveWithdrawalRequests() int32 {
	if x != nil {
		return x.ActiveWithdrawalRequests
	}
	return 0
}

// AccountingSnapshot represents a pending update to a user position during accounting.
// These snapshots are used to stage all accounting changes before atomically committing
// them when the accounting session completes. This ensures consistency even if accounting
// is performed across multiple message invocations.
type AccountingSnapshot struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// User address
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// Position ID for this user
	PositionId uint64 `protobuf:"varint,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// New deposit amount after accounting
	DepositAmount string `protobuf:"bytes,3,opt,name=deposit_amount,json=depositAmount,proto3" json:"deposit_amount,omitempty"`
	// New accrued yield after accounting
	AccruedYield string `protobuf:"bytes,4,opt,name=accrued_yield,json=accruedYield,proto3" json:"accrued_yield,omitempty"`
	// NAV value used for this snapshot
	AccountingNav string `protobuf:"bytes,5,opt,name=accounting_nav,json=accountingNav,proto3" json:"accounting_nav,omitempty"`
	// Timestamp when this snapshot was created
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (x *AccountingSnapshot) Reset() {
	*x = AccountingSnapshot{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccountingSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccountingSnapshot) ProtoMessage() {}

// Deprecated: Use AccountingSnapshot.ProtoReflect.Descriptor instead.
func (*AccountingSnapshot) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{1}
}

func (x *AccountingSnapshot) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *AccountingSnapshot) GetPositionId() uint64 {
	if x != nil {
		return x.PositionId
	}
	return 0
}

func (x *AccountingSnapshot) GetDepositAmount() string {
	if x != nil {
		return x.DepositAmount
	}
	return ""
}

func (x *AccountingSnapshot) GetAccruedYield() string {
	if x != nil {
		return x.AccruedYield
	}
	return ""
}

func (x *AccountingSnapshot) GetAccountingNav() string {
	if x != nil {
		return x.AccountingNav
	}
	return ""
}

func (x *AccountingSnapshot) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

// WithdrawalRequest represents a pending withdrawal request
type WithdrawalRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Unique request ID
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Address of the account that created the request
	Requester string `protobuf:"bytes,2,opt,name=requester,proto3" json:"requester,omitempty"`
	// Position ID being withdrawn from
	PositionId uint64 `protobuf:"varint,3,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Amount to withdraw (including yield)
	WithdrawAmount string `protobuf:"bytes,4,opt,name=withdraw_amount,json=withdrawAmount,proto3" json:"withdraw_amount,omitempty"`
	// When the withdrawal was requested
	RequestTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=request_time,json=requestTime,proto3" json:"request_time,omitempty"`
	// When the withdrawal can be processed
	UnlockTime *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=unlock_time,json=unlockTime,proto3" json:"unlock_time,omitempty"`
	// Current status of the withdrawal request
	Status WithdrawalRequestStatus `protobuf:"varint,7,opt,name=status,proto3,enum=noble.dollar.vaults.v2.WithdrawalRequestStatus" json:"status,omitempty"`
	// Estimated amount to receive (calculated at request time)
	EstimatedAmount string `protobuf:"bytes,8,opt,name=estimated_amount,json=estimatedAmount,proto3" json:"estimated_amount,omitempty"`
	// Block height when request was made
	RequestBlockHeight int64 `protobuf:"varint,9,opt,name=request_block_height,json=requestBlockHeight,proto3" json:"request_block_height,omitempty"`
}

func (x *WithdrawalRequest) Reset() {
	*x = WithdrawalRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WithdrawalRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WithdrawalRequest) ProtoMessage() {}

// Deprecated: Use WithdrawalRequest.ProtoReflect.Descriptor instead.
func (*WithdrawalRequest) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{2}
}

func (x *WithdrawalRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *WithdrawalRequest) GetRequester() string {
	if x != nil {
		return x.Requester
	}
	return ""
}

func (x *WithdrawalRequest) GetPositionId() uint64 {
	if x != nil {
		return x.PositionId
	}
	return 0
}

func (x *WithdrawalRequest) GetWithdrawAmount() string {
	if x != nil {
		return x.WithdrawAmount
	}
	return ""
}

func (x *WithdrawalRequest) GetRequestTime() *timestamppb.Timestamp {
	if x != nil {
		return x.RequestTime
	}
	return nil
}

func (x *WithdrawalRequest) GetUnlockTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UnlockTime
	}
	return nil
}

func (x *WithdrawalRequest) GetStatus() WithdrawalRequestStatus {
	if x != nil {
		return x.Status
	}
	return WithdrawalRequestStatus_WITHDRAWAL_REQUEST_STATUS_PENDING
}

func (x *WithdrawalRequest) GetEstimatedAmount() string {
	if x != nil {
		return x.EstimatedAmount
	}
	return ""
}

func (x *WithdrawalRequest) GetRequestBlockHeight() int64 {
	if x != nil {
		return x.RequestBlockHeight
	}
	return 0
}

// VaultState represents the current state of a V2 vault
type VaultState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Total deposits in the vault
	TotalDeposits string `protobuf:"bytes,1,opt,name=total_deposits,json=totalDeposits,proto3" json:"total_deposits,omitempty"`
	// Total accrued yield
	TotalAccruedYield string `protobuf:"bytes,2,opt,name=total_accrued_yield,json=totalAccruedYield,proto3" json:"total_accrued_yield,omitempty"`
	// Total Net Asset Value (deposits + yield)
	TotalNav string `protobuf:"bytes,3,opt,name=total_nav,json=totalNav,proto3" json:"total_nav,omitempty"`
	// Total number of users with positions
	TotalUsers uint64 `protobuf:"varint,4,opt,name=total_users,json=totalUsers,proto3" json:"total_users,omitempty"`
	// Whether deposits are currently enabled
	DepositsEnabled bool `protobuf:"varint,5,opt,name=deposits_enabled,json=depositsEnabled,proto3" json:"deposits_enabled,omitempty"`
	// Whether withdrawals are currently enabled
	WithdrawalsEnabled bool `protobuf:"varint,6,opt,name=withdrawals_enabled,json=withdrawalsEnabled,proto3" json:"withdrawals_enabled,omitempty"`
	// Last NAV update timestamp
	LastNavUpdate *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_nav_update,json=lastNavUpdate,proto3" json:"last_nav_update,omitempty"`
	// Total amount pending withdrawal
	TotalAmountPendingWithdrawal string `protobuf:"bytes,8,opt,name=total_amount_pending_withdrawal,json=totalAmountPendingWithdrawal,proto3" json:"total_amount_pending_withdrawal,omitempty"`
	// Number of pending withdrawal requests
	PendingWithdrawalRequests int32 `protobuf:"varint,9,opt,name=pending_withdrawal_requests,json=pendingWithdrawalRequests,proto3" json:"pending_withdrawal_requests,omitempty"`
	// Total number of active positions across all users
	TotalPositions uint64 `protobuf:"varint,10,opt,name=total_positions,json=totalPositions,proto3" json:"total_positions,omitempty"`
}

func (x *VaultState) Reset() {
	*x = VaultState{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VaultState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VaultState) ProtoMessage() {}

// Deprecated: Use VaultState.ProtoReflect.Descriptor instead.
func (*VaultState) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{3}
}

func (x *VaultState) GetTotalDeposits() string {
	if x != nil {
		return x.TotalDeposits
	}
	return ""
}

func (x *VaultState) GetTotalAccruedYield() string {
	if x != nil {
		return x.TotalAccruedYield
	}
	return ""
}

func (x *VaultState) GetTotalNav() string {
	if x != nil {
		return x.TotalNav
	}
	return ""
}

func (x *VaultState) GetTotalUsers() uint64 {
	if x != nil {
		return x.TotalUsers
	}
	return 0
}

func (x *VaultState) GetDepositsEnabled() bool {
	if x != nil {
		return x.DepositsEnabled
	}
	return false
}

func (x *VaultState) GetWithdrawalsEnabled() bool {
	if x != nil {
		return x.WithdrawalsEnabled
	}
	return false
}

func (x *VaultState) GetLastNavUpdate() *timestamppb.Timestamp {
	if x != nil {
		return x.LastNavUpdate
	}
	return nil
}

func (x *VaultState) GetTotalAmountPendingWithdrawal() string {
	if x != nil {
		return x.TotalAmountPendingWithdrawal
	}
	return ""
}

func (x *VaultState) GetPendingWithdrawalRequests() int32 {
	if x != nil {
		return x.PendingWithdrawalRequests
	}
	return 0
}

func (x *VaultState) GetTotalPositions() uint64 {
	if x != nil {
		return x.TotalPositions
	}
	return 0
}

// YieldCalculation contains details about yield calculations
type YieldCalculation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Total deposits used in calculation
	TotalDeposits string `protobuf:"bytes,1,opt,name=total_deposits,json=totalDeposits,proto3" json:"total_deposits,omitempty"`
	// Total accrued yield
	TotalYield string `protobuf:"bytes,2,opt,name=total_yield,json=totalYield,proto3" json:"total_yield,omitempty"`
	// Yield rate (APY percentage)
	YieldRate string `protobuf:"bytes,3,opt,name=yield_rate,json=yieldRate,proto3" json:"yield_rate,omitempty"`
	// Calculation timestamp
	CalculationTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=calculation_time,json=calculationTime,proto3" json:"calculation_time,omitempty"`
}

func (x *YieldCalculation) Reset() {
	*x = YieldCalculation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *YieldCalculation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*YieldCalculation) ProtoMessage() {}

// Deprecated: Use YieldCalculation.ProtoReflect.Descriptor instead.
func (*YieldCalculation) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{4}
}

func (x *YieldCalculation) GetTotalDeposits() string {
	if x != nil {
		return x.TotalDeposits
	}
	return ""
}

func (x *YieldCalculation) GetTotalYield() string {
	if x != nil {
		return x.TotalYield
	}
	return ""
}

func (x *YieldCalculation) GetYieldRate() string {
	if x != nil {
		return x.YieldRate
	}
	return ""
}

func (x *YieldCalculation) GetCalculationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CalculationTime
	}
	return nil
}

// DepositResult contains the outcome of a deposit operation
type DepositResult struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Amount deposited
	AmountDeposited string `protobuf:"bytes,1,opt,name=amount_deposited,json=amountDeposited,proto3" json:"amount_deposited,omitempty"`
}

func (x *DepositResult) Reset() {
	*x = DepositResult{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DepositResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositResult) ProtoMessage() {}

// Deprecated: Use DepositResult.ProtoReflect.Descriptor instead.
func (*DepositResult) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{5}
}

func (x *DepositResult) GetAmountDeposited() string {
	if x != nil {
		return x.AmountDeposited
	}
	return ""
}

// WithdrawalResult contains the outcome of a withdrawal operation
type WithdrawalResult struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Principal withdrawn
	PrincipalWithdrawn string `protobuf:"bytes,1,opt,name=principal_withdrawn,json=principalWithdrawn,proto3" json:"principal_withdrawn,omitempty"`
	// Yield withdrawn
	YieldWithdrawn string `protobuf:"bytes,2,opt,name=yield_withdrawn,json=yieldWithdrawn,proto3" json:"yield_withdrawn,omitempty"`
	// Fees paid
	FeesPaid string `protobuf:"bytes,3,opt,name=fees_paid,json=feesPaid,proto3" json:"fees_paid,omitempty"`
	// Total amount received (principal + yield - fees)
	TotalAmountReceived string `protobuf:"bytes,4,opt,name=total_amount_received,json=totalAmountReceived,proto3" json:"total_amount_received,omitempty"`
}

func (x *WithdrawalResult) Reset() {
	*x = WithdrawalResult{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WithdrawalResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WithdrawalResult) ProtoMessage() {}

// Deprecated: Use WithdrawalResult.ProtoReflect.Descriptor instead.
func (*WithdrawalResult) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{6}
}

func (x *WithdrawalResult) GetPrincipalWithdrawn() string {
	if x != nil {
		return x.PrincipalWithdrawn
	}
	return ""
}

func (x *WithdrawalResult) GetYieldWithdrawn() string {
	if x != nil {
		return x.YieldWithdrawn
	}
	return ""
}

func (x *WithdrawalResult) GetFeesPaid() string {
	if x != nil {
		return x.FeesPaid
	}
	return ""
}

func (x *WithdrawalResult) GetTotalAmountReceived() string {
	if x != nil {
		return x.TotalAmountReceived
	}
	return ""
}

// YieldDistribution represents yield distribution to shareholders
type YieldDistribution struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Total yield amount distributed
	TotalYield string `protobuf:"bytes,1,opt,name=total_yield,json=totalYield,proto3" json:"total_yield,omitempty"`
	// Yield rate applied
	YieldRate string `protobuf:"bytes,2,opt,name=yield_rate,json=yieldRate,proto3" json:"yield_rate,omitempty"`
	// Distribution timestamp
	DistributionTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=distribution_time,json=distributionTime,proto3" json:"distribution_time,omitempty"`
	// Number of eligible depositors
	EligibleDepositors uint64 `protobuf:"varint,4,opt,name=eligible_depositors,json=eligibleDepositors,proto3" json:"eligible_depositors,omitempty"`
}

func (x *YieldDistribution) Reset() {
	*x = YieldDistribution{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *YieldDistribution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*YieldDistribution) ProtoMessage() {}

// Deprecated: Use YieldDistribution.ProtoReflect.Descriptor instead.
func (*YieldDistribution) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{7}
}

func (x *YieldDistribution) GetTotalYield() string {
	if x != nil {
		return x.TotalYield
	}
	return ""
}

func (x *YieldDistribution) GetYieldRate() string {
	if x != nil {
		return x.YieldRate
	}
	return ""
}

func (x *YieldDistribution) GetDistributionTime() *timestamppb.Timestamp {
	if x != nil {
		return x.DistributionTime
	}
	return nil
}

func (x *YieldDistribution) GetEligibleDepositors() uint64 {
	if x != nil {
		return x.EligibleDepositors
	}
	return 0
}

// DepositLimit defines deposit limits and risk controls
type DepositLimit struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Maximum deposit amount per user per time window
	MaxUserDepositPerWindow string `protobuf:"bytes,1,opt,name=max_user_deposit_per_window,json=maxUserDepositPerWindow,proto3" json:"max_user_deposit_per_window,omitempty"`
	// Maximum deposit volume per block
	MaxBlockDepositVolume string `protobuf:"bytes,2,opt,name=max_block_deposit_volume,json=maxBlockDepositVolume,proto3" json:"max_block_deposit_volume,omitempty"`
	// Global maximum total deposits (vault capacity)
	GlobalDepositCap string `protobuf:"bytes,3,opt,name=global_deposit_cap,json=globalDepositCap,proto3" json:"global_deposit_cap,omitempty"`
	// Cooldown period in blocks between deposits
	DepositCooldownBlocks int64 `protobuf:"varint,4,opt,name=deposit_cooldown_blocks,json=depositCooldownBlocks,proto3" json:"deposit_cooldown_blocks,omitempty"`
	// Time window for velocity tracking (in blocks)
	VelocityWindowBlocks int64 `protobuf:"varint,5,opt,name=velocity_window_blocks,json=velocityWindowBlocks,proto3" json:"velocity_window_blocks,omitempty"`
	// Maximum number of deposits per user in time window
	MaxDepositsPerWindow uint32 `protobuf:"varint,6,opt,name=max_deposits_per_window,json=maxDepositsPerWindow,proto3" json:"max_deposits_per_window,omitempty"`
}

func (x *DepositLimit) Reset() {
	*x = DepositLimit{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DepositLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositLimit) ProtoMessage() {}

// Deprecated: Use DepositLimit.ProtoReflect.Descriptor instead.
func (*DepositLimit) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{8}
}

func (x *DepositLimit) GetMaxUserDepositPerWindow() string {
	if x != nil {
		return x.MaxUserDepositPerWindow
	}
	return ""
}

func (x *DepositLimit) GetMaxBlockDepositVolume() string {
	if x != nil {
		return x.MaxBlockDepositVolume
	}
	return ""
}

func (x *DepositLimit) GetGlobalDepositCap() string {
	if x != nil {
		return x.GlobalDepositCap
	}
	return ""
}

func (x *DepositLimit) GetDepositCooldownBlocks() int64 {
	if x != nil {
		return x.DepositCooldownBlocks
	}
	return 0
}

func (x *DepositLimit) GetVelocityWindowBlocks() int64 {
	if x != nil {
		return x.VelocityWindowBlocks
	}
	return 0
}

func (x *DepositLimit) GetMaxDepositsPerWindow() uint32 {
	if x != nil {
		return x.MaxDepositsPerWindow
	}
	return 0
}

// DepositVelocity tracks user deposit velocity for risk monitoring
type DepositVelocity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Block height of last deposit
	LastDepositBlock int64 `protobuf:"varint,1,opt,name=last_deposit_block,json=lastDepositBlock,proto3" json:"last_deposit_block,omitempty"`
	// Number of deposits in recent time window
	RecentDepositCount uint32 `protobuf:"varint,2,opt,name=recent_deposit_count,json=recentDepositCount,proto3" json:"recent_deposit_count,omitempty"`
	// Total volume deposited in recent time window
	RecentDepositVolume string `protobuf:"bytes,3,opt,name=recent_deposit_volume,json=recentDepositVolume,proto3" json:"recent_deposit_volume,omitempty"`
	// Time window size in blocks
	TimeWindowBlocks int64 `protobuf:"varint,4,opt,name=time_window_blocks,json=timeWindowBlocks,proto3" json:"time_window_blocks,omitempty"`
}

func (x *DepositVelocity) Reset() {
	*x = DepositVelocity{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DepositVelocity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositVelocity) ProtoMessage() {}

// Deprecated: Use DepositVelocity.ProtoReflect.Descriptor instead.
func (*DepositVelocity) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{9}
}

func (x *DepositVelocity) GetLastDepositBlock() int64 {
	if x != nil {
		return x.LastDepositBlock
	}
	return 0
}

func (x *DepositVelocity) GetRecentDepositCount() uint32 {
	if x != nil {
		return x.RecentDepositCount
	}
	return 0
}

func (x *DepositVelocity) GetRecentDepositVolume() string {
	if x != nil {
		return x.RecentDepositVolume
	}
	return ""
}

func (x *DepositVelocity) GetTimeWindowBlocks() int64 {
	if x != nil {
		return x.TimeWindowBlocks
	}
	return 0
}

// TWAPConfig configures Time-Weighted Average Price for share pricing
type TWAPConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Whether TWAP is enabled for share pricing
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Number of historical NAV snapshots to include in TWAP calculation
	WindowSize uint32 `protobuf:"varint,2,opt,name=window_size,json=windowSize,proto3" json:"window_size,omitempty"`
	// Minimum time between NAV snapshots (in seconds)
	MinSnapshotInterval int64 `protobuf:"varint,3,opt,name=min_snapshot_interval,json=minSnapshotInterval,proto3" json:"min_snapshot_interval,omitempty"`
	// Maximum age of snapshots to include (in seconds)
	MaxSnapshotAge int64 `protobuf:"varint,4,opt,name=max_snapshot_age,json=maxSnapshotAge,proto3" json:"max_snapshot_age,omitempty"`
}

func (x *TWAPConfig) Reset() {
	*x = TWAPConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TWAPConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TWAPConfig) ProtoMessage() {}

// Deprecated: Use TWAPConfig.ProtoReflect.Descriptor instead.
func (*TWAPConfig) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{10}
}

func (x *TWAPConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *TWAPConfig) GetWindowSize() uint32 {
	if x != nil {
		return x.WindowSize
	}
	return 0
}

func (x *TWAPConfig) GetMinSnapshotInterval() int64 {
	if x != nil {
		return x.MinSnapshotInterval
	}
	return 0
}

func (x *TWAPConfig) GetMaxSnapshotAge() int64 {
	if x != nil {
		return x.MaxSnapshotAge
	}
	return 0
}

// NAVSnapshot represents a point-in-time NAV observation for TWAP
type NAVSnapshot struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// NAV value at this snapshot
	Nav string `protobuf:"bytes,1,opt,name=nav,proto3" json:"nav,omitempty"`
	// Timestamp of this snapshot
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Block height at this snapshot
	BlockHeight int64 `protobuf:"varint,3,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Total shares at this snapshot (for reference)
	TotalShares string `protobuf:"bytes,4,opt,name=total_shares,json=totalShares,proto3" json:"total_shares,omitempty"`
}

func (x *NAVSnapshot) Reset() {
	*x = NAVSnapshot{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NAVSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NAVSnapshot) ProtoMessage() {}

// Deprecated: Use NAVSnapshot.ProtoReflect.Descriptor instead.
func (*NAVSnapshot) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{11}
}

func (x *NAVSnapshot) GetNav() string {
	if x != nil {
		return x.Nav
	}
	return ""
}

func (x *NAVSnapshot) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *NAVSnapshot) GetBlockHeight() int64 {
	if x != nil {
		return x.BlockHeight
	}
	return 0
}

func (x *NAVSnapshot) GetTotalShares() string {
	if x != nil {
		return x.TotalShares
	}
	return ""
}

// AccountingCursor tracks progress of yield accounting operations
type AccountingCursor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Last user address that was processed
	LastProcessedUser string `protobuf:"bytes,1,opt,name=last_processed_user,json=lastProcessedUser,proto3" json:"last_processed_user,omitempty"`
	// NAV value being applied in this accounting session
	AccountingNav string `protobuf:"bytes,2,opt,name=accounting_nav,json=accountingNav,proto3" json:"accounting_nav,omitempty"`
	// Timestamp of NAV being applied
	AccountingNavTimestamp *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=accounting_nav_timestamp,json=accountingNavTimestamp,proto3" json:"accounting_nav_timestamp,omitempty"`
	// Number of positions processed in this accounting session
	PositionsProcessed uint64 `protobuf:"varint,4,opt,name=positions_processed,json=positionsProcessed,proto3" json:"positions_processed,omitempty"`
	// Total positions to process in this session
	TotalPositions uint64 `protobuf:"varint,5,opt,name=total_positions,json=totalPositions,proto3" json:"total_positions,omitempty"`
	// Whether accounting is currently in progress
	InProgress bool `protobuf:"varint,6,opt,name=in_progress,json=inProgress,proto3" json:"in_progress,omitempty"`
	// Timestamp when accounting started
	StartedAt *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// Accumulated residual from division precision handling
	AccumulatedResidual string `protobuf:"bytes,8,opt,name=accumulated_residual,json=accumulatedResidual,proto3" json:"accumulated_residual,omitempty"`
}

func (x *AccountingCursor) Reset() {
	*x = AccountingCursor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_vaults_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccountingCursor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccountingCursor) ProtoMessage() {}

// Deprecated: Use AccountingCursor.ProtoReflect.Descriptor instead.
func (*AccountingCursor) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP(), []int{12}
}

func (x *AccountingCursor) GetLastProcessedUser() string {
	if x != nil {
		return x.LastProcessedUser
	}
	return ""
}

func (x *AccountingCursor) GetAccountingNav() string {
	if x != nil {
		return x.AccountingNav
	}
	return ""
}

func (x *AccountingCursor) GetAccountingNavTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.AccountingNavTimestamp
	}
	return nil
}

func (x *AccountingCursor) GetPositionsProcessed() uint64 {
	if x != nil {
		return x.PositionsProcessed
	}
	return 0
}

func (x *AccountingCursor) GetTotalPositions() uint64 {
	if x != nil {
		return x.TotalPositions
	}
	return 0
}

func (x *AccountingCursor) GetInProgress() bool {
	if x != nil {
		return x.InProgress
	}
	return false
}

func (x *AccountingCursor) GetStartedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.StartedAt
	}
	return nil
}

func (x *AccountingCursor) GetAccumulatedResidual() string {
	if x != nil {
		return x.AccumulatedResidual
	}
	return ""
}

var File_noble_dollar_vaults_v2_vaults_proto protoreflect.FileDescriptor

var file_noble_dollar_vaults_v2_vaults_proto_rawDesc = []byte{
	0x0a, 0x23, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2f, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2f, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x2f, 0x76, 0x32, 0x2f, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x16, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c,
	0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x1a, 0x11, 0x61,
	0x6d, 0x69, 0x6e, 0x6f, 0x2f, 0x61, 0x6d, 0x69, 0x6e, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x19, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x67, 0x6f, 0x67,
	0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x22, 0xd8, 0x04, 0x0a, 0x0c, 0x55, 0x73, 0x65, 0x72, 0x50, 0x6f, 0x73, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x1f, 0x0a, 0x0b, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x49, 0x64, 0x12, 0x57, 0x0a, 0x0e, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x5f,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0d,
	0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x55, 0x0a,
	0x0d, 0x61, 0x63, 0x63, 0x72, 0x75, 0x65, 0x64, 0x5f, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e,
	0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0c, 0x61, 0x63, 0x63, 0x72, 0x75, 0x65, 0x64, 0x59,
	0x69, 0x65, 0x6c, 0x64, 0x12, 0x52, 0x0a, 0x12, 0x66, 0x69, 0x72, 0x73, 0x74, 0x5f, 0x64, 0x65,
	0x70, 0x6f, 0x73, 0x69, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde,
	0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x10, 0x66, 0x69, 0x72, 0x73, 0x74, 0x44, 0x65, 0x70,
	0x6f, 0x73, 0x69, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x52, 0x0a, 0x12, 0x6c, 0x61, 0x73, 0x74,
	0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x10, 0x6c, 0x61, 0x73, 0x74,
	0x41, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x23, 0x0a, 0x0d,
	0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x5f, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x0c, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x59, 0x69, 0x65, 0x6c,
	0x64, 0x12, 0x6c, 0x0a, 0x19, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x70, 0x65, 0x6e, 0x64,
	0x69, 0x6e, 0x67, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e,
	0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x17, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x50, 0x65,
	0x6e, 0x64, 0x69, 0x6e, 0x67, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x12,
	0x3c, 0x0a, 0x1a, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72,
	0x61, 0x77, 0x61, 0x6c, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x18, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x57, 0x69, 0x74, 0x68, 0x64,
	0x72, 0x61, 0x77, 0x61, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x22, 0xb1, 0x03,
	0x0a, 0x12, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x6e, 0x61, 0x70,
	0x73, 0x68, 0x6f, 0x74, 0x12, 0x2c, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x04, 0x75, 0x73,
	0x65, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x49, 0x64, 0x12, 0x57, 0x0a, 0x0e, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x5f, 0x61,
	0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69,
	0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0d, 0x64,
	0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x55, 0x0a, 0x0d,
	0x61, 0x63, 0x63, 0x72, 0x75, 0x65, 0x64, 0x5f, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49,
	0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74,
	0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0c, 0x61, 0x63, 0x63, 0x72, 0x75, 0x65, 0x64, 0x59, 0x69,
	0x65, 0x6c, 0x64, 0x12, 0x57, 0x0a, 0x0e, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e,
	0x67, 0x5f, 0x6e, 0x61, 0x76, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69,
	0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0d, 0x61,
	0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x4e, 0x61, 0x76, 0x12, 0x43, 0x0a, 0x0a,
	0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde,
	0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41,
	0x74, 0x22, 0xce, 0x04, 0x0a, 0x11, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x72, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x12, 0x36, 0x0a, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x09, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x72, 0x12, 0x1f,
	0x0a, 0x0b, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x0a, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12,
	0x59, 0x0a, 0x0f, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x5f, 0x61, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde,
	0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d,
	0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0e, 0x77, 0x69, 0x74, 0x68,
	0x64, 0x72, 0x61, 0x77, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x47, 0x0a, 0x0c, 0x72, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde,
	0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x0b, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54,
	0x69, 0x6d, 0x65, 0x12, 0x45, 0x0a, 0x0b, 0x75, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x74, 0x69,
	0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x0a,
	0x75, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x47, 0x0a, 0x06, 0x73, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2f, 0x2e, 0x6e, 0x6f, 0x62,
	0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73,
	0x2e, 0x76, 0x32, 0x2e, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x5b, 0x0a, 0x10, 0x65, 0x73, 0x74, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x64,
	0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b,
	0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52,
	0x0f, 0x65, 0x73, 0x74, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x64, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x12, 0x30, 0x0a, 0x14, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x62, 0x6c, 0x6f, 0x63,
	0x6b, 0x5f, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x03, 0x52, 0x12,
	0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x65, 0x69, 0x67,
	0x68, 0x74, 0x22, 0xc3, 0x05, 0x0a, 0x0a, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x53, 0x74, 0x61, 0x74,
	0x65, 0x12, 0x57, 0x0a, 0x0e, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x64, 0x65, 0x70, 0x6f, 0x73,
	0x69, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f,
	0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0d, 0x74, 0x6f, 0x74,
	0x61, 0x6c, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x73, 0x12, 0x60, 0x0a, 0x13, 0x74, 0x6f,
	0x74, 0x61, 0x6c, 0x5f, 0x61, 0x63, 0x63, 0x72, 0x75, 0x65, 0x64, 0x5f, 0x79, 0x69, 0x65, 0x6c,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f,
	0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61,
	0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x11, 0x74, 0x6f, 0x74, 0x61, 0x6c,
	0x41, 0x63, 0x63, 0x72, 0x75, 0x65, 0x64, 0x59, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x4d, 0x0a, 0x09,
	0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6e, 0x61, 0x76, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4,
	0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a,
	0x01, 0x52, 0x08, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x4e, 0x61, 0x76, 0x12, 0x1f, 0x0a, 0x0b, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x55, 0x73, 0x65, 0x72, 0x73, 0x12, 0x29, 0x0a, 0x10,
	0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x73, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x73,
	0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x2f, 0x0a, 0x13, 0x77, 0x69, 0x74, 0x68, 0x64,
	0x72, 0x61, 0x77, 0x61, 0x6c, 0x73, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c,
	0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x4c, 0x0a, 0x0f, 0x6c, 0x61, 0x73, 0x74,
	0x5f, 0x6e, 0x61, 0x76, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8,
	0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x4e, 0x61, 0x76,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x77, 0x0a, 0x1f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x77,
	0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4,
	0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a,
	0x01, 0x52, 0x1c, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x50, 0x65,
	0x6e, 0x64, 0x69, 0x6e, 0x67, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x12,
	0x3e, 0x0a, 0x1b, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x64,
	0x72, 0x61, 0x77, 0x61, 0x6c, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x18, 0x09,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x19, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x57, 0x69, 0x74,
	0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x12,
	0x27, 0x0a, 0x0f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0e, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x50,
	0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0xe6, 0x02, 0x0a, 0x10, 0x59, 0x69, 0x65,
	0x6c, 0x64, 0x43, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x57, 0x0a,
	0x0e, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49,
	0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0d, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x65,
	0x70, 0x6f, 0x73, 0x69, 0x74, 0x73, 0x12, 0x51, 0x0a, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f,
	0x79, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69,
	0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0a, 0x74,
	0x6f, 0x74, 0x61, 0x6c, 0x59, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x55, 0x0a, 0x0a, 0x79, 0x69, 0x65,
	0x6c, 0x64, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x36, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b,
	0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44,
	0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63,
	0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x09, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x52, 0x61, 0x74, 0x65,
	0x12, 0x4f, 0x0a, 0x10, 0x63, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x74, 0x69, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01,
	0x52, 0x0f, 0x63, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x69, 0x6d,
	0x65, 0x22, 0x6c, 0x0a, 0x0d, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x52, 0x65, 0x73, 0x75,
	0x6c, 0x74, 0x12, 0x5b, 0x0a, 0x10, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x64, 0x65, 0x70,
	0x6f, 0x73, 0x69, 0x74, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0f,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x65, 0x64, 0x22,
	0x85, 0x03, 0x0a, 0x10, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x52, 0x65,
	0x73, 0x75, 0x6c, 0x74, 0x12, 0x61, 0x0a, 0x13, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61,
	0x6c, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74,
	0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7,
	0xb0, 0x2a, 0x01, 0x52, 0x12, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x57, 0x69,
	0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x6e, 0x12, 0x59, 0x0a, 0x0f, 0x79, 0x69, 0x65, 0x6c, 0x64,
	0x5f, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2,
	0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0,
	0x2a, 0x01, 0x52, 0x0e, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61,
	0x77, 0x6e, 0x12, 0x4d, 0x0a, 0x09, 0x66, 0x65, 0x65, 0x73, 0x5f, 0x70, 0x61, 0x69, 0x64, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49,
	0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x08, 0x66, 0x65, 0x65, 0x73, 0x50, 0x61, 0x69,
	0x64, 0x12, 0x64, 0x0a, 0x15, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e,
	0x74, 0x5f, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2,
	0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0,
	0x2a, 0x01, 0x52, 0x13, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x52,
	0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x22, 0xc1, 0x02, 0x0a, 0x11, 0x59, 0x69, 0x65, 0x6c,
	0x64, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x51, 0x0a,
	0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e,
	0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8,
	0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x59, 0x69, 0x65, 0x6c, 0x64,
	0x12, 0x55, 0x0a, 0x0a, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x36, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x09, 0x79, 0x69,
	0x65, 0x6c, 0x64, 0x52, 0x61, 0x74, 0x65, 0x12, 0x51, 0x0a, 0x11, 0x64, 0x69, 0x73, 0x74, 0x72,
	0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08,
	0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x10, 0x64, 0x69, 0x73, 0x74, 0x72, 0x69,
	0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x2f, 0x0a, 0x13, 0x65, 0x6c,
	0x69, 0x67, 0x69, 0x62, 0x6c, 0x65, 0x5f, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x6f, 0x72,
	0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x12, 0x65, 0x6c, 0x69, 0x67, 0x69, 0x62, 0x6c,
	0x65, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x6f, 0x72, 0x73, 0x22, 0xee, 0x03, 0x0a, 0x0c,
	0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x6e, 0x0a, 0x1b,
	0x6d, 0x61, 0x78, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74,
	0x5f, 0x70, 0x65, 0x72, 0x5f, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74,
	0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7,
	0xb0, 0x2a, 0x01, 0x52, 0x17, 0x6d, 0x61, 0x78, 0x55, 0x73, 0x65, 0x72, 0x44, 0x65, 0x70, 0x6f,
	0x73, 0x69, 0x74, 0x50, 0x65, 0x72, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x12, 0x69, 0x0a, 0x18,
	0x6d, 0x61, 0x78, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69,
	0x74, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d,
	0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01,
	0x52, 0x15, 0x6d, 0x61, 0x78, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69,
	0x74, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x12, 0x5e, 0x0a, 0x12, 0x67, 0x6c, 0x6f, 0x62, 0x61,
	0x6c, 0x5f, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x5f, 0x63, 0x61, 0x70, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49,
	0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74,
	0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x10, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x44, 0x65, 0x70,
	0x6f, 0x73, 0x69, 0x74, 0x43, 0x61, 0x70, 0x12, 0x36, 0x0a, 0x17, 0x64, 0x65, 0x70, 0x6f, 0x73,
	0x69, 0x74, 0x5f, 0x63, 0x6f, 0x6f, 0x6c, 0x64, 0x6f, 0x77, 0x6e, 0x5f, 0x62, 0x6c, 0x6f, 0x63,
	0x6b, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x15, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69,
	0x74, 0x43, 0x6f, 0x6f, 0x6c, 0x64, 0x6f, 0x77, 0x6e, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x12,
	0x34, 0x0a, 0x16, 0x76, 0x65, 0x6c, 0x6f, 0x63, 0x69, 0x74, 0x79, 0x5f, 0x77, 0x69, 0x6e, 0x64,
	0x6f, 0x77, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52,
	0x14, 0x76, 0x65, 0x6c, 0x6f, 0x63, 0x69, 0x74, 0x79, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x42,
	0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x12, 0x35, 0x0a, 0x17, 0x6d, 0x61, 0x78, 0x5f, 0x64, 0x65, 0x70,
	0x6f, 0x73, 0x69, 0x74, 0x73, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x14, 0x6d, 0x61, 0x78, 0x44, 0x65, 0x70, 0x6f, 0x73,
	0x69, 0x74, 0x73, 0x50, 0x65, 0x72, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x22, 0x85, 0x02, 0x0a,
	0x0f, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x56, 0x65, 0x6c, 0x6f, 0x63, 0x69, 0x74, 0x79,
	0x12, 0x2c, 0x0a, 0x12, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74,
	0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x10, 0x6c, 0x61,
	0x73, 0x74, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x12, 0x30,
	0x0a, 0x14, 0x72, 0x65, 0x63, 0x65, 0x6e, 0x74, 0x5f, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74,
	0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x72, 0x65,
	0x63, 0x65, 0x6e, 0x74, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74,
	0x12, 0x64, 0x0a, 0x15, 0x72, 0x65, 0x63, 0x65, 0x6e, 0x74, 0x5f, 0x64, 0x65, 0x70, 0x6f, 0x73,
	0x69, 0x74, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4,
	0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a,
	0x01, 0x52, 0x13, 0x72, 0x65, 0x63, 0x65, 0x6e, 0x74, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74,
	0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x12, 0x2c, 0x0a, 0x12, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x77,
	0x69, 0x6e, 0x64, 0x6f, 0x77, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x03, 0x52, 0x10, 0x74, 0x69, 0x6d, 0x65, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x42, 0x6c,
	0x6f, 0x63, 0x6b, 0x73, 0x22, 0xa5, 0x01, 0x0a, 0x0a, 0x54, 0x57, 0x41, 0x50, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1f, 0x0a,
	0x0b, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x0a, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x32,
	0x0a, 0x15, 0x6d, 0x69, 0x6e, 0x5f, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x5f, 0x69,
	0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x13, 0x6d,
	0x69, 0x6e, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76,
	0x61, 0x6c, 0x12, 0x28, 0x0a, 0x10, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68,
	0x6f, 0x74, 0x5f, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0e, 0x6d, 0x61,
	0x78, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x41, 0x67, 0x65, 0x22, 0x8d, 0x02, 0x0a,
	0x0b, 0x4e, 0x41, 0x56, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x12, 0x42, 0x0a, 0x03,
	0x6e, 0x61, 0x76, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f,
	0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x03, 0x6e, 0x61, 0x76,
	0x12, 0x42, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42,
	0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x12, 0x21, 0x0a, 0x0c, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x68, 0x65,
	0x69, 0x67, 0x68, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x62, 0x6c, 0x6f, 0x63,
	0x6b, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x53, 0x0a, 0x0c, 0x74, 0x6f, 0x74, 0x61, 0x6c,
	0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b,
	0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52,
	0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x68, 0x61, 0x72, 0x65, 0x73, 0x22, 0xba, 0x04, 0x0a,
	0x10, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x43, 0x75, 0x72, 0x73, 0x6f,
	0x72, 0x12, 0x48, 0x0a, 0x13, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73,
	0x73, 0x65, 0x64, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18,
	0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x11, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x72,
	0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x55, 0x73, 0x65, 0x72, 0x12, 0x57, 0x0a, 0x0e, 0x61,
	0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x6e, 0x61, 0x76, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49,
	0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74,
	0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0d, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e,
	0x67, 0x4e, 0x61, 0x76, 0x12, 0x5e, 0x0a, 0x18, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69,
	0x6e, 0x67, 0x5f, 0x6e, 0x61, 0x76, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
	0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x16, 0x61, 0x63,
	0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x4e, 0x61, 0x76, 0x54, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x12, 0x2f, 0x0a, 0x13, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x12, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x50, 0x72, 0x6f, 0x63,
	0x65, 0x73, 0x73, 0x65, 0x64, 0x12, 0x27, 0x0a, 0x0f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70,
	0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0e,
	0x74, 0x6f, 0x74, 0x61, 0x6c, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x1f,
	0x0a, 0x0b, 0x69, 0x6e, 0x5f, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x6e, 0x50, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73, 0x12,
	0x43, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x07, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42,
	0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74,
	0x65, 0x64, 0x41, 0x74, 0x12, 0x63, 0x0a, 0x14, 0x61, 0x63, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61,
	0x74, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x73, 0x69, 0x64, 0x75, 0x61, 0x6c, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e,
	0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8,
	0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x13, 0x61, 0x63, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x65,
	0x64, 0x52, 0x65, 0x73, 0x69, 0x64, 0x75, 0x61, 0x6c, 0x2a, 0xe4, 0x01, 0x0a, 0x17, 0x57, 0x69,
	0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x61, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x25, 0x0a, 0x21, 0x57, 0x49, 0x54, 0x48, 0x44, 0x52, 0x41,
	0x57, 0x41, 0x4c, 0x5f, 0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54,
	0x55, 0x53, 0x5f, 0x50, 0x45, 0x4e, 0x44, 0x49, 0x4e, 0x47, 0x10, 0x00, 0x12, 0x23, 0x0a, 0x1f,
	0x57, 0x49, 0x54, 0x48, 0x44, 0x52, 0x41, 0x57, 0x41, 0x4c, 0x5f, 0x52, 0x45, 0x51, 0x55, 0x45,
	0x53, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x52, 0x45, 0x41, 0x44, 0x59, 0x10,
	0x01, 0x12, 0x27, 0x0a, 0x23, 0x57, 0x49, 0x54, 0x48, 0x44, 0x52, 0x41, 0x57, 0x41, 0x4c, 0x5f,
	0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x50,
	0x52, 0x4f, 0x43, 0x45, 0x53, 0x53, 0x45, 0x44, 0x10, 0x02, 0x12, 0x27, 0x0a, 0x23, 0x57, 0x49,
	0x54, 0x48, 0x44, 0x52, 0x41, 0x57, 0x41, 0x4c, 0x5f, 0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54,
	0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x43, 0x41, 0x4e, 0x43, 0x45, 0x4c, 0x4c, 0x45,
	0x44, 0x10, 0x03, 0x12, 0x25, 0x0a, 0x21, 0x57, 0x49, 0x54, 0x48, 0x44, 0x52, 0x41, 0x57, 0x41,
	0x4c, 0x5f, 0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53,
	0x5f, 0x45, 0x58, 0x50, 0x49, 0x52, 0x45, 0x44, 0x10, 0x04, 0x1a, 0x04, 0x88, 0xa3, 0x1e, 0x00,
	0x42, 0xdd, 0x01, 0x0a, 0x1a, 0x63, 0x6f, 0x6d, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x42,
	0x0b, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x37,
	0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x78, 0x79, 0x7a,
	0x2f, 0x76, 0x33, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2f, 0x64, 0x6f,
	0x6c, 0x6c, 0x61, 0x72, 0x2f, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2f, 0x76, 0x32, 0x3b, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x76, 0x32, 0xa2, 0x02, 0x03, 0x4e, 0x44, 0x56, 0xaa, 0x02, 0x16,
	0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x44, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x56, 0x61, 0x75,
	0x6c, 0x74, 0x73, 0x2e, 0x56, 0x32, 0xca, 0x02, 0x16, 0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x5c, 0x44,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x5c, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x5c, 0x56, 0x32, 0xe2,
	0x02, 0x22, 0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x5c, 0x44, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x5c, 0x56,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x5c, 0x56, 0x32, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x19, 0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x3a, 0x3a, 0x44, 0x6f,
	0x6c, 0x6c, 0x61, 0x72, 0x3a, 0x3a, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x3a, 0x3a, 0x56, 0x32,
	0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_noble_dollar_vaults_v2_vaults_proto_rawDescOnce sync.Once
	file_noble_dollar_vaults_v2_vaults_proto_rawDescData = file_noble_dollar_vaults_v2_vaults_proto_rawDesc
)

func file_noble_dollar_vaults_v2_vaults_proto_rawDescGZIP() []byte {
	file_noble_dollar_vaults_v2_vaults_proto_rawDescOnce.Do(func() {
		file_noble_dollar_vaults_v2_vaults_proto_rawDescData = protoimpl.X.CompressGZIP(file_noble_dollar_vaults_v2_vaults_proto_rawDescData)
	})
	return file_noble_dollar_vaults_v2_vaults_proto_rawDescData
}

var file_noble_dollar_vaults_v2_vaults_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_noble_dollar_vaults_v2_vaults_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_noble_dollar_vaults_v2_vaults_proto_goTypes = []interface{}{
	(WithdrawalRequestStatus)(0),  // 0: noble.dollar.vaults.v2.WithdrawalRequestStatus
	(*UserPosition)(nil),          // 1: noble.dollar.vaults.v2.UserPosition
	(*AccountingSnapshot)(nil),    // 2: noble.dollar.vaults.v2.AccountingSnapshot
	(*WithdrawalRequest)(nil),     // 3: noble.dollar.vaults.v2.WithdrawalRequest
	(*VaultState)(nil),            // 4: noble.dollar.vaults.v2.VaultState
	(*YieldCalculation)(nil),      // 5: noble.dollar.vaults.v2.YieldCalculation
	(*DepositResult)(nil),         // 6: noble.dollar.vaults.v2.DepositResult
	(*WithdrawalResult)(nil),      // 7: noble.dollar.vaults.v2.WithdrawalResult
	(*YieldDistribution)(nil),     // 8: noble.dollar.vaults.v2.YieldDistribution
	(*DepositLimit)(nil),          // 9: noble.dollar.vaults.v2.DepositLimit
	(*DepositVelocity)(nil),       // 10: noble.dollar.vaults.v2.DepositVelocity
	(*TWAPConfig)(nil),            // 11: noble.dollar.vaults.v2.TWAPConfig
	(*NAVSnapshot)(nil),           // 12: noble.dollar.vaults.v2.NAVSnapshot
	(*AccountingCursor)(nil),      // 13: noble.dollar.vaults.v2.AccountingCursor
	(*timestamppb.Timestamp)(nil), // 14: google.protobuf.Timestamp
}
var file_noble_dollar_vaults_v2_vaults_proto_depIdxs = []int32{
	14, // 0: noble.dollar.vaults.v2.UserPosition.first_deposit_time:type_name -> google.protobuf.Timestamp
	14, // 1: noble.dollar.vaults.v2.UserPosition.last_activity_time:type_name -> google.protobuf.Timestamp
	14, // 2: noble.dollar.vaults.v2.AccountingSnapshot.created_at:type_name -> google.protobuf.Timestamp
	14, // 3: noble.dollar.vaults.v2.WithdrawalRequest.request_time:type_name -> google.protobuf.Timestamp
	14, // 4: noble.dollar.vaults.v2.WithdrawalRequest.unlock_time:type_name -> google.protobuf.Timestamp
	0,  // 5: noble.dollar.vaults.v2.WithdrawalRequest.status:type_name -> noble.dollar.vaults.v2.WithdrawalRequestStatus
	14, // 6: noble.dollar.vaults.v2.VaultState.last_nav_update:type_name -> google.protobuf.Timestamp
	14, // 7: noble.dollar.vaults.v2.YieldCalculation.calculation_time:type_name -> google.protobuf.Timestamp
	14, // 8: noble.dollar.vaults.v2.YieldDistribution.distribution_time:type_name -> google.protobuf.Timestamp
	14, // 9: noble.dollar.vaults.v2.NAVSnapshot.timestamp:type_name -> google.protobuf.Timestamp
	14, // 10: noble.dollar.vaults.v2.AccountingCursor.accounting_nav_timestamp:type_name -> google.protobuf.Timestamp
	14, // 11: noble.dollar.vaults.v2.AccountingCursor.started_at:type_name -> google.protobuf.Timestamp
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_noble_dollar_vaults_v2_vaults_proto_init() }
func file_noble_dollar_vaults_v2_vaults_proto_init() {
	if File_noble_dollar_vaults_v2_vaults_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserPosition); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccountingSnapshot); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WithdrawalRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VaultState); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*YieldCalculation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DepositResult); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WithdrawalResult); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*YieldDistribution); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DepositLimit); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DepositVelocity); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TWAPConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NAVSnapshot); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_vaults_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccountingCursor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_noble_dollar_vaults_v2_vaults_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_noble_dollar_vaults_v2_vaults_proto_goTypes,
		DependencyIndexes: file_noble_dollar_vaults_v2_vaults_proto_depIdxs,
		EnumInfos:         file_noble_dollar_vaults_v2_vaults_proto_enumTypes,
		MessageInfos:      file_noble_dollar_vaults_v2_vaults_proto_msgTypes,
	}.Build()
	File_noble_dollar_vaults_v2_vaults_proto = out.File
	file_noble_dollar_vaults_v2_vaults_proto_rawDesc = nil
	file_noble_dollar_vaults_v2_vaults_proto_goTypes = nil
	file_noble_dollar_vaults_v2_vaults_proto_depIdxs = nil
}
