// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package vaultsv2

import (
	_ "cosmossdk.io/api/amino"
	_ "dollar.noble.xyz/v3/api/hyperlane/warp/v1"
	binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	reflect "reflect"
	sort "sort"
	sync "sync"
)

var (
	md_CrossChainRoute                         protoreflect.MessageDescriptor
	fd_CrossChainRoute_hyptoken_id             protoreflect.FieldDescriptor
	fd_CrossChainRoute_receiver_chain_hook     protoreflect.FieldDescriptor
	fd_CrossChainRoute_remote_position_address protoreflect.FieldDescriptor
	fd_CrossChainRoute_max_inflight_value      protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_CrossChainRoute = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("CrossChainRoute")
	fd_CrossChainRoute_hyptoken_id = md_CrossChainRoute.Fields().ByName("hyptoken_id")
	fd_CrossChainRoute_receiver_chain_hook = md_CrossChainRoute.Fields().ByName("receiver_chain_hook")
	fd_CrossChainRoute_remote_position_address = md_CrossChainRoute.Fields().ByName("remote_position_address")
	fd_CrossChainRoute_max_inflight_value = md_CrossChainRoute.Fields().ByName("max_inflight_value")
}

var _ protoreflect.Message = (*fastReflection_CrossChainRoute)(nil)

type fastReflection_CrossChainRoute CrossChainRoute

func (x *CrossChainRoute) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CrossChainRoute)(x)
}

func (x *CrossChainRoute) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CrossChainRoute_messageType fastReflection_CrossChainRoute_messageType
var _ protoreflect.MessageType = fastReflection_CrossChainRoute_messageType{}

type fastReflection_CrossChainRoute_messageType struct{}

func (x fastReflection_CrossChainRoute_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CrossChainRoute)(nil)
}
func (x fastReflection_CrossChainRoute_messageType) New() protoreflect.Message {
	return new(fastReflection_CrossChainRoute)
}
func (x fastReflection_CrossChainRoute_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CrossChainRoute
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CrossChainRoute) Descriptor() protoreflect.MessageDescriptor {
	return md_CrossChainRoute
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CrossChainRoute) Type() protoreflect.MessageType {
	return _fastReflection_CrossChainRoute_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CrossChainRoute) New() protoreflect.Message {
	return new(fastReflection_CrossChainRoute)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CrossChainRoute) Interface() protoreflect.ProtoMessage {
	return (*CrossChainRoute)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CrossChainRoute) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.HyptokenId != "" {
		value := protoreflect.ValueOfString(x.HyptokenId)
		if !f(fd_CrossChainRoute_hyptoken_id, value) {
			return
		}
	}
	if x.ReceiverChainHook != "" {
		value := protoreflect.ValueOfString(x.ReceiverChainHook)
		if !f(fd_CrossChainRoute_receiver_chain_hook, value) {
			return
		}
	}
	if x.RemotePositionAddress != "" {
		value := protoreflect.ValueOfString(x.RemotePositionAddress)
		if !f(fd_CrossChainRoute_remote_position_address, value) {
			return
		}
	}
	if x.MaxInflightValue != "" {
		value := protoreflect.ValueOfString(x.MaxInflightValue)
		if !f(fd_CrossChainRoute_max_inflight_value, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CrossChainRoute) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainRoute.hyptoken_id":
		return x.HyptokenId != ""
	case "noble.dollar.vaults.v2.CrossChainRoute.receiver_chain_hook":
		return x.ReceiverChainHook != ""
	case "noble.dollar.vaults.v2.CrossChainRoute.remote_position_address":
		return x.RemotePositionAddress != ""
	case "noble.dollar.vaults.v2.CrossChainRoute.max_inflight_value":
		return x.MaxInflightValue != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainRoute"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainRoute does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainRoute) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainRoute.hyptoken_id":
		x.HyptokenId = ""
	case "noble.dollar.vaults.v2.CrossChainRoute.receiver_chain_hook":
		x.ReceiverChainHook = ""
	case "noble.dollar.vaults.v2.CrossChainRoute.remote_position_address":
		x.RemotePositionAddress = ""
	case "noble.dollar.vaults.v2.CrossChainRoute.max_inflight_value":
		x.MaxInflightValue = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainRoute"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainRoute does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CrossChainRoute) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.CrossChainRoute.hyptoken_id":
		value := x.HyptokenId
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.CrossChainRoute.receiver_chain_hook":
		value := x.ReceiverChainHook
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.CrossChainRoute.remote_position_address":
		value := x.RemotePositionAddress
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.CrossChainRoute.max_inflight_value":
		value := x.MaxInflightValue
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainRoute"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainRoute does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainRoute) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainRoute.hyptoken_id":
		x.HyptokenId = value.Interface().(string)
	case "noble.dollar.vaults.v2.CrossChainRoute.receiver_chain_hook":
		x.ReceiverChainHook = value.Interface().(string)
	case "noble.dollar.vaults.v2.CrossChainRoute.remote_position_address":
		x.RemotePositionAddress = value.Interface().(string)
	case "noble.dollar.vaults.v2.CrossChainRoute.max_inflight_value":
		x.MaxInflightValue = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainRoute"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainRoute does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainRoute) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainRoute.hyptoken_id":
		panic(fmt.Errorf("field hyptoken_id of message noble.dollar.vaults.v2.CrossChainRoute is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainRoute.receiver_chain_hook":
		panic(fmt.Errorf("field receiver_chain_hook of message noble.dollar.vaults.v2.CrossChainRoute is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainRoute.remote_position_address":
		panic(fmt.Errorf("field remote_position_address of message noble.dollar.vaults.v2.CrossChainRoute is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainRoute.max_inflight_value":
		panic(fmt.Errorf("field max_inflight_value of message noble.dollar.vaults.v2.CrossChainRoute is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainRoute"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainRoute does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CrossChainRoute) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainRoute.hyptoken_id":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.CrossChainRoute.receiver_chain_hook":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.CrossChainRoute.remote_position_address":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.CrossChainRoute.max_inflight_value":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainRoute"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainRoute does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CrossChainRoute) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.CrossChainRoute", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CrossChainRoute) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainRoute) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CrossChainRoute) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CrossChainRoute) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CrossChainRoute)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.HyptokenId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ReceiverChainHook)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RemotePositionAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MaxInflightValue)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CrossChainRoute)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.MaxInflightValue) > 0 {
			i -= len(x.MaxInflightValue)
			copy(dAtA[i:], x.MaxInflightValue)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MaxInflightValue)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.RemotePositionAddress) > 0 {
			i -= len(x.RemotePositionAddress)
			copy(dAtA[i:], x.RemotePositionAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RemotePositionAddress)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.ReceiverChainHook) > 0 {
			i -= len(x.ReceiverChainHook)
			copy(dAtA[i:], x.ReceiverChainHook)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ReceiverChainHook)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.HyptokenId) > 0 {
			i -= len(x.HyptokenId)
			copy(dAtA[i:], x.HyptokenId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.HyptokenId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CrossChainRoute)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CrossChainRoute: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field HyptokenId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.HyptokenId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReceiverChainHook", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ReceiverChainHook = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RemotePositionAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RemotePositionAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxInflightValue", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MaxInflightValue = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_RemotePosition                protoreflect.MessageDescriptor
	fd_RemotePosition_hyptoken_id    protoreflect.FieldDescriptor
	fd_RemotePosition_vault_address  protoreflect.FieldDescriptor
	fd_RemotePosition_shares_held    protoreflect.FieldDescriptor
	fd_RemotePosition_principal      protoreflect.FieldDescriptor
	fd_RemotePosition_share_price    protoreflect.FieldDescriptor
	fd_RemotePosition_total_value    protoreflect.FieldDescriptor
	fd_RemotePosition_last_update    protoreflect.FieldDescriptor
	fd_RemotePosition_status         protoreflect.FieldDescriptor
	fd_RemotePosition_oracle_address protoreflect.FieldDescriptor
	fd_RemotePosition_max_staleness  protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_RemotePosition = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("RemotePosition")
	fd_RemotePosition_hyptoken_id = md_RemotePosition.Fields().ByName("hyptoken_id")
	fd_RemotePosition_vault_address = md_RemotePosition.Fields().ByName("vault_address")
	fd_RemotePosition_shares_held = md_RemotePosition.Fields().ByName("shares_held")
	fd_RemotePosition_principal = md_RemotePosition.Fields().ByName("principal")
	fd_RemotePosition_share_price = md_RemotePosition.Fields().ByName("share_price")
	fd_RemotePosition_total_value = md_RemotePosition.Fields().ByName("total_value")
	fd_RemotePosition_last_update = md_RemotePosition.Fields().ByName("last_update")
	fd_RemotePosition_status = md_RemotePosition.Fields().ByName("status")
	fd_RemotePosition_oracle_address = md_RemotePosition.Fields().ByName("oracle_address")
	fd_RemotePosition_max_staleness = md_RemotePosition.Fields().ByName("max_staleness")
}

var _ protoreflect.Message = (*fastReflection_RemotePosition)(nil)

type fastReflection_RemotePosition RemotePosition

func (x *RemotePosition) ProtoReflect() protoreflect.Message {
	return (*fastReflection_RemotePosition)(x)
}

func (x *RemotePosition) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_RemotePosition_messageType fastReflection_RemotePosition_messageType
var _ protoreflect.MessageType = fastReflection_RemotePosition_messageType{}

type fastReflection_RemotePosition_messageType struct{}

func (x fastReflection_RemotePosition_messageType) Zero() protoreflect.Message {
	return (*fastReflection_RemotePosition)(nil)
}
func (x fastReflection_RemotePosition_messageType) New() protoreflect.Message {
	return new(fastReflection_RemotePosition)
}
func (x fastReflection_RemotePosition_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_RemotePosition
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_RemotePosition) Descriptor() protoreflect.MessageDescriptor {
	return md_RemotePosition
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_RemotePosition) Type() protoreflect.MessageType {
	return _fastReflection_RemotePosition_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_RemotePosition) New() protoreflect.Message {
	return new(fastReflection_RemotePosition)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_RemotePosition) Interface() protoreflect.ProtoMessage {
	return (*RemotePosition)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_RemotePosition) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.HyptokenId != "" {
		value := protoreflect.ValueOfString(x.HyptokenId)
		if !f(fd_RemotePosition_hyptoken_id, value) {
			return
		}
	}
	if len(x.VaultAddress) != 0 {
		value := protoreflect.ValueOfBytes(x.VaultAddress)
		if !f(fd_RemotePosition_vault_address, value) {
			return
		}
	}
	if x.SharesHeld != "" {
		value := protoreflect.ValueOfString(x.SharesHeld)
		if !f(fd_RemotePosition_shares_held, value) {
			return
		}
	}
	if x.Principal != "" {
		value := protoreflect.ValueOfString(x.Principal)
		if !f(fd_RemotePosition_principal, value) {
			return
		}
	}
	if x.SharePrice != "" {
		value := protoreflect.ValueOfString(x.SharePrice)
		if !f(fd_RemotePosition_share_price, value) {
			return
		}
	}
	if x.TotalValue != "" {
		value := protoreflect.ValueOfString(x.TotalValue)
		if !f(fd_RemotePosition_total_value, value) {
			return
		}
	}
	if x.LastUpdate != nil {
		value := protoreflect.ValueOfMessage(x.LastUpdate.ProtoReflect())
		if !f(fd_RemotePosition_last_update, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_RemotePosition_status, value) {
			return
		}
	}
	if x.OracleAddress != "" {
		value := protoreflect.ValueOfString(x.OracleAddress)
		if !f(fd_RemotePosition_oracle_address, value) {
			return
		}
	}
	if x.MaxStaleness != int64(0) {
		value := protoreflect.ValueOfInt64(x.MaxStaleness)
		if !f(fd_RemotePosition_max_staleness, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_RemotePosition) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.RemotePosition.hyptoken_id":
		return x.HyptokenId != ""
	case "noble.dollar.vaults.v2.RemotePosition.vault_address":
		return len(x.VaultAddress) != 0
	case "noble.dollar.vaults.v2.RemotePosition.shares_held":
		return x.SharesHeld != ""
	case "noble.dollar.vaults.v2.RemotePosition.principal":
		return x.Principal != ""
	case "noble.dollar.vaults.v2.RemotePosition.share_price":
		return x.SharePrice != ""
	case "noble.dollar.vaults.v2.RemotePosition.total_value":
		return x.TotalValue != ""
	case "noble.dollar.vaults.v2.RemotePosition.last_update":
		return x.LastUpdate != nil
	case "noble.dollar.vaults.v2.RemotePosition.status":
		return x.Status != 0
	case "noble.dollar.vaults.v2.RemotePosition.oracle_address":
		return x.OracleAddress != ""
	case "noble.dollar.vaults.v2.RemotePosition.max_staleness":
		return x.MaxStaleness != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.RemotePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.RemotePosition does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemotePosition) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.RemotePosition.hyptoken_id":
		x.HyptokenId = ""
	case "noble.dollar.vaults.v2.RemotePosition.vault_address":
		x.VaultAddress = nil
	case "noble.dollar.vaults.v2.RemotePosition.shares_held":
		x.SharesHeld = ""
	case "noble.dollar.vaults.v2.RemotePosition.principal":
		x.Principal = ""
	case "noble.dollar.vaults.v2.RemotePosition.share_price":
		x.SharePrice = ""
	case "noble.dollar.vaults.v2.RemotePosition.total_value":
		x.TotalValue = ""
	case "noble.dollar.vaults.v2.RemotePosition.last_update":
		x.LastUpdate = nil
	case "noble.dollar.vaults.v2.RemotePosition.status":
		x.Status = 0
	case "noble.dollar.vaults.v2.RemotePosition.oracle_address":
		x.OracleAddress = ""
	case "noble.dollar.vaults.v2.RemotePosition.max_staleness":
		x.MaxStaleness = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.RemotePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.RemotePosition does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_RemotePosition) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.RemotePosition.hyptoken_id":
		value := x.HyptokenId
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.RemotePosition.vault_address":
		value := x.VaultAddress
		return protoreflect.ValueOfBytes(value)
	case "noble.dollar.vaults.v2.RemotePosition.shares_held":
		value := x.SharesHeld
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.RemotePosition.principal":
		value := x.Principal
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.RemotePosition.share_price":
		value := x.SharePrice
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.RemotePosition.total_value":
		value := x.TotalValue
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.RemotePosition.last_update":
		value := x.LastUpdate
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.RemotePosition.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "noble.dollar.vaults.v2.RemotePosition.oracle_address":
		value := x.OracleAddress
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.RemotePosition.max_staleness":
		value := x.MaxStaleness
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.RemotePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.RemotePosition does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemotePosition) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.RemotePosition.hyptoken_id":
		x.HyptokenId = value.Interface().(string)
	case "noble.dollar.vaults.v2.RemotePosition.vault_address":
		x.VaultAddress = value.Bytes()
	case "noble.dollar.vaults.v2.RemotePosition.shares_held":
		x.SharesHeld = value.Interface().(string)
	case "noble.dollar.vaults.v2.RemotePosition.principal":
		x.Principal = value.Interface().(string)
	case "noble.dollar.vaults.v2.RemotePosition.share_price":
		x.SharePrice = value.Interface().(string)
	case "noble.dollar.vaults.v2.RemotePosition.total_value":
		x.TotalValue = value.Interface().(string)
	case "noble.dollar.vaults.v2.RemotePosition.last_update":
		x.LastUpdate = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.RemotePosition.status":
		x.Status = (RemotePositionStatus)(value.Enum())
	case "noble.dollar.vaults.v2.RemotePosition.oracle_address":
		x.OracleAddress = value.Interface().(string)
	case "noble.dollar.vaults.v2.RemotePosition.max_staleness":
		x.MaxStaleness = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.RemotePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.RemotePosition does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemotePosition) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.RemotePosition.last_update":
		if x.LastUpdate == nil {
			x.LastUpdate = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.LastUpdate.ProtoReflect())
	case "noble.dollar.vaults.v2.RemotePosition.hyptoken_id":
		panic(fmt.Errorf("field hyptoken_id of message noble.dollar.vaults.v2.RemotePosition is not mutable"))
	case "noble.dollar.vaults.v2.RemotePosition.vault_address":
		panic(fmt.Errorf("field vault_address of message noble.dollar.vaults.v2.RemotePosition is not mutable"))
	case "noble.dollar.vaults.v2.RemotePosition.shares_held":
		panic(fmt.Errorf("field shares_held of message noble.dollar.vaults.v2.RemotePosition is not mutable"))
	case "noble.dollar.vaults.v2.RemotePosition.principal":
		panic(fmt.Errorf("field principal of message noble.dollar.vaults.v2.RemotePosition is not mutable"))
	case "noble.dollar.vaults.v2.RemotePosition.share_price":
		panic(fmt.Errorf("field share_price of message noble.dollar.vaults.v2.RemotePosition is not mutable"))
	case "noble.dollar.vaults.v2.RemotePosition.total_value":
		panic(fmt.Errorf("field total_value of message noble.dollar.vaults.v2.RemotePosition is not mutable"))
	case "noble.dollar.vaults.v2.RemotePosition.status":
		panic(fmt.Errorf("field status of message noble.dollar.vaults.v2.RemotePosition is not mutable"))
	case "noble.dollar.vaults.v2.RemotePosition.oracle_address":
		panic(fmt.Errorf("field oracle_address of message noble.dollar.vaults.v2.RemotePosition is not mutable"))
	case "noble.dollar.vaults.v2.RemotePosition.max_staleness":
		panic(fmt.Errorf("field max_staleness of message noble.dollar.vaults.v2.RemotePosition is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.RemotePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.RemotePosition does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_RemotePosition) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.RemotePosition.hyptoken_id":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.RemotePosition.vault_address":
		return protoreflect.ValueOfBytes(nil)
	case "noble.dollar.vaults.v2.RemotePosition.shares_held":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.RemotePosition.principal":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.RemotePosition.share_price":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.RemotePosition.total_value":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.RemotePosition.last_update":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.RemotePosition.status":
		return protoreflect.ValueOfEnum(0)
	case "noble.dollar.vaults.v2.RemotePosition.oracle_address":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.RemotePosition.max_staleness":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.RemotePosition"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.RemotePosition does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_RemotePosition) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.RemotePosition", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_RemotePosition) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemotePosition) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_RemotePosition) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_RemotePosition) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*RemotePosition)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.HyptokenId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.VaultAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SharesHeld)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Principal)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SharePrice)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalValue)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.LastUpdate != nil {
			l = options.Size(x.LastUpdate)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		l = len(x.OracleAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MaxStaleness != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxStaleness))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*RemotePosition)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.MaxStaleness != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxStaleness))
			i--
			dAtA[i] = 0x50
		}
		if len(x.OracleAddress) > 0 {
			i -= len(x.OracleAddress)
			copy(dAtA[i:], x.OracleAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OracleAddress)))
			i--
			dAtA[i] = 0x4a
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x40
		}
		if x.LastUpdate != nil {
			encoded, err := options.Marshal(x.LastUpdate)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.TotalValue) > 0 {
			i -= len(x.TotalValue)
			copy(dAtA[i:], x.TotalValue)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalValue)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.SharePrice) > 0 {
			i -= len(x.SharePrice)
			copy(dAtA[i:], x.SharePrice)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SharePrice)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Principal) > 0 {
			i -= len(x.Principal)
			copy(dAtA[i:], x.Principal)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Principal)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.SharesHeld) > 0 {
			i -= len(x.SharesHeld)
			copy(dAtA[i:], x.SharesHeld)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SharesHeld)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.VaultAddress) > 0 {
			i -= len(x.VaultAddress)
			copy(dAtA[i:], x.VaultAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.VaultAddress)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.HyptokenId) > 0 {
			i -= len(x.HyptokenId)
			copy(dAtA[i:], x.HyptokenId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.HyptokenId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*RemotePosition)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: RemotePosition: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: RemotePosition: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field HyptokenId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.HyptokenId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.VaultAddress = append(x.VaultAddress[:0], dAtA[iNdEx:postIndex]...)
				if x.VaultAddress == nil {
					x.VaultAddress = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SharesHeld", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SharesHeld = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Principal = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SharePrice = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalValue = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.LastUpdate == nil {
					x.LastUpdate = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LastUpdate); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= RemotePositionStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OracleAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OracleAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxStaleness", wireType)
				}
				x.MaxStaleness = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxStaleness |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_InflightFund                     protoreflect.MessageDescriptor
	fd_InflightFund_id                  protoreflect.FieldDescriptor
	fd_InflightFund_transaction_id      protoreflect.FieldDescriptor
	fd_InflightFund_amount              protoreflect.FieldDescriptor
	fd_InflightFund_noble_origin        protoreflect.FieldDescriptor
	fd_InflightFund_remote_origin       protoreflect.FieldDescriptor
	fd_InflightFund_noble_destination   protoreflect.FieldDescriptor
	fd_InflightFund_remote_destination  protoreflect.FieldDescriptor
	fd_InflightFund_initiated_at        protoreflect.FieldDescriptor
	fd_InflightFund_expected_at         protoreflect.FieldDescriptor
	fd_InflightFund_status              protoreflect.FieldDescriptor
	fd_InflightFund_value_at_initiation protoreflect.FieldDescriptor
	fd_InflightFund_provider_tracking   protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_InflightFund = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("InflightFund")
	fd_InflightFund_id = md_InflightFund.Fields().ByName("id")
	fd_InflightFund_transaction_id = md_InflightFund.Fields().ByName("transaction_id")
	fd_InflightFund_amount = md_InflightFund.Fields().ByName("amount")
	fd_InflightFund_noble_origin = md_InflightFund.Fields().ByName("noble_origin")
	fd_InflightFund_remote_origin = md_InflightFund.Fields().ByName("remote_origin")
	fd_InflightFund_noble_destination = md_InflightFund.Fields().ByName("noble_destination")
	fd_InflightFund_remote_destination = md_InflightFund.Fields().ByName("remote_destination")
	fd_InflightFund_initiated_at = md_InflightFund.Fields().ByName("initiated_at")
	fd_InflightFund_expected_at = md_InflightFund.Fields().ByName("expected_at")
	fd_InflightFund_status = md_InflightFund.Fields().ByName("status")
	fd_InflightFund_value_at_initiation = md_InflightFund.Fields().ByName("value_at_initiation")
	fd_InflightFund_provider_tracking = md_InflightFund.Fields().ByName("provider_tracking")
}

var _ protoreflect.Message = (*fastReflection_InflightFund)(nil)

type fastReflection_InflightFund InflightFund

func (x *InflightFund) ProtoReflect() protoreflect.Message {
	return (*fastReflection_InflightFund)(x)
}

func (x *InflightFund) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_InflightFund_messageType fastReflection_InflightFund_messageType
var _ protoreflect.MessageType = fastReflection_InflightFund_messageType{}

type fastReflection_InflightFund_messageType struct{}

func (x fastReflection_InflightFund_messageType) Zero() protoreflect.Message {
	return (*fastReflection_InflightFund)(nil)
}
func (x fastReflection_InflightFund_messageType) New() protoreflect.Message {
	return new(fastReflection_InflightFund)
}
func (x fastReflection_InflightFund_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_InflightFund
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_InflightFund) Descriptor() protoreflect.MessageDescriptor {
	return md_InflightFund
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_InflightFund) Type() protoreflect.MessageType {
	return _fastReflection_InflightFund_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_InflightFund) New() protoreflect.Message {
	return new(fastReflection_InflightFund)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_InflightFund) Interface() protoreflect.ProtoMessage {
	return (*InflightFund)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_InflightFund) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_InflightFund_id, value) {
			return
		}
	}
	if x.TransactionId != "" {
		value := protoreflect.ValueOfString(x.TransactionId)
		if !f(fd_InflightFund_transaction_id, value) {
			return
		}
	}
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_InflightFund_amount, value) {
			return
		}
	}
	if x.Origin != nil {
		switch o := x.Origin.(type) {
		case *InflightFund_NobleOrigin:
			v := o.NobleOrigin
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_InflightFund_noble_origin, value) {
				return
			}
		case *InflightFund_RemoteOrigin:
			v := o.RemoteOrigin
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_InflightFund_remote_origin, value) {
				return
			}
		}
	}
	if x.Destination != nil {
		switch o := x.Destination.(type) {
		case *InflightFund_NobleDestination:
			v := o.NobleDestination
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_InflightFund_noble_destination, value) {
				return
			}
		case *InflightFund_RemoteDestination:
			v := o.RemoteDestination
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_InflightFund_remote_destination, value) {
				return
			}
		}
	}
	if x.InitiatedAt != nil {
		value := protoreflect.ValueOfMessage(x.InitiatedAt.ProtoReflect())
		if !f(fd_InflightFund_initiated_at, value) {
			return
		}
	}
	if x.ExpectedAt != nil {
		value := protoreflect.ValueOfMessage(x.ExpectedAt.ProtoReflect())
		if !f(fd_InflightFund_expected_at, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_InflightFund_status, value) {
			return
		}
	}
	if x.ValueAtInitiation != "" {
		value := protoreflect.ValueOfString(x.ValueAtInitiation)
		if !f(fd_InflightFund_value_at_initiation, value) {
			return
		}
	}
	if x.ProviderTracking != nil {
		value := protoreflect.ValueOfMessage(x.ProviderTracking.ProtoReflect())
		if !f(fd_InflightFund_provider_tracking, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_InflightFund) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.InflightFund.id":
		return x.Id != uint64(0)
	case "noble.dollar.vaults.v2.InflightFund.transaction_id":
		return x.TransactionId != ""
	case "noble.dollar.vaults.v2.InflightFund.amount":
		return x.Amount != ""
	case "noble.dollar.vaults.v2.InflightFund.noble_origin":
		if x.Origin == nil {
			return false
		} else if _, ok := x.Origin.(*InflightFund_NobleOrigin); ok {
			return true
		} else {
			return false
		}
	case "noble.dollar.vaults.v2.InflightFund.remote_origin":
		if x.Origin == nil {
			return false
		} else if _, ok := x.Origin.(*InflightFund_RemoteOrigin); ok {
			return true
		} else {
			return false
		}
	case "noble.dollar.vaults.v2.InflightFund.noble_destination":
		if x.Destination == nil {
			return false
		} else if _, ok := x.Destination.(*InflightFund_NobleDestination); ok {
			return true
		} else {
			return false
		}
	case "noble.dollar.vaults.v2.InflightFund.remote_destination":
		if x.Destination == nil {
			return false
		} else if _, ok := x.Destination.(*InflightFund_RemoteDestination); ok {
			return true
		} else {
			return false
		}
	case "noble.dollar.vaults.v2.InflightFund.initiated_at":
		return x.InitiatedAt != nil
	case "noble.dollar.vaults.v2.InflightFund.expected_at":
		return x.ExpectedAt != nil
	case "noble.dollar.vaults.v2.InflightFund.status":
		return x.Status != 0
	case "noble.dollar.vaults.v2.InflightFund.value_at_initiation":
		return x.ValueAtInitiation != ""
	case "noble.dollar.vaults.v2.InflightFund.provider_tracking":
		return x.ProviderTracking != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.InflightFund"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.InflightFund does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InflightFund) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.InflightFund.id":
		x.Id = uint64(0)
	case "noble.dollar.vaults.v2.InflightFund.transaction_id":
		x.TransactionId = ""
	case "noble.dollar.vaults.v2.InflightFund.amount":
		x.Amount = ""
	case "noble.dollar.vaults.v2.InflightFund.noble_origin":
		x.Origin = nil
	case "noble.dollar.vaults.v2.InflightFund.remote_origin":
		x.Origin = nil
	case "noble.dollar.vaults.v2.InflightFund.noble_destination":
		x.Destination = nil
	case "noble.dollar.vaults.v2.InflightFund.remote_destination":
		x.Destination = nil
	case "noble.dollar.vaults.v2.InflightFund.initiated_at":
		x.InitiatedAt = nil
	case "noble.dollar.vaults.v2.InflightFund.expected_at":
		x.ExpectedAt = nil
	case "noble.dollar.vaults.v2.InflightFund.status":
		x.Status = 0
	case "noble.dollar.vaults.v2.InflightFund.value_at_initiation":
		x.ValueAtInitiation = ""
	case "noble.dollar.vaults.v2.InflightFund.provider_tracking":
		x.ProviderTracking = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.InflightFund"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.InflightFund does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_InflightFund) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.InflightFund.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v2.InflightFund.transaction_id":
		value := x.TransactionId
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.InflightFund.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.InflightFund.noble_origin":
		if x.Origin == nil {
			return protoreflect.ValueOfMessage((*NobleEndpoint)(nil).ProtoReflect())
		} else if v, ok := x.Origin.(*InflightFund_NobleOrigin); ok {
			return protoreflect.ValueOfMessage(v.NobleOrigin.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*NobleEndpoint)(nil).ProtoReflect())
		}
	case "noble.dollar.vaults.v2.InflightFund.remote_origin":
		if x.Origin == nil {
			return protoreflect.ValueOfMessage((*RemotePosition)(nil).ProtoReflect())
		} else if v, ok := x.Origin.(*InflightFund_RemoteOrigin); ok {
			return protoreflect.ValueOfMessage(v.RemoteOrigin.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*RemotePosition)(nil).ProtoReflect())
		}
	case "noble.dollar.vaults.v2.InflightFund.noble_destination":
		if x.Destination == nil {
			return protoreflect.ValueOfMessage((*NobleEndpoint)(nil).ProtoReflect())
		} else if v, ok := x.Destination.(*InflightFund_NobleDestination); ok {
			return protoreflect.ValueOfMessage(v.NobleDestination.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*NobleEndpoint)(nil).ProtoReflect())
		}
	case "noble.dollar.vaults.v2.InflightFund.remote_destination":
		if x.Destination == nil {
			return protoreflect.ValueOfMessage((*RemotePosition)(nil).ProtoReflect())
		} else if v, ok := x.Destination.(*InflightFund_RemoteDestination); ok {
			return protoreflect.ValueOfMessage(v.RemoteDestination.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*RemotePosition)(nil).ProtoReflect())
		}
	case "noble.dollar.vaults.v2.InflightFund.initiated_at":
		value := x.InitiatedAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.expected_at":
		value := x.ExpectedAt
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "noble.dollar.vaults.v2.InflightFund.value_at_initiation":
		value := x.ValueAtInitiation
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.InflightFund.provider_tracking":
		value := x.ProviderTracking
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.InflightFund"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.InflightFund does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InflightFund) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.InflightFund.id":
		x.Id = value.Uint()
	case "noble.dollar.vaults.v2.InflightFund.transaction_id":
		x.TransactionId = value.Interface().(string)
	case "noble.dollar.vaults.v2.InflightFund.amount":
		x.Amount = value.Interface().(string)
	case "noble.dollar.vaults.v2.InflightFund.noble_origin":
		cv := value.Message().Interface().(*NobleEndpoint)
		x.Origin = &InflightFund_NobleOrigin{NobleOrigin: cv}
	case "noble.dollar.vaults.v2.InflightFund.remote_origin":
		cv := value.Message().Interface().(*RemotePosition)
		x.Origin = &InflightFund_RemoteOrigin{RemoteOrigin: cv}
	case "noble.dollar.vaults.v2.InflightFund.noble_destination":
		cv := value.Message().Interface().(*NobleEndpoint)
		x.Destination = &InflightFund_NobleDestination{NobleDestination: cv}
	case "noble.dollar.vaults.v2.InflightFund.remote_destination":
		cv := value.Message().Interface().(*RemotePosition)
		x.Destination = &InflightFund_RemoteDestination{RemoteDestination: cv}
	case "noble.dollar.vaults.v2.InflightFund.initiated_at":
		x.InitiatedAt = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.InflightFund.expected_at":
		x.ExpectedAt = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.InflightFund.status":
		x.Status = (InflightStatus)(value.Enum())
	case "noble.dollar.vaults.v2.InflightFund.value_at_initiation":
		x.ValueAtInitiation = value.Interface().(string)
	case "noble.dollar.vaults.v2.InflightFund.provider_tracking":
		x.ProviderTracking = value.Message().Interface().(*ProviderTrackingInfo)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.InflightFund"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.InflightFund does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InflightFund) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.InflightFund.noble_origin":
		if x.Origin == nil {
			value := &NobleEndpoint{}
			oneofValue := &InflightFund_NobleOrigin{NobleOrigin: value}
			x.Origin = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Origin.(type) {
		case *InflightFund_NobleOrigin:
			return protoreflect.ValueOfMessage(m.NobleOrigin.ProtoReflect())
		default:
			value := &NobleEndpoint{}
			oneofValue := &InflightFund_NobleOrigin{NobleOrigin: value}
			x.Origin = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	case "noble.dollar.vaults.v2.InflightFund.remote_origin":
		if x.Origin == nil {
			value := &RemotePosition{}
			oneofValue := &InflightFund_RemoteOrigin{RemoteOrigin: value}
			x.Origin = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Origin.(type) {
		case *InflightFund_RemoteOrigin:
			return protoreflect.ValueOfMessage(m.RemoteOrigin.ProtoReflect())
		default:
			value := &RemotePosition{}
			oneofValue := &InflightFund_RemoteOrigin{RemoteOrigin: value}
			x.Origin = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	case "noble.dollar.vaults.v2.InflightFund.noble_destination":
		if x.Destination == nil {
			value := &NobleEndpoint{}
			oneofValue := &InflightFund_NobleDestination{NobleDestination: value}
			x.Destination = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Destination.(type) {
		case *InflightFund_NobleDestination:
			return protoreflect.ValueOfMessage(m.NobleDestination.ProtoReflect())
		default:
			value := &NobleEndpoint{}
			oneofValue := &InflightFund_NobleDestination{NobleDestination: value}
			x.Destination = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	case "noble.dollar.vaults.v2.InflightFund.remote_destination":
		if x.Destination == nil {
			value := &RemotePosition{}
			oneofValue := &InflightFund_RemoteDestination{RemoteDestination: value}
			x.Destination = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.Destination.(type) {
		case *InflightFund_RemoteDestination:
			return protoreflect.ValueOfMessage(m.RemoteDestination.ProtoReflect())
		default:
			value := &RemotePosition{}
			oneofValue := &InflightFund_RemoteDestination{RemoteDestination: value}
			x.Destination = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	case "noble.dollar.vaults.v2.InflightFund.initiated_at":
		if x.InitiatedAt == nil {
			x.InitiatedAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.InitiatedAt.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.expected_at":
		if x.ExpectedAt == nil {
			x.ExpectedAt = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.ExpectedAt.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.provider_tracking":
		if x.ProviderTracking == nil {
			x.ProviderTracking = new(ProviderTrackingInfo)
		}
		return protoreflect.ValueOfMessage(x.ProviderTracking.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.id":
		panic(fmt.Errorf("field id of message noble.dollar.vaults.v2.InflightFund is not mutable"))
	case "noble.dollar.vaults.v2.InflightFund.transaction_id":
		panic(fmt.Errorf("field transaction_id of message noble.dollar.vaults.v2.InflightFund is not mutable"))
	case "noble.dollar.vaults.v2.InflightFund.amount":
		panic(fmt.Errorf("field amount of message noble.dollar.vaults.v2.InflightFund is not mutable"))
	case "noble.dollar.vaults.v2.InflightFund.status":
		panic(fmt.Errorf("field status of message noble.dollar.vaults.v2.InflightFund is not mutable"))
	case "noble.dollar.vaults.v2.InflightFund.value_at_initiation":
		panic(fmt.Errorf("field value_at_initiation of message noble.dollar.vaults.v2.InflightFund is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.InflightFund"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.InflightFund does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_InflightFund) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.InflightFund.id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v2.InflightFund.transaction_id":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.InflightFund.amount":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.InflightFund.noble_origin":
		value := &NobleEndpoint{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.remote_origin":
		value := &RemotePosition{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.noble_destination":
		value := &NobleEndpoint{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.remote_destination":
		value := &RemotePosition{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.initiated_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.expected_at":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.InflightFund.status":
		return protoreflect.ValueOfEnum(0)
	case "noble.dollar.vaults.v2.InflightFund.value_at_initiation":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.InflightFund.provider_tracking":
		m := new(ProviderTrackingInfo)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.InflightFund"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.InflightFund does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_InflightFund) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	case "noble.dollar.vaults.v2.InflightFund.origin":
		if x.Origin == nil {
			return nil
		}
		switch x.Origin.(type) {
		case *InflightFund_NobleOrigin:
			return x.Descriptor().Fields().ByName("noble_origin")
		case *InflightFund_RemoteOrigin:
			return x.Descriptor().Fields().ByName("remote_origin")
		}
	case "noble.dollar.vaults.v2.InflightFund.destination":
		if x.Destination == nil {
			return nil
		}
		switch x.Destination.(type) {
		case *InflightFund_NobleDestination:
			return x.Descriptor().Fields().ByName("noble_destination")
		case *InflightFund_RemoteDestination:
			return x.Descriptor().Fields().ByName("remote_destination")
		}
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.InflightFund", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_InflightFund) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_InflightFund) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_InflightFund) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_InflightFund) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*InflightFund)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		l = len(x.TransactionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		switch x := x.Origin.(type) {
		case *InflightFund_NobleOrigin:
			if x == nil {
				break
			}
			l = options.Size(x.NobleOrigin)
			n += 1 + l + runtime.Sov(uint64(l))
		case *InflightFund_RemoteOrigin:
			if x == nil {
				break
			}
			l = options.Size(x.RemoteOrigin)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		switch x := x.Destination.(type) {
		case *InflightFund_NobleDestination:
			if x == nil {
				break
			}
			l = options.Size(x.NobleDestination)
			n += 1 + l + runtime.Sov(uint64(l))
		case *InflightFund_RemoteDestination:
			if x == nil {
				break
			}
			l = options.Size(x.RemoteDestination)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.InitiatedAt != nil {
			l = options.Size(x.InitiatedAt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ExpectedAt != nil {
			l = options.Size(x.ExpectedAt)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		l = len(x.ValueAtInitiation)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ProviderTracking != nil {
			l = options.Size(x.ProviderTracking)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*InflightFund)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		switch x := x.Destination.(type) {
		case *InflightFund_NobleDestination:
			encoded, err := options.Marshal(x.NobleDestination)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		case *InflightFund_RemoteDestination:
			encoded, err := options.Marshal(x.RemoteDestination)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		switch x := x.Origin.(type) {
		case *InflightFund_NobleOrigin:
			encoded, err := options.Marshal(x.NobleOrigin)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		case *InflightFund_RemoteOrigin:
			encoded, err := options.Marshal(x.RemoteOrigin)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if x.ProviderTracking != nil {
			encoded, err := options.Marshal(x.ProviderTracking)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.ValueAtInitiation) > 0 {
			i -= len(x.ValueAtInitiation)
			copy(dAtA[i:], x.ValueAtInitiation)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ValueAtInitiation)))
			i--
			dAtA[i] = 0x5a
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x50
		}
		if x.ExpectedAt != nil {
			encoded, err := options.Marshal(x.ExpectedAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x4a
		}
		if x.InitiatedAt != nil {
			encoded, err := options.Marshal(x.InitiatedAt)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.TransactionId) > 0 {
			i -= len(x.TransactionId)
			copy(dAtA[i:], x.TransactionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TransactionId)))
			i--
			dAtA[i] = 0x12
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*InflightFund)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: InflightFund: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: InflightFund: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TransactionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NobleOrigin", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &NobleEndpoint{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Origin = &InflightFund_NobleOrigin{v}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RemoteOrigin", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &RemotePosition{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Origin = &InflightFund_RemoteOrigin{v}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NobleDestination", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &NobleEndpoint{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Destination = &InflightFund_NobleDestination{v}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RemoteDestination", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &RemotePosition{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.Destination = &InflightFund_RemoteDestination{v}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.InitiatedAt == nil {
					x.InitiatedAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.InitiatedAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExpectedAt", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ExpectedAt == nil {
					x.ExpectedAt = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ExpectedAt); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= InflightStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ValueAtInitiation", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ValueAtInitiation = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ProviderTracking", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ProviderTracking == nil {
					x.ProviderTracking = &ProviderTrackingInfo{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ProviderTracking); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_NobleEndpoint                protoreflect.MessageDescriptor
	fd_NobleEndpoint_operation_type protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_NobleEndpoint = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("NobleEndpoint")
	fd_NobleEndpoint_operation_type = md_NobleEndpoint.Fields().ByName("operation_type")
}

var _ protoreflect.Message = (*fastReflection_NobleEndpoint)(nil)

type fastReflection_NobleEndpoint NobleEndpoint

func (x *NobleEndpoint) ProtoReflect() protoreflect.Message {
	return (*fastReflection_NobleEndpoint)(x)
}

func (x *NobleEndpoint) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_NobleEndpoint_messageType fastReflection_NobleEndpoint_messageType
var _ protoreflect.MessageType = fastReflection_NobleEndpoint_messageType{}

type fastReflection_NobleEndpoint_messageType struct{}

func (x fastReflection_NobleEndpoint_messageType) Zero() protoreflect.Message {
	return (*fastReflection_NobleEndpoint)(nil)
}
func (x fastReflection_NobleEndpoint_messageType) New() protoreflect.Message {
	return new(fastReflection_NobleEndpoint)
}
func (x fastReflection_NobleEndpoint_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_NobleEndpoint
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_NobleEndpoint) Descriptor() protoreflect.MessageDescriptor {
	return md_NobleEndpoint
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_NobleEndpoint) Type() protoreflect.MessageType {
	return _fastReflection_NobleEndpoint_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_NobleEndpoint) New() protoreflect.Message {
	return new(fastReflection_NobleEndpoint)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_NobleEndpoint) Interface() protoreflect.ProtoMessage {
	return (*NobleEndpoint)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_NobleEndpoint) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.OperationType != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.OperationType))
		if !f(fd_NobleEndpoint_operation_type, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_NobleEndpoint) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NobleEndpoint.operation_type":
		return x.OperationType != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NobleEndpoint"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NobleEndpoint does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NobleEndpoint) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NobleEndpoint.operation_type":
		x.OperationType = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NobleEndpoint"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NobleEndpoint does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_NobleEndpoint) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.NobleEndpoint.operation_type":
		value := x.OperationType
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NobleEndpoint"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NobleEndpoint does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NobleEndpoint) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NobleEndpoint.operation_type":
		x.OperationType = (OperationType)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NobleEndpoint"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NobleEndpoint does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NobleEndpoint) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NobleEndpoint.operation_type":
		panic(fmt.Errorf("field operation_type of message noble.dollar.vaults.v2.NobleEndpoint is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NobleEndpoint"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NobleEndpoint does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_NobleEndpoint) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NobleEndpoint.operation_type":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NobleEndpoint"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NobleEndpoint does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_NobleEndpoint) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.NobleEndpoint", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_NobleEndpoint) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NobleEndpoint) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_NobleEndpoint) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_NobleEndpoint) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*NobleEndpoint)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.OperationType != 0 {
			n += 1 + runtime.Sov(uint64(x.OperationType))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*NobleEndpoint)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.OperationType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.OperationType))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*NobleEndpoint)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: NobleEndpoint: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: NobleEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
				}
				x.OperationType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.OperationType |= OperationType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ProviderTrackingInfo                    protoreflect.MessageDescriptor
	fd_ProviderTrackingInfo_hyperlane_tracking protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_ProviderTrackingInfo = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("ProviderTrackingInfo")
	fd_ProviderTrackingInfo_hyperlane_tracking = md_ProviderTrackingInfo.Fields().ByName("hyperlane_tracking")
}

var _ protoreflect.Message = (*fastReflection_ProviderTrackingInfo)(nil)

type fastReflection_ProviderTrackingInfo ProviderTrackingInfo

func (x *ProviderTrackingInfo) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ProviderTrackingInfo)(x)
}

func (x *ProviderTrackingInfo) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ProviderTrackingInfo_messageType fastReflection_ProviderTrackingInfo_messageType
var _ protoreflect.MessageType = fastReflection_ProviderTrackingInfo_messageType{}

type fastReflection_ProviderTrackingInfo_messageType struct{}

func (x fastReflection_ProviderTrackingInfo_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ProviderTrackingInfo)(nil)
}
func (x fastReflection_ProviderTrackingInfo_messageType) New() protoreflect.Message {
	return new(fastReflection_ProviderTrackingInfo)
}
func (x fastReflection_ProviderTrackingInfo_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ProviderTrackingInfo
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ProviderTrackingInfo) Descriptor() protoreflect.MessageDescriptor {
	return md_ProviderTrackingInfo
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ProviderTrackingInfo) Type() protoreflect.MessageType {
	return _fastReflection_ProviderTrackingInfo_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ProviderTrackingInfo) New() protoreflect.Message {
	return new(fastReflection_ProviderTrackingInfo)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ProviderTrackingInfo) Interface() protoreflect.ProtoMessage {
	return (*ProviderTrackingInfo)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ProviderTrackingInfo) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TrackingInfo != nil {
		switch o := x.TrackingInfo.(type) {
		case *ProviderTrackingInfo_HyperlaneTracking:
			v := o.HyperlaneTracking
			value := protoreflect.ValueOfMessage(v.ProtoReflect())
			if !f(fd_ProviderTrackingInfo_hyperlane_tracking, value) {
				return
			}
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ProviderTrackingInfo) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.ProviderTrackingInfo.hyperlane_tracking":
		if x.TrackingInfo == nil {
			return false
		} else if _, ok := x.TrackingInfo.(*ProviderTrackingInfo_HyperlaneTracking); ok {
			return true
		} else {
			return false
		}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.ProviderTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.ProviderTrackingInfo does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ProviderTrackingInfo) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.ProviderTrackingInfo.hyperlane_tracking":
		x.TrackingInfo = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.ProviderTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.ProviderTrackingInfo does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ProviderTrackingInfo) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.ProviderTrackingInfo.hyperlane_tracking":
		if x.TrackingInfo == nil {
			return protoreflect.ValueOfMessage((*HyperlaneTrackingInfo)(nil).ProtoReflect())
		} else if v, ok := x.TrackingInfo.(*ProviderTrackingInfo_HyperlaneTracking); ok {
			return protoreflect.ValueOfMessage(v.HyperlaneTracking.ProtoReflect())
		} else {
			return protoreflect.ValueOfMessage((*HyperlaneTrackingInfo)(nil).ProtoReflect())
		}
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.ProviderTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.ProviderTrackingInfo does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ProviderTrackingInfo) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.ProviderTrackingInfo.hyperlane_tracking":
		cv := value.Message().Interface().(*HyperlaneTrackingInfo)
		x.TrackingInfo = &ProviderTrackingInfo_HyperlaneTracking{HyperlaneTracking: cv}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.ProviderTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.ProviderTrackingInfo does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ProviderTrackingInfo) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.ProviderTrackingInfo.hyperlane_tracking":
		if x.TrackingInfo == nil {
			value := &HyperlaneTrackingInfo{}
			oneofValue := &ProviderTrackingInfo_HyperlaneTracking{HyperlaneTracking: value}
			x.TrackingInfo = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
		switch m := x.TrackingInfo.(type) {
		case *ProviderTrackingInfo_HyperlaneTracking:
			return protoreflect.ValueOfMessage(m.HyperlaneTracking.ProtoReflect())
		default:
			value := &HyperlaneTrackingInfo{}
			oneofValue := &ProviderTrackingInfo_HyperlaneTracking{HyperlaneTracking: value}
			x.TrackingInfo = oneofValue
			return protoreflect.ValueOfMessage(value.ProtoReflect())
		}
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.ProviderTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.ProviderTrackingInfo does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ProviderTrackingInfo) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.ProviderTrackingInfo.hyperlane_tracking":
		value := &HyperlaneTrackingInfo{}
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.ProviderTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.ProviderTrackingInfo does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ProviderTrackingInfo) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	case "noble.dollar.vaults.v2.ProviderTrackingInfo.tracking_info":
		if x.TrackingInfo == nil {
			return nil
		}
		switch x.TrackingInfo.(type) {
		case *ProviderTrackingInfo_HyperlaneTracking:
			return x.Descriptor().Fields().ByName("hyperlane_tracking")
		}
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.ProviderTrackingInfo", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ProviderTrackingInfo) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ProviderTrackingInfo) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ProviderTrackingInfo) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ProviderTrackingInfo) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ProviderTrackingInfo)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		switch x := x.TrackingInfo.(type) {
		case *ProviderTrackingInfo_HyperlaneTracking:
			if x == nil {
				break
			}
			l = options.Size(x.HyperlaneTracking)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ProviderTrackingInfo)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		switch x := x.TrackingInfo.(type) {
		case *ProviderTrackingInfo_HyperlaneTracking:
			encoded, err := options.Marshal(x.HyperlaneTracking)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ProviderTrackingInfo)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ProviderTrackingInfo: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ProviderTrackingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field HyperlaneTracking", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v := &HyperlaneTrackingInfo{}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], v); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				x.TrackingInfo = &ProviderTrackingInfo_HyperlaneTracking{v}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_HyperlaneTrackingInfo                     protoreflect.MessageDescriptor
	fd_HyperlaneTrackingInfo_message_id          protoreflect.FieldDescriptor
	fd_HyperlaneTrackingInfo_origin_domain       protoreflect.FieldDescriptor
	fd_HyperlaneTrackingInfo_destination_domain  protoreflect.FieldDescriptor
	fd_HyperlaneTrackingInfo_nonce               protoreflect.FieldDescriptor
	fd_HyperlaneTrackingInfo_origin_tx_hash      protoreflect.FieldDescriptor
	fd_HyperlaneTrackingInfo_destination_tx_hash protoreflect.FieldDescriptor
	fd_HyperlaneTrackingInfo_processed           protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_HyperlaneTrackingInfo = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("HyperlaneTrackingInfo")
	fd_HyperlaneTrackingInfo_message_id = md_HyperlaneTrackingInfo.Fields().ByName("message_id")
	fd_HyperlaneTrackingInfo_origin_domain = md_HyperlaneTrackingInfo.Fields().ByName("origin_domain")
	fd_HyperlaneTrackingInfo_destination_domain = md_HyperlaneTrackingInfo.Fields().ByName("destination_domain")
	fd_HyperlaneTrackingInfo_nonce = md_HyperlaneTrackingInfo.Fields().ByName("nonce")
	fd_HyperlaneTrackingInfo_origin_tx_hash = md_HyperlaneTrackingInfo.Fields().ByName("origin_tx_hash")
	fd_HyperlaneTrackingInfo_destination_tx_hash = md_HyperlaneTrackingInfo.Fields().ByName("destination_tx_hash")
	fd_HyperlaneTrackingInfo_processed = md_HyperlaneTrackingInfo.Fields().ByName("processed")
}

var _ protoreflect.Message = (*fastReflection_HyperlaneTrackingInfo)(nil)

type fastReflection_HyperlaneTrackingInfo HyperlaneTrackingInfo

func (x *HyperlaneTrackingInfo) ProtoReflect() protoreflect.Message {
	return (*fastReflection_HyperlaneTrackingInfo)(x)
}

func (x *HyperlaneTrackingInfo) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_HyperlaneTrackingInfo_messageType fastReflection_HyperlaneTrackingInfo_messageType
var _ protoreflect.MessageType = fastReflection_HyperlaneTrackingInfo_messageType{}

type fastReflection_HyperlaneTrackingInfo_messageType struct{}

func (x fastReflection_HyperlaneTrackingInfo_messageType) Zero() protoreflect.Message {
	return (*fastReflection_HyperlaneTrackingInfo)(nil)
}
func (x fastReflection_HyperlaneTrackingInfo_messageType) New() protoreflect.Message {
	return new(fastReflection_HyperlaneTrackingInfo)
}
func (x fastReflection_HyperlaneTrackingInfo_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_HyperlaneTrackingInfo
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_HyperlaneTrackingInfo) Descriptor() protoreflect.MessageDescriptor {
	return md_HyperlaneTrackingInfo
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_HyperlaneTrackingInfo) Type() protoreflect.MessageType {
	return _fastReflection_HyperlaneTrackingInfo_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_HyperlaneTrackingInfo) New() protoreflect.Message {
	return new(fastReflection_HyperlaneTrackingInfo)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_HyperlaneTrackingInfo) Interface() protoreflect.ProtoMessage {
	return (*HyperlaneTrackingInfo)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_HyperlaneTrackingInfo) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.MessageId) != 0 {
		value := protoreflect.ValueOfBytes(x.MessageId)
		if !f(fd_HyperlaneTrackingInfo_message_id, value) {
			return
		}
	}
	if x.OriginDomain != uint32(0) {
		value := protoreflect.ValueOfUint32(x.OriginDomain)
		if !f(fd_HyperlaneTrackingInfo_origin_domain, value) {
			return
		}
	}
	if x.DestinationDomain != uint32(0) {
		value := protoreflect.ValueOfUint32(x.DestinationDomain)
		if !f(fd_HyperlaneTrackingInfo_destination_domain, value) {
			return
		}
	}
	if x.Nonce != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Nonce)
		if !f(fd_HyperlaneTrackingInfo_nonce, value) {
			return
		}
	}
	if x.OriginTxHash != "" {
		value := protoreflect.ValueOfString(x.OriginTxHash)
		if !f(fd_HyperlaneTrackingInfo_origin_tx_hash, value) {
			return
		}
	}
	if x.DestinationTxHash != "" {
		value := protoreflect.ValueOfString(x.DestinationTxHash)
		if !f(fd_HyperlaneTrackingInfo_destination_tx_hash, value) {
			return
		}
	}
	if x.Processed != false {
		value := protoreflect.ValueOfBool(x.Processed)
		if !f(fd_HyperlaneTrackingInfo_processed, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_HyperlaneTrackingInfo) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.message_id":
		return len(x.MessageId) != 0
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_domain":
		return x.OriginDomain != uint32(0)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_domain":
		return x.DestinationDomain != uint32(0)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.nonce":
		return x.Nonce != uint64(0)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_tx_hash":
		return x.OriginTxHash != ""
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_tx_hash":
		return x.DestinationTxHash != ""
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.processed":
		return x.Processed != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.HyperlaneTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.HyperlaneTrackingInfo does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_HyperlaneTrackingInfo) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.message_id":
		x.MessageId = nil
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_domain":
		x.OriginDomain = uint32(0)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_domain":
		x.DestinationDomain = uint32(0)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.nonce":
		x.Nonce = uint64(0)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_tx_hash":
		x.OriginTxHash = ""
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_tx_hash":
		x.DestinationTxHash = ""
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.processed":
		x.Processed = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.HyperlaneTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.HyperlaneTrackingInfo does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_HyperlaneTrackingInfo) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.message_id":
		value := x.MessageId
		return protoreflect.ValueOfBytes(value)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_domain":
		value := x.OriginDomain
		return protoreflect.ValueOfUint32(value)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_domain":
		value := x.DestinationDomain
		return protoreflect.ValueOfUint32(value)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.nonce":
		value := x.Nonce
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_tx_hash":
		value := x.OriginTxHash
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_tx_hash":
		value := x.DestinationTxHash
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.processed":
		value := x.Processed
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.HyperlaneTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.HyperlaneTrackingInfo does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_HyperlaneTrackingInfo) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.message_id":
		x.MessageId = value.Bytes()
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_domain":
		x.OriginDomain = uint32(value.Uint())
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_domain":
		x.DestinationDomain = uint32(value.Uint())
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.nonce":
		x.Nonce = value.Uint()
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_tx_hash":
		x.OriginTxHash = value.Interface().(string)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_tx_hash":
		x.DestinationTxHash = value.Interface().(string)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.processed":
		x.Processed = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.HyperlaneTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.HyperlaneTrackingInfo does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_HyperlaneTrackingInfo) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.message_id":
		panic(fmt.Errorf("field message_id of message noble.dollar.vaults.v2.HyperlaneTrackingInfo is not mutable"))
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_domain":
		panic(fmt.Errorf("field origin_domain of message noble.dollar.vaults.v2.HyperlaneTrackingInfo is not mutable"))
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_domain":
		panic(fmt.Errorf("field destination_domain of message noble.dollar.vaults.v2.HyperlaneTrackingInfo is not mutable"))
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.nonce":
		panic(fmt.Errorf("field nonce of message noble.dollar.vaults.v2.HyperlaneTrackingInfo is not mutable"))
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_tx_hash":
		panic(fmt.Errorf("field origin_tx_hash of message noble.dollar.vaults.v2.HyperlaneTrackingInfo is not mutable"))
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_tx_hash":
		panic(fmt.Errorf("field destination_tx_hash of message noble.dollar.vaults.v2.HyperlaneTrackingInfo is not mutable"))
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.processed":
		panic(fmt.Errorf("field processed of message noble.dollar.vaults.v2.HyperlaneTrackingInfo is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.HyperlaneTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.HyperlaneTrackingInfo does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_HyperlaneTrackingInfo) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.message_id":
		return protoreflect.ValueOfBytes(nil)
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_domain":
		return protoreflect.ValueOfUint32(uint32(0))
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_domain":
		return protoreflect.ValueOfUint32(uint32(0))
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.nonce":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.origin_tx_hash":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.destination_tx_hash":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.HyperlaneTrackingInfo.processed":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.HyperlaneTrackingInfo"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.HyperlaneTrackingInfo does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_HyperlaneTrackingInfo) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.HyperlaneTrackingInfo", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_HyperlaneTrackingInfo) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_HyperlaneTrackingInfo) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_HyperlaneTrackingInfo) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_HyperlaneTrackingInfo) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*HyperlaneTrackingInfo)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.MessageId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.OriginDomain != 0 {
			n += 1 + runtime.Sov(uint64(x.OriginDomain))
		}
		if x.DestinationDomain != 0 {
			n += 1 + runtime.Sov(uint64(x.DestinationDomain))
		}
		if x.Nonce != 0 {
			n += 1 + runtime.Sov(uint64(x.Nonce))
		}
		l = len(x.OriginTxHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.DestinationTxHash)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Processed {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*HyperlaneTrackingInfo)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Processed {
			i--
			if x.Processed {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x38
		}
		if len(x.DestinationTxHash) > 0 {
			i -= len(x.DestinationTxHash)
			copy(dAtA[i:], x.DestinationTxHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DestinationTxHash)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.OriginTxHash) > 0 {
			i -= len(x.OriginTxHash)
			copy(dAtA[i:], x.OriginTxHash)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OriginTxHash)))
			i--
			dAtA[i] = 0x2a
		}
		if x.Nonce != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Nonce))
			i--
			dAtA[i] = 0x20
		}
		if x.DestinationDomain != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.DestinationDomain))
			i--
			dAtA[i] = 0x18
		}
		if x.OriginDomain != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.OriginDomain))
			i--
			dAtA[i] = 0x10
		}
		if len(x.MessageId) > 0 {
			i -= len(x.MessageId)
			copy(dAtA[i:], x.MessageId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MessageId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*HyperlaneTrackingInfo)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: HyperlaneTrackingInfo: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: HyperlaneTrackingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MessageId = append(x.MessageId[:0], dAtA[iNdEx:postIndex]...)
				if x.MessageId == nil {
					x.MessageId = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OriginDomain", wireType)
				}
				x.OriginDomain = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.OriginDomain |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
				}
				x.DestinationDomain = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.DestinationDomain |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				x.Nonce = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Nonce |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OriginTxHash", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OriginTxHash = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DestinationTxHash", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DestinationTxHash = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Processed", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Processed = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_NAVOracleUpdate              protoreflect.MessageDescriptor
	fd_NAVOracleUpdate_position_id  protoreflect.FieldDescriptor
	fd_NAVOracleUpdate_share_price  protoreflect.FieldDescriptor
	fd_NAVOracleUpdate_shares_held  protoreflect.FieldDescriptor
	fd_NAVOracleUpdate_timestamp    protoreflect.FieldDescriptor
	fd_NAVOracleUpdate_source_chain protoreflect.FieldDescriptor
	fd_NAVOracleUpdate_message_id   protoreflect.FieldDescriptor
	fd_NAVOracleUpdate_status       protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_NAVOracleUpdate = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("NAVOracleUpdate")
	fd_NAVOracleUpdate_position_id = md_NAVOracleUpdate.Fields().ByName("position_id")
	fd_NAVOracleUpdate_share_price = md_NAVOracleUpdate.Fields().ByName("share_price")
	fd_NAVOracleUpdate_shares_held = md_NAVOracleUpdate.Fields().ByName("shares_held")
	fd_NAVOracleUpdate_timestamp = md_NAVOracleUpdate.Fields().ByName("timestamp")
	fd_NAVOracleUpdate_source_chain = md_NAVOracleUpdate.Fields().ByName("source_chain")
	fd_NAVOracleUpdate_message_id = md_NAVOracleUpdate.Fields().ByName("message_id")
	fd_NAVOracleUpdate_status = md_NAVOracleUpdate.Fields().ByName("status")
}

var _ protoreflect.Message = (*fastReflection_NAVOracleUpdate)(nil)

type fastReflection_NAVOracleUpdate NAVOracleUpdate

func (x *NAVOracleUpdate) ProtoReflect() protoreflect.Message {
	return (*fastReflection_NAVOracleUpdate)(x)
}

func (x *NAVOracleUpdate) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_NAVOracleUpdate_messageType fastReflection_NAVOracleUpdate_messageType
var _ protoreflect.MessageType = fastReflection_NAVOracleUpdate_messageType{}

type fastReflection_NAVOracleUpdate_messageType struct{}

func (x fastReflection_NAVOracleUpdate_messageType) Zero() protoreflect.Message {
	return (*fastReflection_NAVOracleUpdate)(nil)
}
func (x fastReflection_NAVOracleUpdate_messageType) New() protoreflect.Message {
	return new(fastReflection_NAVOracleUpdate)
}
func (x fastReflection_NAVOracleUpdate_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_NAVOracleUpdate
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_NAVOracleUpdate) Descriptor() protoreflect.MessageDescriptor {
	return md_NAVOracleUpdate
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_NAVOracleUpdate) Type() protoreflect.MessageType {
	return _fastReflection_NAVOracleUpdate_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_NAVOracleUpdate) New() protoreflect.Message {
	return new(fastReflection_NAVOracleUpdate)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_NAVOracleUpdate) Interface() protoreflect.ProtoMessage {
	return (*NAVOracleUpdate)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_NAVOracleUpdate) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PositionId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PositionId)
		if !f(fd_NAVOracleUpdate_position_id, value) {
			return
		}
	}
	if x.SharePrice != "" {
		value := protoreflect.ValueOfString(x.SharePrice)
		if !f(fd_NAVOracleUpdate_share_price, value) {
			return
		}
	}
	if x.SharesHeld != "" {
		value := protoreflect.ValueOfString(x.SharesHeld)
		if !f(fd_NAVOracleUpdate_shares_held, value) {
			return
		}
	}
	if x.Timestamp != nil {
		value := protoreflect.ValueOfMessage(x.Timestamp.ProtoReflect())
		if !f(fd_NAVOracleUpdate_timestamp, value) {
			return
		}
	}
	if x.SourceChain != "" {
		value := protoreflect.ValueOfString(x.SourceChain)
		if !f(fd_NAVOracleUpdate_source_chain, value) {
			return
		}
	}
	if x.MessageId != "" {
		value := protoreflect.ValueOfString(x.MessageId)
		if !f(fd_NAVOracleUpdate_message_id, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_NAVOracleUpdate_status, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_NAVOracleUpdate) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NAVOracleUpdate.position_id":
		return x.PositionId != uint64(0)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.share_price":
		return x.SharePrice != ""
	case "noble.dollar.vaults.v2.NAVOracleUpdate.shares_held":
		return x.SharesHeld != ""
	case "noble.dollar.vaults.v2.NAVOracleUpdate.timestamp":
		return x.Timestamp != nil
	case "noble.dollar.vaults.v2.NAVOracleUpdate.source_chain":
		return x.SourceChain != ""
	case "noble.dollar.vaults.v2.NAVOracleUpdate.message_id":
		return x.MessageId != ""
	case "noble.dollar.vaults.v2.NAVOracleUpdate.status":
		return x.Status != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVOracleUpdate"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVOracleUpdate does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NAVOracleUpdate) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NAVOracleUpdate.position_id":
		x.PositionId = uint64(0)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.share_price":
		x.SharePrice = ""
	case "noble.dollar.vaults.v2.NAVOracleUpdate.shares_held":
		x.SharesHeld = ""
	case "noble.dollar.vaults.v2.NAVOracleUpdate.timestamp":
		x.Timestamp = nil
	case "noble.dollar.vaults.v2.NAVOracleUpdate.source_chain":
		x.SourceChain = ""
	case "noble.dollar.vaults.v2.NAVOracleUpdate.message_id":
		x.MessageId = ""
	case "noble.dollar.vaults.v2.NAVOracleUpdate.status":
		x.Status = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVOracleUpdate"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVOracleUpdate does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_NAVOracleUpdate) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.NAVOracleUpdate.position_id":
		value := x.PositionId
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.share_price":
		value := x.SharePrice
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.shares_held":
		value := x.SharesHeld
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.NAVOracleUpdate.source_chain":
		value := x.SourceChain
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.message_id":
		value := x.MessageId
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVOracleUpdate"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVOracleUpdate does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NAVOracleUpdate) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NAVOracleUpdate.position_id":
		x.PositionId = value.Uint()
	case "noble.dollar.vaults.v2.NAVOracleUpdate.share_price":
		x.SharePrice = value.Interface().(string)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.shares_held":
		x.SharesHeld = value.Interface().(string)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.timestamp":
		x.Timestamp = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.source_chain":
		x.SourceChain = value.Interface().(string)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.message_id":
		x.MessageId = value.Interface().(string)
	case "noble.dollar.vaults.v2.NAVOracleUpdate.status":
		x.Status = (OracleUpdateStatus)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVOracleUpdate"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVOracleUpdate does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NAVOracleUpdate) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NAVOracleUpdate.timestamp":
		if x.Timestamp == nil {
			x.Timestamp = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.Timestamp.ProtoReflect())
	case "noble.dollar.vaults.v2.NAVOracleUpdate.position_id":
		panic(fmt.Errorf("field position_id of message noble.dollar.vaults.v2.NAVOracleUpdate is not mutable"))
	case "noble.dollar.vaults.v2.NAVOracleUpdate.share_price":
		panic(fmt.Errorf("field share_price of message noble.dollar.vaults.v2.NAVOracleUpdate is not mutable"))
	case "noble.dollar.vaults.v2.NAVOracleUpdate.shares_held":
		panic(fmt.Errorf("field shares_held of message noble.dollar.vaults.v2.NAVOracleUpdate is not mutable"))
	case "noble.dollar.vaults.v2.NAVOracleUpdate.source_chain":
		panic(fmt.Errorf("field source_chain of message noble.dollar.vaults.v2.NAVOracleUpdate is not mutable"))
	case "noble.dollar.vaults.v2.NAVOracleUpdate.message_id":
		panic(fmt.Errorf("field message_id of message noble.dollar.vaults.v2.NAVOracleUpdate is not mutable"))
	case "noble.dollar.vaults.v2.NAVOracleUpdate.status":
		panic(fmt.Errorf("field status of message noble.dollar.vaults.v2.NAVOracleUpdate is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVOracleUpdate"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVOracleUpdate does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_NAVOracleUpdate) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.NAVOracleUpdate.position_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v2.NAVOracleUpdate.share_price":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.NAVOracleUpdate.shares_held":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.NAVOracleUpdate.timestamp":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.NAVOracleUpdate.source_chain":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.NAVOracleUpdate.message_id":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.NAVOracleUpdate.status":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.NAVOracleUpdate"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.NAVOracleUpdate does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_NAVOracleUpdate) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.NAVOracleUpdate", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_NAVOracleUpdate) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_NAVOracleUpdate) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_NAVOracleUpdate) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_NAVOracleUpdate) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*NAVOracleUpdate)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PositionId != 0 {
			n += 1 + runtime.Sov(uint64(x.PositionId))
		}
		l = len(x.SharePrice)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SharesHeld)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Timestamp != nil {
			l = options.Size(x.Timestamp)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SourceChain)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MessageId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*NAVOracleUpdate)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x38
		}
		if len(x.MessageId) > 0 {
			i -= len(x.MessageId)
			copy(dAtA[i:], x.MessageId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MessageId)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.SourceChain) > 0 {
			i -= len(x.SourceChain)
			copy(dAtA[i:], x.SourceChain)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SourceChain)))
			i--
			dAtA[i] = 0x2a
		}
		if x.Timestamp != nil {
			encoded, err := options.Marshal(x.Timestamp)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.SharesHeld) > 0 {
			i -= len(x.SharesHeld)
			copy(dAtA[i:], x.SharesHeld)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SharesHeld)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.SharePrice) > 0 {
			i -= len(x.SharePrice)
			copy(dAtA[i:], x.SharePrice)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SharePrice)))
			i--
			dAtA[i] = 0x12
		}
		if x.PositionId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PositionId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*NAVOracleUpdate)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: NAVOracleUpdate: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: NAVOracleUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
				}
				x.PositionId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PositionId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SharePrice = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SharesHeld", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SharesHeld = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Timestamp == nil {
					x.Timestamp = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Timestamp); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SourceChain = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MessageId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= OracleUpdateStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_PositionOracleConfig                   protoreflect.MessageDescriptor
	fd_PositionOracleConfig_position_id       protoreflect.FieldDescriptor
	fd_PositionOracleConfig_origin_identifier protoreflect.FieldDescriptor
	fd_PositionOracleConfig_max_staleness     protoreflect.FieldDescriptor
	fd_PositionOracleConfig_oracle_contract   protoreflect.FieldDescriptor
	fd_PositionOracleConfig_source_chain      protoreflect.FieldDescriptor
	fd_PositionOracleConfig_last_update       protoreflect.FieldDescriptor
	fd_PositionOracleConfig_provider_type     protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_PositionOracleConfig = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("PositionOracleConfig")
	fd_PositionOracleConfig_position_id = md_PositionOracleConfig.Fields().ByName("position_id")
	fd_PositionOracleConfig_origin_identifier = md_PositionOracleConfig.Fields().ByName("origin_identifier")
	fd_PositionOracleConfig_max_staleness = md_PositionOracleConfig.Fields().ByName("max_staleness")
	fd_PositionOracleConfig_oracle_contract = md_PositionOracleConfig.Fields().ByName("oracle_contract")
	fd_PositionOracleConfig_source_chain = md_PositionOracleConfig.Fields().ByName("source_chain")
	fd_PositionOracleConfig_last_update = md_PositionOracleConfig.Fields().ByName("last_update")
	fd_PositionOracleConfig_provider_type = md_PositionOracleConfig.Fields().ByName("provider_type")
}

var _ protoreflect.Message = (*fastReflection_PositionOracleConfig)(nil)

type fastReflection_PositionOracleConfig PositionOracleConfig

func (x *PositionOracleConfig) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PositionOracleConfig)(x)
}

func (x *PositionOracleConfig) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PositionOracleConfig_messageType fastReflection_PositionOracleConfig_messageType
var _ protoreflect.MessageType = fastReflection_PositionOracleConfig_messageType{}

type fastReflection_PositionOracleConfig_messageType struct{}

func (x fastReflection_PositionOracleConfig_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PositionOracleConfig)(nil)
}
func (x fastReflection_PositionOracleConfig_messageType) New() protoreflect.Message {
	return new(fastReflection_PositionOracleConfig)
}
func (x fastReflection_PositionOracleConfig_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PositionOracleConfig
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PositionOracleConfig) Descriptor() protoreflect.MessageDescriptor {
	return md_PositionOracleConfig
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PositionOracleConfig) Type() protoreflect.MessageType {
	return _fastReflection_PositionOracleConfig_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PositionOracleConfig) New() protoreflect.Message {
	return new(fastReflection_PositionOracleConfig)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PositionOracleConfig) Interface() protoreflect.ProtoMessage {
	return (*PositionOracleConfig)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PositionOracleConfig) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PositionId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PositionId)
		if !f(fd_PositionOracleConfig_position_id, value) {
			return
		}
	}
	if x.OriginIdentifier != "" {
		value := protoreflect.ValueOfString(x.OriginIdentifier)
		if !f(fd_PositionOracleConfig_origin_identifier, value) {
			return
		}
	}
	if x.MaxStaleness != int64(0) {
		value := protoreflect.ValueOfInt64(x.MaxStaleness)
		if !f(fd_PositionOracleConfig_max_staleness, value) {
			return
		}
	}
	if x.OracleContract != "" {
		value := protoreflect.ValueOfString(x.OracleContract)
		if !f(fd_PositionOracleConfig_oracle_contract, value) {
			return
		}
	}
	if x.SourceChain != "" {
		value := protoreflect.ValueOfString(x.SourceChain)
		if !f(fd_PositionOracleConfig_source_chain, value) {
			return
		}
	}
	if x.LastUpdate != nil {
		value := protoreflect.ValueOfMessage(x.LastUpdate.ProtoReflect())
		if !f(fd_PositionOracleConfig_last_update, value) {
			return
		}
	}
	if x.ProviderType != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.ProviderType))
		if !f(fd_PositionOracleConfig_provider_type, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PositionOracleConfig) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.PositionOracleConfig.position_id":
		return x.PositionId != uint64(0)
	case "noble.dollar.vaults.v2.PositionOracleConfig.origin_identifier":
		return x.OriginIdentifier != ""
	case "noble.dollar.vaults.v2.PositionOracleConfig.max_staleness":
		return x.MaxStaleness != int64(0)
	case "noble.dollar.vaults.v2.PositionOracleConfig.oracle_contract":
		return x.OracleContract != ""
	case "noble.dollar.vaults.v2.PositionOracleConfig.source_chain":
		return x.SourceChain != ""
	case "noble.dollar.vaults.v2.PositionOracleConfig.last_update":
		return x.LastUpdate != nil
	case "noble.dollar.vaults.v2.PositionOracleConfig.provider_type":
		return x.ProviderType != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.PositionOracleConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.PositionOracleConfig does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PositionOracleConfig) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.PositionOracleConfig.position_id":
		x.PositionId = uint64(0)
	case "noble.dollar.vaults.v2.PositionOracleConfig.origin_identifier":
		x.OriginIdentifier = ""
	case "noble.dollar.vaults.v2.PositionOracleConfig.max_staleness":
		x.MaxStaleness = int64(0)
	case "noble.dollar.vaults.v2.PositionOracleConfig.oracle_contract":
		x.OracleContract = ""
	case "noble.dollar.vaults.v2.PositionOracleConfig.source_chain":
		x.SourceChain = ""
	case "noble.dollar.vaults.v2.PositionOracleConfig.last_update":
		x.LastUpdate = nil
	case "noble.dollar.vaults.v2.PositionOracleConfig.provider_type":
		x.ProviderType = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.PositionOracleConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.PositionOracleConfig does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PositionOracleConfig) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.PositionOracleConfig.position_id":
		value := x.PositionId
		return protoreflect.ValueOfUint64(value)
	case "noble.dollar.vaults.v2.PositionOracleConfig.origin_identifier":
		value := x.OriginIdentifier
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.PositionOracleConfig.max_staleness":
		value := x.MaxStaleness
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.PositionOracleConfig.oracle_contract":
		value := x.OracleContract
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.PositionOracleConfig.source_chain":
		value := x.SourceChain
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.PositionOracleConfig.last_update":
		value := x.LastUpdate
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.PositionOracleConfig.provider_type":
		value := x.ProviderType
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.PositionOracleConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.PositionOracleConfig does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PositionOracleConfig) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.PositionOracleConfig.position_id":
		x.PositionId = value.Uint()
	case "noble.dollar.vaults.v2.PositionOracleConfig.origin_identifier":
		x.OriginIdentifier = value.Interface().(string)
	case "noble.dollar.vaults.v2.PositionOracleConfig.max_staleness":
		x.MaxStaleness = value.Int()
	case "noble.dollar.vaults.v2.PositionOracleConfig.oracle_contract":
		x.OracleContract = value.Interface().(string)
	case "noble.dollar.vaults.v2.PositionOracleConfig.source_chain":
		x.SourceChain = value.Interface().(string)
	case "noble.dollar.vaults.v2.PositionOracleConfig.last_update":
		x.LastUpdate = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.PositionOracleConfig.provider_type":
		x.ProviderType = (ProviderType)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.PositionOracleConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.PositionOracleConfig does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PositionOracleConfig) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.PositionOracleConfig.last_update":
		if x.LastUpdate == nil {
			x.LastUpdate = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.LastUpdate.ProtoReflect())
	case "noble.dollar.vaults.v2.PositionOracleConfig.position_id":
		panic(fmt.Errorf("field position_id of message noble.dollar.vaults.v2.PositionOracleConfig is not mutable"))
	case "noble.dollar.vaults.v2.PositionOracleConfig.origin_identifier":
		panic(fmt.Errorf("field origin_identifier of message noble.dollar.vaults.v2.PositionOracleConfig is not mutable"))
	case "noble.dollar.vaults.v2.PositionOracleConfig.max_staleness":
		panic(fmt.Errorf("field max_staleness of message noble.dollar.vaults.v2.PositionOracleConfig is not mutable"))
	case "noble.dollar.vaults.v2.PositionOracleConfig.oracle_contract":
		panic(fmt.Errorf("field oracle_contract of message noble.dollar.vaults.v2.PositionOracleConfig is not mutable"))
	case "noble.dollar.vaults.v2.PositionOracleConfig.source_chain":
		panic(fmt.Errorf("field source_chain of message noble.dollar.vaults.v2.PositionOracleConfig is not mutable"))
	case "noble.dollar.vaults.v2.PositionOracleConfig.provider_type":
		panic(fmt.Errorf("field provider_type of message noble.dollar.vaults.v2.PositionOracleConfig is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.PositionOracleConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.PositionOracleConfig does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PositionOracleConfig) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.PositionOracleConfig.position_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "noble.dollar.vaults.v2.PositionOracleConfig.origin_identifier":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.PositionOracleConfig.max_staleness":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.PositionOracleConfig.oracle_contract":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.PositionOracleConfig.source_chain":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.PositionOracleConfig.last_update":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.PositionOracleConfig.provider_type":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.PositionOracleConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.PositionOracleConfig does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PositionOracleConfig) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.PositionOracleConfig", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PositionOracleConfig) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PositionOracleConfig) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PositionOracleConfig) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PositionOracleConfig) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PositionOracleConfig)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PositionId != 0 {
			n += 1 + runtime.Sov(uint64(x.PositionId))
		}
		l = len(x.OriginIdentifier)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MaxStaleness != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxStaleness))
		}
		l = len(x.OracleContract)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SourceChain)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.LastUpdate != nil {
			l = options.Size(x.LastUpdate)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ProviderType != 0 {
			n += 1 + runtime.Sov(uint64(x.ProviderType))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PositionOracleConfig)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ProviderType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ProviderType))
			i--
			dAtA[i] = 0x38
		}
		if x.LastUpdate != nil {
			encoded, err := options.Marshal(x.LastUpdate)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.SourceChain) > 0 {
			i -= len(x.SourceChain)
			copy(dAtA[i:], x.SourceChain)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SourceChain)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.OracleContract) > 0 {
			i -= len(x.OracleContract)
			copy(dAtA[i:], x.OracleContract)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OracleContract)))
			i--
			dAtA[i] = 0x22
		}
		if x.MaxStaleness != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxStaleness))
			i--
			dAtA[i] = 0x18
		}
		if len(x.OriginIdentifier) > 0 {
			i -= len(x.OriginIdentifier)
			copy(dAtA[i:], x.OriginIdentifier)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OriginIdentifier)))
			i--
			dAtA[i] = 0x12
		}
		if x.PositionId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PositionId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PositionOracleConfig)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PositionOracleConfig: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PositionOracleConfig: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
				}
				x.PositionId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PositionId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OriginIdentifier", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OriginIdentifier = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxStaleness", wireType)
				}
				x.MaxStaleness = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxStaleness |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OracleContract", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OracleContract = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SourceChain = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.LastUpdate == nil {
					x.LastUpdate = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.LastUpdate); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ProviderType", wireType)
				}
				x.ProviderType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ProviderType |= ProviderType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.Map = (*_CrossChainPositionSnapshot_6_map)(nil)

type _CrossChainPositionSnapshot_6_map struct {
	m *map[uint32]string
}

func (x *_CrossChainPositionSnapshot_6_map) Len() int {
	if x.m == nil {
		return 0
	}
	return len(*x.m)
}

func (x *_CrossChainPositionSnapshot_6_map) Range(f func(protoreflect.MapKey, protoreflect.Value) bool) {
	if x.m == nil {
		return
	}
	for k, v := range *x.m {
		mapKey := (protoreflect.MapKey)(protoreflect.ValueOfUint32(k))
		mapValue := protoreflect.ValueOfString(v)
		if !f(mapKey, mapValue) {
			break
		}
	}
}

func (x *_CrossChainPositionSnapshot_6_map) Has(key protoreflect.MapKey) bool {
	if x.m == nil {
		return false
	}
	keyUnwrapped := key.Uint()
	concreteValue := (uint32)(keyUnwrapped)
	_, ok := (*x.m)[concreteValue]
	return ok
}

func (x *_CrossChainPositionSnapshot_6_map) Clear(key protoreflect.MapKey) {
	if x.m == nil {
		return
	}
	keyUnwrapped := key.Uint()
	concreteKey := (uint32)(keyUnwrapped)
	delete(*x.m, concreteKey)
}

func (x *_CrossChainPositionSnapshot_6_map) Get(key protoreflect.MapKey) protoreflect.Value {
	if x.m == nil {
		return protoreflect.Value{}
	}
	keyUnwrapped := key.Uint()
	concreteKey := (uint32)(keyUnwrapped)
	v, ok := (*x.m)[concreteKey]
	if !ok {
		return protoreflect.Value{}
	}
	return protoreflect.ValueOfString(v)
}

func (x *_CrossChainPositionSnapshot_6_map) Set(key protoreflect.MapKey, value protoreflect.Value) {
	if !key.IsValid() || !value.IsValid() {
		panic("invalid key or value provided")
	}
	keyUnwrapped := key.Uint()
	concreteKey := (uint32)(keyUnwrapped)
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.m)[concreteKey] = concreteValue
}

func (x *_CrossChainPositionSnapshot_6_map) Mutable(key protoreflect.MapKey) protoreflect.Value {
	panic("should not call Mutable on protoreflect.Map whose value is not of type protoreflect.Message")
}

func (x *_CrossChainPositionSnapshot_6_map) NewValue() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_CrossChainPositionSnapshot_6_map) IsValid() bool {
	return x.m != nil
}

var (
	md_CrossChainPositionSnapshot                      protoreflect.MessageDescriptor
	fd_CrossChainPositionSnapshot_total_remote_value   protoreflect.FieldDescriptor
	fd_CrossChainPositionSnapshot_total_inflight_value protoreflect.FieldDescriptor
	fd_CrossChainPositionSnapshot_active_positions     protoreflect.FieldDescriptor
	fd_CrossChainPositionSnapshot_stale_positions      protoreflect.FieldDescriptor
	fd_CrossChainPositionSnapshot_block_height         protoreflect.FieldDescriptor
	fd_CrossChainPositionSnapshot_value_by_route       protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_CrossChainPositionSnapshot = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("CrossChainPositionSnapshot")
	fd_CrossChainPositionSnapshot_total_remote_value = md_CrossChainPositionSnapshot.Fields().ByName("total_remote_value")
	fd_CrossChainPositionSnapshot_total_inflight_value = md_CrossChainPositionSnapshot.Fields().ByName("total_inflight_value")
	fd_CrossChainPositionSnapshot_active_positions = md_CrossChainPositionSnapshot.Fields().ByName("active_positions")
	fd_CrossChainPositionSnapshot_stale_positions = md_CrossChainPositionSnapshot.Fields().ByName("stale_positions")
	fd_CrossChainPositionSnapshot_block_height = md_CrossChainPositionSnapshot.Fields().ByName("block_height")
	fd_CrossChainPositionSnapshot_value_by_route = md_CrossChainPositionSnapshot.Fields().ByName("value_by_route")
}

var _ protoreflect.Message = (*fastReflection_CrossChainPositionSnapshot)(nil)

type fastReflection_CrossChainPositionSnapshot CrossChainPositionSnapshot

func (x *CrossChainPositionSnapshot) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CrossChainPositionSnapshot)(x)
}

func (x *CrossChainPositionSnapshot) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CrossChainPositionSnapshot_messageType fastReflection_CrossChainPositionSnapshot_messageType
var _ protoreflect.MessageType = fastReflection_CrossChainPositionSnapshot_messageType{}

type fastReflection_CrossChainPositionSnapshot_messageType struct{}

func (x fastReflection_CrossChainPositionSnapshot_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CrossChainPositionSnapshot)(nil)
}
func (x fastReflection_CrossChainPositionSnapshot_messageType) New() protoreflect.Message {
	return new(fastReflection_CrossChainPositionSnapshot)
}
func (x fastReflection_CrossChainPositionSnapshot_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CrossChainPositionSnapshot
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CrossChainPositionSnapshot) Descriptor() protoreflect.MessageDescriptor {
	return md_CrossChainPositionSnapshot
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CrossChainPositionSnapshot) Type() protoreflect.MessageType {
	return _fastReflection_CrossChainPositionSnapshot_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CrossChainPositionSnapshot) New() protoreflect.Message {
	return new(fastReflection_CrossChainPositionSnapshot)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CrossChainPositionSnapshot) Interface() protoreflect.ProtoMessage {
	return (*CrossChainPositionSnapshot)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CrossChainPositionSnapshot) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TotalRemoteValue != "" {
		value := protoreflect.ValueOfString(x.TotalRemoteValue)
		if !f(fd_CrossChainPositionSnapshot_total_remote_value, value) {
			return
		}
	}
	if x.TotalInflightValue != "" {
		value := protoreflect.ValueOfString(x.TotalInflightValue)
		if !f(fd_CrossChainPositionSnapshot_total_inflight_value, value) {
			return
		}
	}
	if x.ActivePositions != int64(0) {
		value := protoreflect.ValueOfInt64(x.ActivePositions)
		if !f(fd_CrossChainPositionSnapshot_active_positions, value) {
			return
		}
	}
	if x.StalePositions != int64(0) {
		value := protoreflect.ValueOfInt64(x.StalePositions)
		if !f(fd_CrossChainPositionSnapshot_stale_positions, value) {
			return
		}
	}
	if x.BlockHeight != int64(0) {
		value := protoreflect.ValueOfInt64(x.BlockHeight)
		if !f(fd_CrossChainPositionSnapshot_block_height, value) {
			return
		}
	}
	if len(x.ValueByRoute) != 0 {
		value := protoreflect.ValueOfMap(&_CrossChainPositionSnapshot_6_map{m: &x.ValueByRoute})
		if !f(fd_CrossChainPositionSnapshot_value_by_route, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CrossChainPositionSnapshot) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_remote_value":
		return x.TotalRemoteValue != ""
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_inflight_value":
		return x.TotalInflightValue != ""
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.active_positions":
		return x.ActivePositions != int64(0)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.stale_positions":
		return x.StalePositions != int64(0)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.block_height":
		return x.BlockHeight != int64(0)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.value_by_route":
		return len(x.ValueByRoute) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainPositionSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainPositionSnapshot does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainPositionSnapshot) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_remote_value":
		x.TotalRemoteValue = ""
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_inflight_value":
		x.TotalInflightValue = ""
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.active_positions":
		x.ActivePositions = int64(0)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.stale_positions":
		x.StalePositions = int64(0)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.block_height":
		x.BlockHeight = int64(0)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.value_by_route":
		x.ValueByRoute = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainPositionSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainPositionSnapshot does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CrossChainPositionSnapshot) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_remote_value":
		value := x.TotalRemoteValue
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_inflight_value":
		value := x.TotalInflightValue
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.active_positions":
		value := x.ActivePositions
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.stale_positions":
		value := x.StalePositions
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.block_height":
		value := x.BlockHeight
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.value_by_route":
		if len(x.ValueByRoute) == 0 {
			return protoreflect.ValueOfMap(&_CrossChainPositionSnapshot_6_map{})
		}
		mapValue := &_CrossChainPositionSnapshot_6_map{m: &x.ValueByRoute}
		return protoreflect.ValueOfMap(mapValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainPositionSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainPositionSnapshot does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainPositionSnapshot) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_remote_value":
		x.TotalRemoteValue = value.Interface().(string)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_inflight_value":
		x.TotalInflightValue = value.Interface().(string)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.active_positions":
		x.ActivePositions = value.Int()
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.stale_positions":
		x.StalePositions = value.Int()
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.block_height":
		x.BlockHeight = value.Int()
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.value_by_route":
		mv := value.Map()
		cmv := mv.(*_CrossChainPositionSnapshot_6_map)
		x.ValueByRoute = *cmv.m
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainPositionSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainPositionSnapshot does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainPositionSnapshot) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.value_by_route":
		if x.ValueByRoute == nil {
			x.ValueByRoute = make(map[uint32]string)
		}
		value := &_CrossChainPositionSnapshot_6_map{m: &x.ValueByRoute}
		return protoreflect.ValueOfMap(value)
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_remote_value":
		panic(fmt.Errorf("field total_remote_value of message noble.dollar.vaults.v2.CrossChainPositionSnapshot is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_inflight_value":
		panic(fmt.Errorf("field total_inflight_value of message noble.dollar.vaults.v2.CrossChainPositionSnapshot is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.active_positions":
		panic(fmt.Errorf("field active_positions of message noble.dollar.vaults.v2.CrossChainPositionSnapshot is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.stale_positions":
		panic(fmt.Errorf("field stale_positions of message noble.dollar.vaults.v2.CrossChainPositionSnapshot is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.block_height":
		panic(fmt.Errorf("field block_height of message noble.dollar.vaults.v2.CrossChainPositionSnapshot is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainPositionSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainPositionSnapshot does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CrossChainPositionSnapshot) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_remote_value":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.total_inflight_value":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.active_positions":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.stale_positions":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.block_height":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.CrossChainPositionSnapshot.value_by_route":
		m := make(map[uint32]string)
		return protoreflect.ValueOfMap(&_CrossChainPositionSnapshot_6_map{m: &m})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainPositionSnapshot"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainPositionSnapshot does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CrossChainPositionSnapshot) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.CrossChainPositionSnapshot", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CrossChainPositionSnapshot) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainPositionSnapshot) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CrossChainPositionSnapshot) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CrossChainPositionSnapshot) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CrossChainPositionSnapshot)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TotalRemoteValue)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TotalInflightValue)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ActivePositions != 0 {
			n += 1 + runtime.Sov(uint64(x.ActivePositions))
		}
		if x.StalePositions != 0 {
			n += 1 + runtime.Sov(uint64(x.StalePositions))
		}
		if x.BlockHeight != 0 {
			n += 1 + runtime.Sov(uint64(x.BlockHeight))
		}
		if len(x.ValueByRoute) > 0 {
			SiZeMaP := func(k uint32, v string) {
				mapEntrySize := 1 + runtime.Sov(uint64(k)) + 1 + len(v) + runtime.Sov(uint64(len(v)))
				n += mapEntrySize + 1 + runtime.Sov(uint64(mapEntrySize))
			}
			if options.Deterministic {
				sortme := make([]uint32, 0, len(x.ValueByRoute))
				for k := range x.ValueByRoute {
					sortme = append(sortme, k)
				}
				sort.Slice(sortme, func(i, j int) bool {
					return sortme[i] < sortme[j]
				})
				for _, k := range sortme {
					v := x.ValueByRoute[k]
					SiZeMaP(k, v)
				}
			} else {
				for k, v := range x.ValueByRoute {
					SiZeMaP(k, v)
				}
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CrossChainPositionSnapshot)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ValueByRoute) > 0 {
			MaRsHaLmAp := func(k uint32, v string) (protoiface.MarshalOutput, error) {
				baseI := i
				i -= len(v)
				copy(dAtA[i:], v)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
				i = runtime.EncodeVarint(dAtA, i, uint64(k))
				i--
				dAtA[i] = 0x8
				i = runtime.EncodeVarint(dAtA, i, uint64(baseI-i))
				i--
				dAtA[i] = 0x32
				return protoiface.MarshalOutput{}, nil
			}
			if options.Deterministic {
				keysForValueByRoute := make([]uint32, 0, len(x.ValueByRoute))
				for k := range x.ValueByRoute {
					keysForValueByRoute = append(keysForValueByRoute, uint32(k))
				}
				sort.Slice(keysForValueByRoute, func(i, j int) bool {
					return keysForValueByRoute[i] < keysForValueByRoute[j]
				})
				for iNdEx := len(keysForValueByRoute) - 1; iNdEx >= 0; iNdEx-- {
					v := x.ValueByRoute[uint32(keysForValueByRoute[iNdEx])]
					out, err := MaRsHaLmAp(keysForValueByRoute[iNdEx], v)
					if err != nil {
						return out, err
					}
				}
			} else {
				for k := range x.ValueByRoute {
					v := x.ValueByRoute[k]
					out, err := MaRsHaLmAp(k, v)
					if err != nil {
						return out, err
					}
				}
			}
		}
		if x.BlockHeight != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BlockHeight))
			i--
			dAtA[i] = 0x28
		}
		if x.StalePositions != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.StalePositions))
			i--
			dAtA[i] = 0x20
		}
		if x.ActivePositions != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ActivePositions))
			i--
			dAtA[i] = 0x18
		}
		if len(x.TotalInflightValue) > 0 {
			i -= len(x.TotalInflightValue)
			copy(dAtA[i:], x.TotalInflightValue)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalInflightValue)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.TotalRemoteValue) > 0 {
			i -= len(x.TotalRemoteValue)
			copy(dAtA[i:], x.TotalRemoteValue)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TotalRemoteValue)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CrossChainPositionSnapshot)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CrossChainPositionSnapshot: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CrossChainPositionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalRemoteValue", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalRemoteValue = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalInflightValue", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TotalInflightValue = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ActivePositions", wireType)
				}
				x.ActivePositions = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ActivePositions |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StalePositions", wireType)
				}
				x.StalePositions = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.StalePositions |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
				}
				x.BlockHeight = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BlockHeight |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ValueByRoute", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ValueByRoute == nil {
					x.ValueByRoute = make(map[uint32]string)
				}
				var mapkey uint32
				var mapvalue string
				for iNdEx < postIndex {
					entryPreIndex := iNdEx
					var wire uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						wire |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					fieldNum := int32(wire >> 3)
					if fieldNum == 1 {
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							mapkey |= uint32(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
					} else if fieldNum == 2 {
						var stringLenmapvalue uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							stringLenmapvalue |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						intStringLenmapvalue := int(stringLenmapvalue)
						if intStringLenmapvalue < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postStringIndexmapvalue := iNdEx + intStringLenmapvalue
						if postStringIndexmapvalue < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postStringIndexmapvalue > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
						iNdEx = postStringIndexmapvalue
					} else {
						iNdEx = entryPreIndex
						skippy, err := runtime.Skip(dAtA[iNdEx:])
						if err != nil {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
						}
						if (skippy < 0) || (iNdEx+skippy) < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if (iNdEx + skippy) > postIndex {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						iNdEx += skippy
					}
				}
				x.ValueByRoute[mapkey] = mapvalue
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_CrossChainConfig_5_list)(nil)

type _CrossChainConfig_5_list struct {
	list *[]string
}

func (x *_CrossChainConfig_5_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_CrossChainConfig_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_CrossChainConfig_5_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_CrossChainConfig_5_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_CrossChainConfig_5_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message CrossChainConfig at list field AllowedChains as it is not of Message kind"))
}

func (x *_CrossChainConfig_5_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_CrossChainConfig_5_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_CrossChainConfig_5_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_CrossChainConfig_9_list)(nil)

type _CrossChainConfig_9_list struct {
	list *[]ProviderType
}

func (x *_CrossChainConfig_9_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_CrossChainConfig_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfEnum((protoreflect.EnumNumber)((*x.list)[i]))
}

func (x *_CrossChainConfig_9_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Enum()
	concreteValue := (ProviderType)(valueUnwrapped)
	(*x.list)[i] = concreteValue
}

func (x *_CrossChainConfig_9_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Enum()
	concreteValue := (ProviderType)(valueUnwrapped)
	*x.list = append(*x.list, concreteValue)
}

func (x *_CrossChainConfig_9_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message CrossChainConfig at list field SupportedProviders as it is not of Message kind"))
}

func (x *_CrossChainConfig_9_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_CrossChainConfig_9_list) NewElement() protoreflect.Value {
	v := 0
	return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(v))
}

func (x *_CrossChainConfig_9_list) IsValid() bool {
	return x.list != nil
}

var (
	md_CrossChainConfig                       protoreflect.MessageDescriptor
	fd_CrossChainConfig_max_remote_exposure   protoreflect.FieldDescriptor
	fd_CrossChainConfig_default_timeout       protoreflect.FieldDescriptor
	fd_CrossChainConfig_update_frequency      protoreflect.FieldDescriptor
	fd_CrossChainConfig_max_remote_positions  protoreflect.FieldDescriptor
	fd_CrossChainConfig_allowed_chains        protoreflect.FieldDescriptor
	fd_CrossChainConfig_enabled               protoreflect.FieldDescriptor
	fd_CrossChainConfig_max_inflight_duration protoreflect.FieldDescriptor
	fd_CrossChainConfig_max_inflight_value    protoreflect.FieldDescriptor
	fd_CrossChainConfig_supported_providers   protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_CrossChainConfig = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("CrossChainConfig")
	fd_CrossChainConfig_max_remote_exposure = md_CrossChainConfig.Fields().ByName("max_remote_exposure")
	fd_CrossChainConfig_default_timeout = md_CrossChainConfig.Fields().ByName("default_timeout")
	fd_CrossChainConfig_update_frequency = md_CrossChainConfig.Fields().ByName("update_frequency")
	fd_CrossChainConfig_max_remote_positions = md_CrossChainConfig.Fields().ByName("max_remote_positions")
	fd_CrossChainConfig_allowed_chains = md_CrossChainConfig.Fields().ByName("allowed_chains")
	fd_CrossChainConfig_enabled = md_CrossChainConfig.Fields().ByName("enabled")
	fd_CrossChainConfig_max_inflight_duration = md_CrossChainConfig.Fields().ByName("max_inflight_duration")
	fd_CrossChainConfig_max_inflight_value = md_CrossChainConfig.Fields().ByName("max_inflight_value")
	fd_CrossChainConfig_supported_providers = md_CrossChainConfig.Fields().ByName("supported_providers")
}

var _ protoreflect.Message = (*fastReflection_CrossChainConfig)(nil)

type fastReflection_CrossChainConfig CrossChainConfig

func (x *CrossChainConfig) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CrossChainConfig)(x)
}

func (x *CrossChainConfig) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CrossChainConfig_messageType fastReflection_CrossChainConfig_messageType
var _ protoreflect.MessageType = fastReflection_CrossChainConfig_messageType{}

type fastReflection_CrossChainConfig_messageType struct{}

func (x fastReflection_CrossChainConfig_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CrossChainConfig)(nil)
}
func (x fastReflection_CrossChainConfig_messageType) New() protoreflect.Message {
	return new(fastReflection_CrossChainConfig)
}
func (x fastReflection_CrossChainConfig_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CrossChainConfig
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CrossChainConfig) Descriptor() protoreflect.MessageDescriptor {
	return md_CrossChainConfig
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CrossChainConfig) Type() protoreflect.MessageType {
	return _fastReflection_CrossChainConfig_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CrossChainConfig) New() protoreflect.Message {
	return new(fastReflection_CrossChainConfig)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CrossChainConfig) Interface() protoreflect.ProtoMessage {
	return (*CrossChainConfig)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CrossChainConfig) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.MaxRemoteExposure != int32(0) {
		value := protoreflect.ValueOfInt32(x.MaxRemoteExposure)
		if !f(fd_CrossChainConfig_max_remote_exposure, value) {
			return
		}
	}
	if x.DefaultTimeout != int64(0) {
		value := protoreflect.ValueOfInt64(x.DefaultTimeout)
		if !f(fd_CrossChainConfig_default_timeout, value) {
			return
		}
	}
	if x.UpdateFrequency != int64(0) {
		value := protoreflect.ValueOfInt64(x.UpdateFrequency)
		if !f(fd_CrossChainConfig_update_frequency, value) {
			return
		}
	}
	if x.MaxRemotePositions != uint32(0) {
		value := protoreflect.ValueOfUint32(x.MaxRemotePositions)
		if !f(fd_CrossChainConfig_max_remote_positions, value) {
			return
		}
	}
	if len(x.AllowedChains) != 0 {
		value := protoreflect.ValueOfList(&_CrossChainConfig_5_list{list: &x.AllowedChains})
		if !f(fd_CrossChainConfig_allowed_chains, value) {
			return
		}
	}
	if x.Enabled != false {
		value := protoreflect.ValueOfBool(x.Enabled)
		if !f(fd_CrossChainConfig_enabled, value) {
			return
		}
	}
	if x.MaxInflightDuration != int64(0) {
		value := protoreflect.ValueOfInt64(x.MaxInflightDuration)
		if !f(fd_CrossChainConfig_max_inflight_duration, value) {
			return
		}
	}
	if x.MaxInflightValue != "" {
		value := protoreflect.ValueOfString(x.MaxInflightValue)
		if !f(fd_CrossChainConfig_max_inflight_value, value) {
			return
		}
	}
	if len(x.SupportedProviders) != 0 {
		value := protoreflect.ValueOfList(&_CrossChainConfig_9_list{list: &x.SupportedProviders})
		if !f(fd_CrossChainConfig_supported_providers, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CrossChainConfig) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_exposure":
		return x.MaxRemoteExposure != int32(0)
	case "noble.dollar.vaults.v2.CrossChainConfig.default_timeout":
		return x.DefaultTimeout != int64(0)
	case "noble.dollar.vaults.v2.CrossChainConfig.update_frequency":
		return x.UpdateFrequency != int64(0)
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_positions":
		return x.MaxRemotePositions != uint32(0)
	case "noble.dollar.vaults.v2.CrossChainConfig.allowed_chains":
		return len(x.AllowedChains) != 0
	case "noble.dollar.vaults.v2.CrossChainConfig.enabled":
		return x.Enabled != false
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_duration":
		return x.MaxInflightDuration != int64(0)
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_value":
		return x.MaxInflightValue != ""
	case "noble.dollar.vaults.v2.CrossChainConfig.supported_providers":
		return len(x.SupportedProviders) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainConfig does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainConfig) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_exposure":
		x.MaxRemoteExposure = int32(0)
	case "noble.dollar.vaults.v2.CrossChainConfig.default_timeout":
		x.DefaultTimeout = int64(0)
	case "noble.dollar.vaults.v2.CrossChainConfig.update_frequency":
		x.UpdateFrequency = int64(0)
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_positions":
		x.MaxRemotePositions = uint32(0)
	case "noble.dollar.vaults.v2.CrossChainConfig.allowed_chains":
		x.AllowedChains = nil
	case "noble.dollar.vaults.v2.CrossChainConfig.enabled":
		x.Enabled = false
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_duration":
		x.MaxInflightDuration = int64(0)
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_value":
		x.MaxInflightValue = ""
	case "noble.dollar.vaults.v2.CrossChainConfig.supported_providers":
		x.SupportedProviders = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainConfig does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CrossChainConfig) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_exposure":
		value := x.MaxRemoteExposure
		return protoreflect.ValueOfInt32(value)
	case "noble.dollar.vaults.v2.CrossChainConfig.default_timeout":
		value := x.DefaultTimeout
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.CrossChainConfig.update_frequency":
		value := x.UpdateFrequency
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_positions":
		value := x.MaxRemotePositions
		return protoreflect.ValueOfUint32(value)
	case "noble.dollar.vaults.v2.CrossChainConfig.allowed_chains":
		if len(x.AllowedChains) == 0 {
			return protoreflect.ValueOfList(&_CrossChainConfig_5_list{})
		}
		listValue := &_CrossChainConfig_5_list{list: &x.AllowedChains}
		return protoreflect.ValueOfList(listValue)
	case "noble.dollar.vaults.v2.CrossChainConfig.enabled":
		value := x.Enabled
		return protoreflect.ValueOfBool(value)
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_duration":
		value := x.MaxInflightDuration
		return protoreflect.ValueOfInt64(value)
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_value":
		value := x.MaxInflightValue
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.CrossChainConfig.supported_providers":
		if len(x.SupportedProviders) == 0 {
			return protoreflect.ValueOfList(&_CrossChainConfig_9_list{})
		}
		listValue := &_CrossChainConfig_9_list{list: &x.SupportedProviders}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainConfig does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainConfig) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_exposure":
		x.MaxRemoteExposure = int32(value.Int())
	case "noble.dollar.vaults.v2.CrossChainConfig.default_timeout":
		x.DefaultTimeout = value.Int()
	case "noble.dollar.vaults.v2.CrossChainConfig.update_frequency":
		x.UpdateFrequency = value.Int()
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_positions":
		x.MaxRemotePositions = uint32(value.Uint())
	case "noble.dollar.vaults.v2.CrossChainConfig.allowed_chains":
		lv := value.List()
		clv := lv.(*_CrossChainConfig_5_list)
		x.AllowedChains = *clv.list
	case "noble.dollar.vaults.v2.CrossChainConfig.enabled":
		x.Enabled = value.Bool()
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_duration":
		x.MaxInflightDuration = value.Int()
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_value":
		x.MaxInflightValue = value.Interface().(string)
	case "noble.dollar.vaults.v2.CrossChainConfig.supported_providers":
		lv := value.List()
		clv := lv.(*_CrossChainConfig_9_list)
		x.SupportedProviders = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainConfig does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainConfig) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainConfig.allowed_chains":
		if x.AllowedChains == nil {
			x.AllowedChains = []string{}
		}
		value := &_CrossChainConfig_5_list{list: &x.AllowedChains}
		return protoreflect.ValueOfList(value)
	case "noble.dollar.vaults.v2.CrossChainConfig.supported_providers":
		if x.SupportedProviders == nil {
			x.SupportedProviders = []ProviderType{}
		}
		value := &_CrossChainConfig_9_list{list: &x.SupportedProviders}
		return protoreflect.ValueOfList(value)
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_exposure":
		panic(fmt.Errorf("field max_remote_exposure of message noble.dollar.vaults.v2.CrossChainConfig is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainConfig.default_timeout":
		panic(fmt.Errorf("field default_timeout of message noble.dollar.vaults.v2.CrossChainConfig is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainConfig.update_frequency":
		panic(fmt.Errorf("field update_frequency of message noble.dollar.vaults.v2.CrossChainConfig is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_positions":
		panic(fmt.Errorf("field max_remote_positions of message noble.dollar.vaults.v2.CrossChainConfig is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainConfig.enabled":
		panic(fmt.Errorf("field enabled of message noble.dollar.vaults.v2.CrossChainConfig is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_duration":
		panic(fmt.Errorf("field max_inflight_duration of message noble.dollar.vaults.v2.CrossChainConfig is not mutable"))
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_value":
		panic(fmt.Errorf("field max_inflight_value of message noble.dollar.vaults.v2.CrossChainConfig is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainConfig does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CrossChainConfig) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_exposure":
		return protoreflect.ValueOfInt32(int32(0))
	case "noble.dollar.vaults.v2.CrossChainConfig.default_timeout":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.CrossChainConfig.update_frequency":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.CrossChainConfig.max_remote_positions":
		return protoreflect.ValueOfUint32(uint32(0))
	case "noble.dollar.vaults.v2.CrossChainConfig.allowed_chains":
		list := []string{}
		return protoreflect.ValueOfList(&_CrossChainConfig_5_list{list: &list})
	case "noble.dollar.vaults.v2.CrossChainConfig.enabled":
		return protoreflect.ValueOfBool(false)
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_duration":
		return protoreflect.ValueOfInt64(int64(0))
	case "noble.dollar.vaults.v2.CrossChainConfig.max_inflight_value":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.CrossChainConfig.supported_providers":
		list := []ProviderType{}
		return protoreflect.ValueOfList(&_CrossChainConfig_9_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.CrossChainConfig"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.CrossChainConfig does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CrossChainConfig) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.CrossChainConfig", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CrossChainConfig) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CrossChainConfig) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CrossChainConfig) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CrossChainConfig) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CrossChainConfig)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.MaxRemoteExposure != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxRemoteExposure))
		}
		if x.DefaultTimeout != 0 {
			n += 1 + runtime.Sov(uint64(x.DefaultTimeout))
		}
		if x.UpdateFrequency != 0 {
			n += 1 + runtime.Sov(uint64(x.UpdateFrequency))
		}
		if x.MaxRemotePositions != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxRemotePositions))
		}
		if len(x.AllowedChains) > 0 {
			for _, s := range x.AllowedChains {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.Enabled {
			n += 2
		}
		if x.MaxInflightDuration != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxInflightDuration))
		}
		l = len(x.MaxInflightValue)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.SupportedProviders) > 0 {
			l = 0
			for _, e := range x.SupportedProviders {
				l += runtime.Sov(uint64(e))
			}
			n += 1 + runtime.Sov(uint64(l)) + l
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CrossChainConfig)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SupportedProviders) > 0 {
			var pksize2 int
			for _, num := range x.SupportedProviders {
				pksize2 += runtime.Sov(uint64(num))
			}
			i -= pksize2
			j1 := i
			for _, num1 := range x.SupportedProviders {
				num := uint64(num1)
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
			i = runtime.EncodeVarint(dAtA, i, uint64(pksize2))
			i--
			dAtA[i] = 0x4a
		}
		if len(x.MaxInflightValue) > 0 {
			i -= len(x.MaxInflightValue)
			copy(dAtA[i:], x.MaxInflightValue)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MaxInflightValue)))
			i--
			dAtA[i] = 0x42
		}
		if x.MaxInflightDuration != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxInflightDuration))
			i--
			dAtA[i] = 0x38
		}
		if x.Enabled {
			i--
			if x.Enabled {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if len(x.AllowedChains) > 0 {
			for iNdEx := len(x.AllowedChains) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.AllowedChains[iNdEx])
				copy(dAtA[i:], x.AllowedChains[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AllowedChains[iNdEx])))
				i--
				dAtA[i] = 0x2a
			}
		}
		if x.MaxRemotePositions != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxRemotePositions))
			i--
			dAtA[i] = 0x20
		}
		if x.UpdateFrequency != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.UpdateFrequency))
			i--
			dAtA[i] = 0x18
		}
		if x.DefaultTimeout != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.DefaultTimeout))
			i--
			dAtA[i] = 0x10
		}
		if x.MaxRemoteExposure != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxRemoteExposure))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CrossChainConfig)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CrossChainConfig: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CrossChainConfig: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxRemoteExposure", wireType)
				}
				x.MaxRemoteExposure = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxRemoteExposure |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DefaultTimeout", wireType)
				}
				x.DefaultTimeout = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.DefaultTimeout |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UpdateFrequency", wireType)
				}
				x.UpdateFrequency = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.UpdateFrequency |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxRemotePositions", wireType)
				}
				x.MaxRemotePositions = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxRemotePositions |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AllowedChains", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AllowedChains = append(x.AllowedChains, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Enabled = bool(v != 0)
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxInflightDuration", wireType)
				}
				x.MaxInflightDuration = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxInflightDuration |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxInflightValue", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MaxInflightValue = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType == 0 {
					var v ProviderType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ProviderType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					x.SupportedProviders = append(x.SupportedProviders, v)
				} else if wireType == 2 {
					var packedLen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						packedLen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if packedLen < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					postIndex := iNdEx + packedLen
					if postIndex < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					if postIndex > l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					var elementCount int
					if elementCount != 0 && len(x.SupportedProviders) == 0 {
						x.SupportedProviders = make([]ProviderType, 0, elementCount)
					}
					for iNdEx < postIndex {
						var v ProviderType
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							v |= ProviderType(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						x.SupportedProviders = append(x.SupportedProviders, v)
					}
				} else {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SupportedProviders", wireType)
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_StaleInflightAlert                protoreflect.MessageDescriptor
	fd_StaleInflightAlert_route_id       protoreflect.FieldDescriptor
	fd_StaleInflightAlert_transaction_id protoreflect.FieldDescriptor
	fd_StaleInflightAlert_hours_overdue  protoreflect.FieldDescriptor
	fd_StaleInflightAlert_timestamp      protoreflect.FieldDescriptor
	fd_StaleInflightAlert_amount         protoreflect.FieldDescriptor
)

func init() {
	file_noble_dollar_vaults_v2_cross_chain_proto_init()
	md_StaleInflightAlert = File_noble_dollar_vaults_v2_cross_chain_proto.Messages().ByName("StaleInflightAlert")
	fd_StaleInflightAlert_route_id = md_StaleInflightAlert.Fields().ByName("route_id")
	fd_StaleInflightAlert_transaction_id = md_StaleInflightAlert.Fields().ByName("transaction_id")
	fd_StaleInflightAlert_hours_overdue = md_StaleInflightAlert.Fields().ByName("hours_overdue")
	fd_StaleInflightAlert_timestamp = md_StaleInflightAlert.Fields().ByName("timestamp")
	fd_StaleInflightAlert_amount = md_StaleInflightAlert.Fields().ByName("amount")
}

var _ protoreflect.Message = (*fastReflection_StaleInflightAlert)(nil)

type fastReflection_StaleInflightAlert StaleInflightAlert

func (x *StaleInflightAlert) ProtoReflect() protoreflect.Message {
	return (*fastReflection_StaleInflightAlert)(x)
}

func (x *StaleInflightAlert) slowProtoReflect() protoreflect.Message {
	mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_StaleInflightAlert_messageType fastReflection_StaleInflightAlert_messageType
var _ protoreflect.MessageType = fastReflection_StaleInflightAlert_messageType{}

type fastReflection_StaleInflightAlert_messageType struct{}

func (x fastReflection_StaleInflightAlert_messageType) Zero() protoreflect.Message {
	return (*fastReflection_StaleInflightAlert)(nil)
}
func (x fastReflection_StaleInflightAlert_messageType) New() protoreflect.Message {
	return new(fastReflection_StaleInflightAlert)
}
func (x fastReflection_StaleInflightAlert_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_StaleInflightAlert
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_StaleInflightAlert) Descriptor() protoreflect.MessageDescriptor {
	return md_StaleInflightAlert
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_StaleInflightAlert) Type() protoreflect.MessageType {
	return _fastReflection_StaleInflightAlert_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_StaleInflightAlert) New() protoreflect.Message {
	return new(fastReflection_StaleInflightAlert)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_StaleInflightAlert) Interface() protoreflect.ProtoMessage {
	return (*StaleInflightAlert)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_StaleInflightAlert) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.RouteId != uint32(0) {
		value := protoreflect.ValueOfUint32(x.RouteId)
		if !f(fd_StaleInflightAlert_route_id, value) {
			return
		}
	}
	if x.TransactionId != "" {
		value := protoreflect.ValueOfString(x.TransactionId)
		if !f(fd_StaleInflightAlert_transaction_id, value) {
			return
		}
	}
	if x.HoursOverdue != float64(0) || math.Signbit(x.HoursOverdue) {
		value := protoreflect.ValueOfFloat64(x.HoursOverdue)
		if !f(fd_StaleInflightAlert_hours_overdue, value) {
			return
		}
	}
	if x.Timestamp != nil {
		value := protoreflect.ValueOfMessage(x.Timestamp.ProtoReflect())
		if !f(fd_StaleInflightAlert_timestamp, value) {
			return
		}
	}
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_StaleInflightAlert_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_StaleInflightAlert) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.StaleInflightAlert.route_id":
		return x.RouteId != uint32(0)
	case "noble.dollar.vaults.v2.StaleInflightAlert.transaction_id":
		return x.TransactionId != ""
	case "noble.dollar.vaults.v2.StaleInflightAlert.hours_overdue":
		return x.HoursOverdue != float64(0) || math.Signbit(x.HoursOverdue)
	case "noble.dollar.vaults.v2.StaleInflightAlert.timestamp":
		return x.Timestamp != nil
	case "noble.dollar.vaults.v2.StaleInflightAlert.amount":
		return x.Amount != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.StaleInflightAlert"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.StaleInflightAlert does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_StaleInflightAlert) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.StaleInflightAlert.route_id":
		x.RouteId = uint32(0)
	case "noble.dollar.vaults.v2.StaleInflightAlert.transaction_id":
		x.TransactionId = ""
	case "noble.dollar.vaults.v2.StaleInflightAlert.hours_overdue":
		x.HoursOverdue = float64(0)
	case "noble.dollar.vaults.v2.StaleInflightAlert.timestamp":
		x.Timestamp = nil
	case "noble.dollar.vaults.v2.StaleInflightAlert.amount":
		x.Amount = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.StaleInflightAlert"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.StaleInflightAlert does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_StaleInflightAlert) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "noble.dollar.vaults.v2.StaleInflightAlert.route_id":
		value := x.RouteId
		return protoreflect.ValueOfUint32(value)
	case "noble.dollar.vaults.v2.StaleInflightAlert.transaction_id":
		value := x.TransactionId
		return protoreflect.ValueOfString(value)
	case "noble.dollar.vaults.v2.StaleInflightAlert.hours_overdue":
		value := x.HoursOverdue
		return protoreflect.ValueOfFloat64(value)
	case "noble.dollar.vaults.v2.StaleInflightAlert.timestamp":
		value := x.Timestamp
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "noble.dollar.vaults.v2.StaleInflightAlert.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.StaleInflightAlert"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.StaleInflightAlert does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_StaleInflightAlert) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.StaleInflightAlert.route_id":
		x.RouteId = uint32(value.Uint())
	case "noble.dollar.vaults.v2.StaleInflightAlert.transaction_id":
		x.TransactionId = value.Interface().(string)
	case "noble.dollar.vaults.v2.StaleInflightAlert.hours_overdue":
		x.HoursOverdue = value.Float()
	case "noble.dollar.vaults.v2.StaleInflightAlert.timestamp":
		x.Timestamp = value.Message().Interface().(*timestamppb.Timestamp)
	case "noble.dollar.vaults.v2.StaleInflightAlert.amount":
		x.Amount = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.StaleInflightAlert"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.StaleInflightAlert does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_StaleInflightAlert) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.StaleInflightAlert.timestamp":
		if x.Timestamp == nil {
			x.Timestamp = new(timestamppb.Timestamp)
		}
		return protoreflect.ValueOfMessage(x.Timestamp.ProtoReflect())
	case "noble.dollar.vaults.v2.StaleInflightAlert.route_id":
		panic(fmt.Errorf("field route_id of message noble.dollar.vaults.v2.StaleInflightAlert is not mutable"))
	case "noble.dollar.vaults.v2.StaleInflightAlert.transaction_id":
		panic(fmt.Errorf("field transaction_id of message noble.dollar.vaults.v2.StaleInflightAlert is not mutable"))
	case "noble.dollar.vaults.v2.StaleInflightAlert.hours_overdue":
		panic(fmt.Errorf("field hours_overdue of message noble.dollar.vaults.v2.StaleInflightAlert is not mutable"))
	case "noble.dollar.vaults.v2.StaleInflightAlert.amount":
		panic(fmt.Errorf("field amount of message noble.dollar.vaults.v2.StaleInflightAlert is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.StaleInflightAlert"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.StaleInflightAlert does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_StaleInflightAlert) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "noble.dollar.vaults.v2.StaleInflightAlert.route_id":
		return protoreflect.ValueOfUint32(uint32(0))
	case "noble.dollar.vaults.v2.StaleInflightAlert.transaction_id":
		return protoreflect.ValueOfString("")
	case "noble.dollar.vaults.v2.StaleInflightAlert.hours_overdue":
		return protoreflect.ValueOfFloat64(float64(0))
	case "noble.dollar.vaults.v2.StaleInflightAlert.timestamp":
		m := new(timestamppb.Timestamp)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "noble.dollar.vaults.v2.StaleInflightAlert.amount":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: noble.dollar.vaults.v2.StaleInflightAlert"))
		}
		panic(fmt.Errorf("message noble.dollar.vaults.v2.StaleInflightAlert does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_StaleInflightAlert) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in noble.dollar.vaults.v2.StaleInflightAlert", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_StaleInflightAlert) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_StaleInflightAlert) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_StaleInflightAlert) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_StaleInflightAlert) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*StaleInflightAlert)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.RouteId != 0 {
			n += 1 + runtime.Sov(uint64(x.RouteId))
		}
		l = len(x.TransactionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.HoursOverdue != 0 || math.Signbit(x.HoursOverdue) {
			n += 9
		}
		if x.Timestamp != nil {
			l = options.Size(x.Timestamp)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*StaleInflightAlert)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0x2a
		}
		if x.Timestamp != nil {
			encoded, err := options.Marshal(x.Timestamp)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if x.HoursOverdue != 0 || math.Signbit(x.HoursOverdue) {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(x.HoursOverdue))))
			i--
			dAtA[i] = 0x19
		}
		if len(x.TransactionId) > 0 {
			i -= len(x.TransactionId)
			copy(dAtA[i:], x.TransactionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TransactionId)))
			i--
			dAtA[i] = 0x12
		}
		if x.RouteId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.RouteId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*StaleInflightAlert)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: StaleInflightAlert: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: StaleInflightAlert: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
				}
				x.RouteId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.RouteId |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TransactionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 1 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field HoursOverdue", wireType)
				}
				var v uint64
				if (iNdEx + 8) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				x.HoursOverdue = float64(math.Float64frombits(v))
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Timestamp == nil {
					x.Timestamp = &timestamppb.Timestamp{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Timestamp); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: noble/dollar/vaults/v2/cross_chain.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// RemotePositionStatus represents the status of a remote position
type RemotePositionStatus int32

const (
	// Position is active and being tracked
	RemotePositionStatus_REMOTE_POSITION_ACTIVE RemotePositionStatus = 0
	// Position is being withdrawn from
	RemotePositionStatus_REMOTE_POSITION_WITHDRAWING RemotePositionStatus = 1
	// Position has been closed
	RemotePositionStatus_REMOTE_POSITION_CLOSED RemotePositionStatus = 2
	// Position is in error state
	RemotePositionStatus_REMOTE_POSITION_ERROR RemotePositionStatus = 3
)

// Enum value maps for RemotePositionStatus.
var (
	RemotePositionStatus_name = map[int32]string{
		0: "REMOTE_POSITION_ACTIVE",
		1: "REMOTE_POSITION_WITHDRAWING",
		2: "REMOTE_POSITION_CLOSED",
		3: "REMOTE_POSITION_ERROR",
	}
	RemotePositionStatus_value = map[string]int32{
		"REMOTE_POSITION_ACTIVE":      0,
		"REMOTE_POSITION_WITHDRAWING": 1,
		"REMOTE_POSITION_CLOSED":      2,
		"REMOTE_POSITION_ERROR":       3,
	}
)

func (x RemotePositionStatus) Enum() *RemotePositionStatus {
	p := new(RemotePositionStatus)
	*p = x
	return p
}

func (x RemotePositionStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RemotePositionStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[0].Descriptor()
}

func (RemotePositionStatus) Type() protoreflect.EnumType {
	return &file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[0]
}

func (x RemotePositionStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RemotePositionStatus.Descriptor instead.
func (RemotePositionStatus) EnumDescriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{0}
}

// OperationType represents the type of cross-chain operation
type OperationType int32

const (
	// Deposit operation
	OperationType_OPERATION_TYPE_DEPOSIT OperationType = 0
	// Withdrawal operation
	OperationType_OPERATION_TYPE_WITHDRAWAL OperationType = 1
	// Rebalance operation
	OperationType_OPERATION_TYPE_REBALANCE OperationType = 2
)

// Enum value maps for OperationType.
var (
	OperationType_name = map[int32]string{
		0: "OPERATION_TYPE_DEPOSIT",
		1: "OPERATION_TYPE_WITHDRAWAL",
		2: "OPERATION_TYPE_REBALANCE",
	}
	OperationType_value = map[string]int32{
		"OPERATION_TYPE_DEPOSIT":    0,
		"OPERATION_TYPE_WITHDRAWAL": 1,
		"OPERATION_TYPE_REBALANCE":  2,
	}
)

func (x OperationType) Enum() *OperationType {
	p := new(OperationType)
	*p = x
	return p
}

func (x OperationType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OperationType) Descriptor() protoreflect.EnumDescriptor {
	return file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[1].Descriptor()
}

func (OperationType) Type() protoreflect.EnumType {
	return &file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[1]
}

func (x OperationType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OperationType.Descriptor instead.
func (OperationType) EnumDescriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{1}
}

// InflightType defines the type of inflight funds
type InflightType int32

const (
	// USDN being deployed to a remote position
	InflightType_INFLIGHT_DEPOSIT_TO_POSITION InflightType = 0
	// USDN returning from a remote position
	InflightType_INFLIGHT_WITHDRAWAL_FROM_POSITION InflightType = 1
	// USDN moving between positions (via Noble)
	InflightType_INFLIGHT_REBALANCE_BETWEEN_POSITIONS InflightType = 2
	// USDN awaiting deployment to positions
	InflightType_INFLIGHT_PENDING_DEPLOYMENT InflightType = 3
	// USDN awaiting distribution to withdrawal queue
	InflightType_INFLIGHT_PENDING_WITHDRAWAL_DISTRIBUTION InflightType = 4
)

// Enum value maps for InflightType.
var (
	InflightType_name = map[int32]string{
		0: "INFLIGHT_DEPOSIT_TO_POSITION",
		1: "INFLIGHT_WITHDRAWAL_FROM_POSITION",
		2: "INFLIGHT_REBALANCE_BETWEEN_POSITIONS",
		3: "INFLIGHT_PENDING_DEPLOYMENT",
		4: "INFLIGHT_PENDING_WITHDRAWAL_DISTRIBUTION",
	}
	InflightType_value = map[string]int32{
		"INFLIGHT_DEPOSIT_TO_POSITION":             0,
		"INFLIGHT_WITHDRAWAL_FROM_POSITION":        1,
		"INFLIGHT_REBALANCE_BETWEEN_POSITIONS":     2,
		"INFLIGHT_PENDING_DEPLOYMENT":              3,
		"INFLIGHT_PENDING_WITHDRAWAL_DISTRIBUTION": 4,
	}
)

func (x InflightType) Enum() *InflightType {
	p := new(InflightType)
	*p = x
	return p
}

func (x InflightType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InflightType) Descriptor() protoreflect.EnumDescriptor {
	return file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[2].Descriptor()
}

func (InflightType) Type() protoreflect.EnumType {
	return &file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[2]
}

func (x InflightType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use InflightType.Descriptor instead.
func (InflightType) EnumDescriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{2}
}

// InflightStatus represents the status of inflight funds
type InflightStatus int32

const (
	// Transaction is pending
	InflightStatus_INFLIGHT_PENDING InflightStatus = 0
	// Transaction is confirmed by provider
	InflightStatus_INFLIGHT_CONFIRMED InflightStatus = 1
	// Transaction completed successfully
	InflightStatus_INFLIGHT_COMPLETED InflightStatus = 2
	// Transaction failed
	InflightStatus_INFLIGHT_FAILED InflightStatus = 3
	// Transaction timed out
	InflightStatus_INFLIGHT_TIMEOUT InflightStatus = 4
)

// Enum value maps for InflightStatus.
var (
	InflightStatus_name = map[int32]string{
		0: "INFLIGHT_PENDING",
		1: "INFLIGHT_CONFIRMED",
		2: "INFLIGHT_COMPLETED",
		3: "INFLIGHT_FAILED",
		4: "INFLIGHT_TIMEOUT",
	}
	InflightStatus_value = map[string]int32{
		"INFLIGHT_PENDING":   0,
		"INFLIGHT_CONFIRMED": 1,
		"INFLIGHT_COMPLETED": 2,
		"INFLIGHT_FAILED":    3,
		"INFLIGHT_TIMEOUT":   4,
	}
)

func (x InflightStatus) Enum() *InflightStatus {
	p := new(InflightStatus)
	*p = x
	return p
}

func (x InflightStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InflightStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[3].Descriptor()
}

func (InflightStatus) Type() protoreflect.EnumType {
	return &file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[3]
}

func (x InflightStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use InflightStatus.Descriptor instead.
func (InflightStatus) EnumDescriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{3}
}

// OracleUpdateStatus represents the status of an oracle update
type OracleUpdateStatus int32

const (
	// Update has been validated
	OracleUpdateStatus_ORACLE_UPDATE_VALIDATED OracleUpdateStatus = 0
	// Update has been applied to position
	OracleUpdateStatus_ORACLE_UPDATE_APPLIED OracleUpdateStatus = 1
	// Update was rejected (stale, invalid, etc.)
	OracleUpdateStatus_ORACLE_UPDATE_REJECTED OracleUpdateStatus = 2
)

// Enum value maps for OracleUpdateStatus.
var (
	OracleUpdateStatus_name = map[int32]string{
		0: "ORACLE_UPDATE_VALIDATED",
		1: "ORACLE_UPDATE_APPLIED",
		2: "ORACLE_UPDATE_REJECTED",
	}
	OracleUpdateStatus_value = map[string]int32{
		"ORACLE_UPDATE_VALIDATED": 0,
		"ORACLE_UPDATE_APPLIED":   1,
		"ORACLE_UPDATE_REJECTED":  2,
	}
)

func (x OracleUpdateStatus) Enum() *OracleUpdateStatus {
	p := new(OracleUpdateStatus)
	*p = x
	return p
}

func (x OracleUpdateStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OracleUpdateStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[4].Descriptor()
}

func (OracleUpdateStatus) Type() protoreflect.EnumType {
	return &file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[4]
}

func (x OracleUpdateStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OracleUpdateStatus.Descriptor instead.
func (OracleUpdateStatus) EnumDescriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{4}
}

// ProviderType represents the cross-chain provider type
type ProviderType int32

const (
	// Hyperlane provider
	ProviderType_PROVIDER_TYPE_HYPERLANE ProviderType = 0
	// IBC provider
	ProviderType_PROVIDER_TYPE_IBC ProviderType = 1
)

// Enum value maps for ProviderType.
var (
	ProviderType_name = map[int32]string{
		0: "PROVIDER_TYPE_HYPERLANE",
		1: "PROVIDER_TYPE_IBC",
	}
	ProviderType_value = map[string]int32{
		"PROVIDER_TYPE_HYPERLANE": 0,
		"PROVIDER_TYPE_IBC":       1,
	}
)

func (x ProviderType) Enum() *ProviderType {
	p := new(ProviderType)
	*p = x
	return p
}

func (x ProviderType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProviderType) Descriptor() protoreflect.EnumDescriptor {
	return file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[5].Descriptor()
}

func (ProviderType) Type() protoreflect.EnumType {
	return &file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes[5]
}

func (x ProviderType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProviderType.Descriptor instead.
func (ProviderType) EnumDescriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{5}
}

// CrossChainRoute defines a route for cross-chain operations
// Currently supports Hyperlane, with potential for future IBC support
type CrossChainRoute struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// HypToken
	HyptokenId string `protobuf:"bytes,1,opt,name=hyptoken_id,json=hyptokenId,proto3" json:"hyptoken_id,omitempty"`
	// Reciever chain hook;
	ReceiverChainHook string `protobuf:"bytes,2,opt,name=receiver_chain_hook,json=receiverChainHook,proto3" json:"receiver_chain_hook,omitempty"`
	// Vault
	RemotePositionAddress string `protobuf:"bytes,3,opt,name=remote_position_address,json=remotePositionAddress,proto3" json:"remote_position_address,omitempty"`
	// Maximum value allowed inflight on this route
	MaxInflightValue string `protobuf:"bytes,4,opt,name=max_inflight_value,json=maxInflightValue,proto3" json:"max_inflight_value,omitempty"`
}

func (x *CrossChainRoute) Reset() {
	*x = CrossChainRoute{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CrossChainRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CrossChainRoute) ProtoMessage() {}

// Deprecated: Use CrossChainRoute.ProtoReflect.Descriptor instead.
func (*CrossChainRoute) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{0}
}

func (x *CrossChainRoute) GetHyptokenId() string {
	if x != nil {
		return x.HyptokenId
	}
	return ""
}

func (x *CrossChainRoute) GetReceiverChainHook() string {
	if x != nil {
		return x.ReceiverChainHook
	}
	return ""
}

func (x *CrossChainRoute) GetRemotePositionAddress() string {
	if x != nil {
		return x.RemotePositionAddress
	}
	return ""
}

func (x *CrossChainRoute) GetMaxInflightValue() string {
	if x != nil {
		return x.MaxInflightValue
	}
	return ""
}

// RemotePosition represents a position in an ERC-4626 compatible vault on another chain
type RemotePosition struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// HypToken
	HyptokenId string `protobuf:"bytes,1,opt,name=hyptoken_id,json=hyptokenId,proto3" json:"hyptoken_id,omitempty"`
	// Address of the ERC-4626 compatible vault
	VaultAddress []byte `protobuf:"bytes,2,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// Number of vault shares held
	SharesHeld string `protobuf:"bytes,3,opt,name=shares_held,json=sharesHeld,proto3" json:"shares_held,omitempty"`
	// Principal amount initially deposited (in USDN)
	Principal string `protobuf:"bytes,4,opt,name=principal,proto3" json:"principal,omitempty"`
	// Current share price from oracle
	SharePrice string `protobuf:"bytes,5,opt,name=share_price,json=sharePrice,proto3" json:"share_price,omitempty"`
	// Total value of position (shares * price)
	TotalValue string `protobuf:"bytes,6,opt,name=total_value,json=totalValue,proto3" json:"total_value,omitempty"`
	// Last oracle update timestamp
	LastUpdate *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"`
	// Position status
	Status RemotePositionStatus `protobuf:"varint,8,opt,name=status,proto3,enum=noble.dollar.vaults.v2.RemotePositionStatus" json:"status,omitempty"`
	// Oracle configuration for this position
	OracleAddress string `protobuf:"bytes,9,opt,name=oracle_address,json=oracleAddress,proto3" json:"oracle_address,omitempty"`
	// Maximum staleness for oracle data (seconds)
	MaxStaleness int64 `protobuf:"varint,10,opt,name=max_staleness,json=maxStaleness,proto3" json:"max_staleness,omitempty"`
}

func (x *RemotePosition) Reset() {
	*x = RemotePosition{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemotePosition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemotePosition) ProtoMessage() {}

// Deprecated: Use RemotePosition.ProtoReflect.Descriptor instead.
func (*RemotePosition) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{1}
}

func (x *RemotePosition) GetHyptokenId() string {
	if x != nil {
		return x.HyptokenId
	}
	return ""
}

func (x *RemotePosition) GetVaultAddress() []byte {
	if x != nil {
		return x.VaultAddress
	}
	return nil
}

func (x *RemotePosition) GetSharesHeld() string {
	if x != nil {
		return x.SharesHeld
	}
	return ""
}

func (x *RemotePosition) GetPrincipal() string {
	if x != nil {
		return x.Principal
	}
	return ""
}

func (x *RemotePosition) GetSharePrice() string {
	if x != nil {
		return x.SharePrice
	}
	return ""
}

func (x *RemotePosition) GetTotalValue() string {
	if x != nil {
		return x.TotalValue
	}
	return ""
}

func (x *RemotePosition) GetLastUpdate() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUpdate
	}
	return nil
}

func (x *RemotePosition) GetStatus() RemotePositionStatus {
	if x != nil {
		return x.Status
	}
	return RemotePositionStatus_REMOTE_POSITION_ACTIVE
}

func (x *RemotePosition) GetOracleAddress() string {
	if x != nil {
		return x.OracleAddress
	}
	return ""
}

func (x *RemotePosition) GetMaxStaleness() int64 {
	if x != nil {
		return x.MaxStaleness
	}
	return 0
}

// InflightFund represents funds in transit between Noble and remote positions
type InflightFund struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Unique identifier for this inflight transaction
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Transaction ID (Hyperlane message ID or IBC packet sequence)
	TransactionId string `protobuf:"bytes,2,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	// Amount in USDN (always USDN, never shares)
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// Origin information
	//
	// Types that are assignable to Origin:
	//
	//	*InflightFund_NobleOrigin
	//	*InflightFund_RemoteOrigin
	Origin isInflightFund_Origin `protobuf_oneof:"origin"`
	// Destination information
	//
	// Types that are assignable to Destination:
	//
	//	*InflightFund_NobleDestination
	//	*InflightFund_RemoteDestination
	Destination isInflightFund_Destination `protobuf_oneof:"destination"`
	// When the operation was initiated
	InitiatedAt *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=initiated_at,json=initiatedAt,proto3" json:"initiated_at,omitempty"`
	// Expected completion time
	ExpectedAt *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=expected_at,json=expectedAt,proto3" json:"expected_at,omitempty"`
	// Current status
	Status InflightStatus `protobuf:"varint,10,opt,name=status,proto3,enum=noble.dollar.vaults.v2.InflightStatus" json:"status,omitempty"`
	// Value at initiation (for NAV calculation)
	ValueAtInitiation string `protobuf:"bytes,11,opt,name=value_at_initiation,json=valueAtInitiation,proto3" json:"value_at_initiation,omitempty"`
	// Provider-specific tracking information
	ProviderTracking *ProviderTrackingInfo `protobuf:"bytes,12,opt,name=provider_tracking,json=providerTracking,proto3" json:"provider_tracking,omitempty"`
}

func (x *InflightFund) Reset() {
	*x = InflightFund{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *InflightFund) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InflightFund) ProtoMessage() {}

// Deprecated: Use InflightFund.ProtoReflect.Descriptor instead.
func (*InflightFund) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{2}
}

func (x *InflightFund) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *InflightFund) GetTransactionId() string {
	if x != nil {
		return x.TransactionId
	}
	return ""
}

func (x *InflightFund) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *InflightFund) GetOrigin() isInflightFund_Origin {
	if x != nil {
		return x.Origin
	}
	return nil
}

func (x *InflightFund) GetNobleOrigin() *NobleEndpoint {
	if x, ok := x.GetOrigin().(*InflightFund_NobleOrigin); ok {
		return x.NobleOrigin
	}
	return nil
}

func (x *InflightFund) GetRemoteOrigin() *RemotePosition {
	if x, ok := x.GetOrigin().(*InflightFund_RemoteOrigin); ok {
		return x.RemoteOrigin
	}
	return nil
}

func (x *InflightFund) GetDestination() isInflightFund_Destination {
	if x != nil {
		return x.Destination
	}
	return nil
}

func (x *InflightFund) GetNobleDestination() *NobleEndpoint {
	if x, ok := x.GetDestination().(*InflightFund_NobleDestination); ok {
		return x.NobleDestination
	}
	return nil
}

func (x *InflightFund) GetRemoteDestination() *RemotePosition {
	if x, ok := x.GetDestination().(*InflightFund_RemoteDestination); ok {
		return x.RemoteDestination
	}
	return nil
}

func (x *InflightFund) GetInitiatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.InitiatedAt
	}
	return nil
}

func (x *InflightFund) GetExpectedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpectedAt
	}
	return nil
}

func (x *InflightFund) GetStatus() InflightStatus {
	if x != nil {
		return x.Status
	}
	return InflightStatus_INFLIGHT_PENDING
}

func (x *InflightFund) GetValueAtInitiation() string {
	if x != nil {
		return x.ValueAtInitiation
	}
	return ""
}

func (x *InflightFund) GetProviderTracking() *ProviderTrackingInfo {
	if x != nil {
		return x.ProviderTracking
	}
	return nil
}

type isInflightFund_Origin interface {
	isInflightFund_Origin()
}

type InflightFund_NobleOrigin struct {
	// Origin is Noble
	NobleOrigin *NobleEndpoint `protobuf:"bytes,4,opt,name=noble_origin,json=nobleOrigin,proto3,oneof"`
}

type InflightFund_RemoteOrigin struct {
	// Origin is a remote position (withdrawing USDN from it)
	RemoteOrigin *RemotePosition `protobuf:"bytes,5,opt,name=remote_origin,json=remoteOrigin,proto3,oneof"`
}

func (*InflightFund_NobleOrigin) isInflightFund_Origin() {}

func (*InflightFund_RemoteOrigin) isInflightFund_Origin() {}

type isInflightFund_Destination interface {
	isInflightFund_Destination()
}

type InflightFund_NobleDestination struct {
	// Destination is Noble
	NobleDestination *NobleEndpoint `protobuf:"bytes,6,opt,name=noble_destination,json=nobleDestination,proto3,oneof"`
}

type InflightFund_RemoteDestination struct {
	// Destination is a remote position (depositing USDN to it)
	RemoteDestination *RemotePosition `protobuf:"bytes,7,opt,name=remote_destination,json=remoteDestination,proto3,oneof"`
}

func (*InflightFund_NobleDestination) isInflightFund_Destination() {}

func (*InflightFund_RemoteDestination) isInflightFund_Destination() {}

// NobleEndpoint represents Noble as an origin or destination
type NobleEndpoint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Purpose/context of the operation (deposit, withdrawal, rebalance)
	OperationType OperationType `protobuf:"varint,1,opt,name=operation_type,json=operationType,proto3,enum=noble.dollar.vaults.v2.OperationType" json:"operation_type,omitempty"`
}

func (x *NobleEndpoint) Reset() {
	*x = NobleEndpoint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NobleEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NobleEndpoint) ProtoMessage() {}

// Deprecated: Use NobleEndpoint.ProtoReflect.Descriptor instead.
func (*NobleEndpoint) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{3}
}

func (x *NobleEndpoint) GetOperationType() OperationType {
	if x != nil {
		return x.OperationType
	}
	return OperationType_OPERATION_TYPE_DEPOSIT
}

// ProviderTrackingInfo contains provider-specific tracking data
type ProviderTrackingInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to TrackingInfo:
	//
	//	*ProviderTrackingInfo_HyperlaneTracking
	TrackingInfo isProviderTrackingInfo_TrackingInfo `protobuf_oneof:"tracking_info"`
}

func (x *ProviderTrackingInfo) Reset() {
	*x = ProviderTrackingInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ProviderTrackingInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProviderTrackingInfo) ProtoMessage() {}

// Deprecated: Use ProviderTrackingInfo.ProtoReflect.Descriptor instead.
func (*ProviderTrackingInfo) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{4}
}

func (x *ProviderTrackingInfo) GetTrackingInfo() isProviderTrackingInfo_TrackingInfo {
	if x != nil {
		return x.TrackingInfo
	}
	return nil
}

func (x *ProviderTrackingInfo) GetHyperlaneTracking() *HyperlaneTrackingInfo {
	if x, ok := x.GetTrackingInfo().(*ProviderTrackingInfo_HyperlaneTracking); ok {
		return x.HyperlaneTracking
	}
	return nil
}

type isProviderTrackingInfo_TrackingInfo interface {
	isProviderTrackingInfo_TrackingInfo()
}

type ProviderTrackingInfo_HyperlaneTracking struct {
	// Hyperlane-specific tracking information
	HyperlaneTracking *HyperlaneTrackingInfo `protobuf:"bytes,1,opt,name=hyperlane_tracking,json=hyperlaneTracking,proto3,oneof"` // Future: IBC tracking could be added here
}

func (*ProviderTrackingInfo_HyperlaneTracking) isProviderTrackingInfo_TrackingInfo() {}

// HyperlaneTrackingInfo contains Hyperlane-specific tracking data
type HyperlaneTrackingInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Hyperlane message ID
	MessageId []byte `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Origin domain
	OriginDomain uint32 `protobuf:"varint,2,opt,name=origin_domain,json=originDomain,proto3" json:"origin_domain,omitempty"`
	// Destination domain
	DestinationDomain uint32 `protobuf:"varint,3,opt,name=destination_domain,json=destinationDomain,proto3" json:"destination_domain,omitempty"`
	// Message nonce
	Nonce uint64 `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Transaction hash on origin chain
	OriginTxHash string `protobuf:"bytes,5,opt,name=origin_tx_hash,json=originTxHash,proto3" json:"origin_tx_hash,omitempty"`
	// Transaction hash on destination chain
	DestinationTxHash string `protobuf:"bytes,6,opt,name=destination_tx_hash,json=destinationTxHash,proto3" json:"destination_tx_hash,omitempty"`
	// Whether message has been processed
	Processed bool `protobuf:"varint,7,opt,name=processed,proto3" json:"processed,omitempty"`
}

func (x *HyperlaneTrackingInfo) Reset() {
	*x = HyperlaneTrackingInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HyperlaneTrackingInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HyperlaneTrackingInfo) ProtoMessage() {}

// Deprecated: Use HyperlaneTrackingInfo.ProtoReflect.Descriptor instead.
func (*HyperlaneTrackingInfo) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{5}
}

func (x *HyperlaneTrackingInfo) GetMessageId() []byte {
	if x != nil {
		return x.MessageId
	}
	return nil
}

func (x *HyperlaneTrackingInfo) GetOriginDomain() uint32 {
	if x != nil {
		return x.OriginDomain
	}
	return 0
}

func (x *HyperlaneTrackingInfo) GetDestinationDomain() uint32 {
	if x != nil {
		return x.DestinationDomain
	}
	return 0
}

func (x *HyperlaneTrackingInfo) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *HyperlaneTrackingInfo) GetOriginTxHash() string {
	if x != nil {
		return x.OriginTxHash
	}
	return ""
}

func (x *HyperlaneTrackingInfo) GetDestinationTxHash() string {
	if x != nil {
		return x.DestinationTxHash
	}
	return ""
}

func (x *HyperlaneTrackingInfo) GetProcessed() bool {
	if x != nil {
		return x.Processed
	}
	return false
}

// NAVOracleUpdate represents an oracle price update received via cross-chain messaging
type NAVOracleUpdate struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Position identifier this update is for
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Current share price
	SharePrice string `protobuf:"bytes,2,opt,name=share_price,json=sharePrice,proto3" json:"share_price,omitempty"`
	// Number of shares held
	SharesHeld string `protobuf:"bytes,3,opt,name=shares_held,json=sharesHeld,proto3" json:"shares_held,omitempty"`
	// Timestamp of the update
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,5,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Message ID (Hyperlane message ID or IBC packet)
	MessageId string `protobuf:"bytes,6,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Update status
	Status OracleUpdateStatus `protobuf:"varint,7,opt,name=status,proto3,enum=noble.dollar.vaults.v2.OracleUpdateStatus" json:"status,omitempty"`
}

func (x *NAVOracleUpdate) Reset() {
	*x = NAVOracleUpdate{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NAVOracleUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NAVOracleUpdate) ProtoMessage() {}

// Deprecated: Use NAVOracleUpdate.ProtoReflect.Descriptor instead.
func (*NAVOracleUpdate) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{6}
}

func (x *NAVOracleUpdate) GetPositionId() uint64 {
	if x != nil {
		return x.PositionId
	}
	return 0
}

func (x *NAVOracleUpdate) GetSharePrice() string {
	if x != nil {
		return x.SharePrice
	}
	return ""
}

func (x *NAVOracleUpdate) GetSharesHeld() string {
	if x != nil {
		return x.SharesHeld
	}
	return ""
}

func (x *NAVOracleUpdate) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *NAVOracleUpdate) GetSourceChain() string {
	if x != nil {
		return x.SourceChain
	}
	return ""
}

func (x *NAVOracleUpdate) GetMessageId() string {
	if x != nil {
		return x.MessageId
	}
	return ""
}

func (x *NAVOracleUpdate) GetStatus() OracleUpdateStatus {
	if x != nil {
		return x.Status
	}
	return OracleUpdateStatus_ORACLE_UPDATE_VALIDATED
}

// PositionOracleConfig stores oracle configuration for a position
type PositionOracleConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Unique position identifier
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Expected origin mailbox/channel
	OriginIdentifier string `protobuf:"bytes,2,opt,name=origin_identifier,json=originIdentifier,proto3" json:"origin_identifier,omitempty"`
	// Maximum age before data is considered stale (seconds)
	MaxStaleness int64 `protobuf:"varint,3,opt,name=max_staleness,json=maxStaleness,proto3" json:"max_staleness,omitempty"`
	// Authorized oracle contract address on remote chain
	OracleContract string `protobuf:"bytes,4,opt,name=oracle_contract,json=oracleContract,proto3" json:"oracle_contract,omitempty"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,5,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Last update timestamp
	LastUpdate *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"`
	// Provider type (HYPERLANE, IBC)
	ProviderType ProviderType `protobuf:"varint,7,opt,name=provider_type,json=providerType,proto3,enum=noble.dollar.vaults.v2.ProviderType" json:"provider_type,omitempty"`
}

func (x *PositionOracleConfig) Reset() {
	*x = PositionOracleConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PositionOracleConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PositionOracleConfig) ProtoMessage() {}

// Deprecated: Use PositionOracleConfig.ProtoReflect.Descriptor instead.
func (*PositionOracleConfig) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{7}
}

func (x *PositionOracleConfig) GetPositionId() uint64 {
	if x != nil {
		return x.PositionId
	}
	return 0
}

func (x *PositionOracleConfig) GetOriginIdentifier() string {
	if x != nil {
		return x.OriginIdentifier
	}
	return ""
}

func (x *PositionOracleConfig) GetMaxStaleness() int64 {
	if x != nil {
		return x.MaxStaleness
	}
	return 0
}

func (x *PositionOracleConfig) GetOracleContract() string {
	if x != nil {
		return x.OracleContract
	}
	return ""
}

func (x *PositionOracleConfig) GetSourceChain() string {
	if x != nil {
		return x.SourceChain
	}
	return ""
}

func (x *PositionOracleConfig) GetLastUpdate() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUpdate
	}
	return nil
}

func (x *PositionOracleConfig) GetProviderType() ProviderType {
	if x != nil {
		return x.ProviderType
	}
	return ProviderType_PROVIDER_TYPE_HYPERLANE
}

// CrossChainPositionSnapshot provides a snapshot of all cross-chain positions
type CrossChainPositionSnapshot struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Total value of all remote positions
	TotalRemoteValue string `protobuf:"bytes,1,opt,name=total_remote_value,json=totalRemoteValue,proto3" json:"total_remote_value,omitempty"`
	// Total value of inflight funds
	TotalInflightValue string `protobuf:"bytes,2,opt,name=total_inflight_value,json=totalInflightValue,proto3" json:"total_inflight_value,omitempty"`
	// Number of active remote positions
	ActivePositions int64 `protobuf:"varint,3,opt,name=active_positions,json=activePositions,proto3" json:"active_positions,omitempty"`
	// Number of positions with stale data
	StalePositions int64 `protobuf:"varint,4,opt,name=stale_positions,json=stalePositions,proto3" json:"stale_positions,omitempty"`
	// Snapshot block height
	BlockHeight int64 `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Breakdown by route
	ValueByRoute map[uint32]string `protobuf:"bytes,6,rep,name=value_by_route,json=valueByRoute,proto3" json:"value_by_route,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *CrossChainPositionSnapshot) Reset() {
	*x = CrossChainPositionSnapshot{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CrossChainPositionSnapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CrossChainPositionSnapshot) ProtoMessage() {}

// Deprecated: Use CrossChainPositionSnapshot.ProtoReflect.Descriptor instead.
func (*CrossChainPositionSnapshot) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{8}
}

func (x *CrossChainPositionSnapshot) GetTotalRemoteValue() string {
	if x != nil {
		return x.TotalRemoteValue
	}
	return ""
}

func (x *CrossChainPositionSnapshot) GetTotalInflightValue() string {
	if x != nil {
		return x.TotalInflightValue
	}
	return ""
}

func (x *CrossChainPositionSnapshot) GetActivePositions() int64 {
	if x != nil {
		return x.ActivePositions
	}
	return 0
}

func (x *CrossChainPositionSnapshot) GetStalePositions() int64 {
	if x != nil {
		return x.StalePositions
	}
	return 0
}

func (x *CrossChainPositionSnapshot) GetBlockHeight() int64 {
	if x != nil {
		return x.BlockHeight
	}
	return 0
}

func (x *CrossChainPositionSnapshot) GetValueByRoute() map[uint32]string {
	if x != nil {
		return x.ValueByRoute
	}
	return nil
}

// CrossChainConfig defines global configuration for cross-chain operations
type CrossChainConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Maximum total remote position value as percentage of vault (basis points)
	MaxRemoteExposure int32 `protobuf:"varint,1,opt,name=max_remote_exposure,json=maxRemoteExposure,proto3" json:"max_remote_exposure,omitempty"`
	// Default operation timeout (seconds)
	DefaultTimeout int64 `protobuf:"varint,2,opt,name=default_timeout,json=defaultTimeout,proto3" json:"default_timeout,omitempty"`
	// Position update frequency (seconds)
	UpdateFrequency int64 `protobuf:"varint,3,opt,name=update_frequency,json=updateFrequency,proto3" json:"update_frequency,omitempty"`
	// Maximum number of remote positions
	MaxRemotePositions uint32 `protobuf:"varint,4,opt,name=max_remote_positions,json=maxRemotePositions,proto3" json:"max_remote_positions,omitempty"`
	// Allowed chains (can be Hyperlane domains or IBC chain IDs)
	AllowedChains []string `protobuf:"bytes,5,rep,name=allowed_chains,json=allowedChains,proto3" json:"allowed_chains,omitempty"`
	// Whether cross-chain operations are enabled
	Enabled bool `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Maximum duration funds can be inflight (seconds)
	MaxInflightDuration int64 `protobuf:"varint,7,opt,name=max_inflight_duration,json=maxInflightDuration,proto3" json:"max_inflight_duration,omitempty"`
	// Maximum total value allowed inflight
	MaxInflightValue string `protobuf:"bytes,8,opt,name=max_inflight_value,json=maxInflightValue,proto3" json:"max_inflight_value,omitempty"`
	// Supported providers (currently only HYPERLANE)
	SupportedProviders []ProviderType `protobuf:"varint,9,rep,packed,name=supported_providers,json=supportedProviders,proto3,enum=noble.dollar.vaults.v2.ProviderType" json:"supported_providers,omitempty"`
}

func (x *CrossChainConfig) Reset() {
	*x = CrossChainConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CrossChainConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CrossChainConfig) ProtoMessage() {}

// Deprecated: Use CrossChainConfig.ProtoReflect.Descriptor instead.
func (*CrossChainConfig) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{9}
}

func (x *CrossChainConfig) GetMaxRemoteExposure() int32 {
	if x != nil {
		return x.MaxRemoteExposure
	}
	return 0
}

func (x *CrossChainConfig) GetDefaultTimeout() int64 {
	if x != nil {
		return x.DefaultTimeout
	}
	return 0
}

func (x *CrossChainConfig) GetUpdateFrequency() int64 {
	if x != nil {
		return x.UpdateFrequency
	}
	return 0
}

func (x *CrossChainConfig) GetMaxRemotePositions() uint32 {
	if x != nil {
		return x.MaxRemotePositions
	}
	return 0
}

func (x *CrossChainConfig) GetAllowedChains() []string {
	if x != nil {
		return x.AllowedChains
	}
	return nil
}

func (x *CrossChainConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *CrossChainConfig) GetMaxInflightDuration() int64 {
	if x != nil {
		return x.MaxInflightDuration
	}
	return 0
}

func (x *CrossChainConfig) GetMaxInflightValue() string {
	if x != nil {
		return x.MaxInflightValue
	}
	return ""
}

func (x *CrossChainConfig) GetSupportedProviders() []ProviderType {
	if x != nil {
		return x.SupportedProviders
	}
	return nil
}

// StaleInflightAlert represents an alert for inflight funds exceeding expected duration
type StaleInflightAlert struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Route ID
	RouteId uint32 `protobuf:"varint,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Transaction ID
	TransactionId string `protobuf:"bytes,2,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	// Hours overdue
	HoursOverdue float64 `protobuf:"fixed64,3,opt,name=hours_overdue,json=hoursOverdue,proto3" json:"hours_overdue,omitempty"`
	// Alert timestamp
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Amount stuck in transit
	Amount string `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *StaleInflightAlert) Reset() {
	*x = StaleInflightAlert{}
	if protoimpl.UnsafeEnabled {
		mi := &file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StaleInflightAlert) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StaleInflightAlert) ProtoMessage() {}

// Deprecated: Use StaleInflightAlert.ProtoReflect.Descriptor instead.
func (*StaleInflightAlert) Descriptor() ([]byte, []int) {
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP(), []int{10}
}

func (x *StaleInflightAlert) GetRouteId() uint32 {
	if x != nil {
		return x.RouteId
	}
	return 0
}

func (x *StaleInflightAlert) GetTransactionId() string {
	if x != nil {
		return x.TransactionId
	}
	return ""
}

func (x *StaleInflightAlert) GetHoursOverdue() float64 {
	if x != nil {
		return x.HoursOverdue
	}
	return 0
}

func (x *StaleInflightAlert) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *StaleInflightAlert) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

var File_noble_dollar_vaults_v2_cross_chain_proto protoreflect.FileDescriptor

var file_noble_dollar_vaults_v2_cross_chain_proto_rawDesc = []byte{
	0x0a, 0x28, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2f, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2f, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x2f, 0x76, 0x32, 0x2f, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x5f, 0x63,
	0x68, 0x61, 0x69, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x16, 0x6e, 0x6f, 0x62, 0x6c,
	0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e,
	0x76, 0x32, 0x1a, 0x11, 0x61, 0x6d, 0x69, 0x6e, 0x6f, 0x2f, 0x61, 0x6d, 0x69, 0x6e, 0x6f, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x5f, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x14, 0x67, 0x6f, 0x67, 0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1d, 0x68, 0x79, 0x70, 0x65, 0x72, 0x6c, 0x61,
	0x6e, 0x65, 0x2f, 0x77, 0x61, 0x72, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc9, 0x03, 0x0a, 0x0f, 0x43, 0x72, 0x6f, 0x73, 0x73,
	0x43, 0x68, 0x61, 0x69, 0x6e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x64, 0x0a, 0x0b, 0x68, 0x79,
	0x70, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x43, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x3b, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
	0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x63, 0x70, 0x2d, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x2f, 0x68, 0x79, 0x70, 0x65, 0x72, 0x6c, 0x61, 0x6e, 0x65, 0x2d, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x75, 0x74, 0x69, 0x6c, 0x2e, 0x48, 0x65, 0x78, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x52, 0x0a, 0x68, 0x79, 0x70, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x49, 0x64,
	0x12, 0x73, 0x0a, 0x13, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x5f, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x5f, 0x68, 0x6f, 0x6f, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x43, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x3b, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x62, 0x63, 0x70, 0x2d, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x2f, 0x68, 0x79, 0x70, 0x65, 0x72, 0x6c, 0x61, 0x6e, 0x65, 0x2d, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x2f, 0x75, 0x74, 0x69, 0x6c, 0x2e, 0x48, 0x65, 0x78, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x11, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x43, 0x68, 0x61, 0x69,
	0x6e, 0x48, 0x6f, 0x6f, 0x6b, 0x12, 0x7b, 0x0a, 0x17, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x5f,
	0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x43, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x3b,
	0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x63, 0x70, 0x2d, 0x69,
	0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x68, 0x79, 0x70, 0x65, 0x72,
	0x6c, 0x61, 0x6e, 0x65, 0x2d, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x75, 0x74, 0x69, 0x6c,
	0x2e, 0x48, 0x65, 0x78, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x15, 0x72, 0x65, 0x6d,
	0x6f, 0x74, 0x65, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x12, 0x5e, 0x0a, 0x12, 0x6d, 0x61, 0x78, 0x5f, 0x69, 0x6e, 0x66, 0x6c, 0x69, 0x67,
	0x68, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d,
	0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01,
	0x52, 0x10, 0x6d, 0x61, 0x78, 0x49, 0x6e, 0x66, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x56, 0x61, 0x6c,
	0x75, 0x65, 0x22, 0x88, 0x06, 0x0a, 0x0e, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x6f, 0x73,
	0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x64, 0x0a, 0x0b, 0x68, 0x79, 0x70, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x43, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x3b, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62,
	0x63, 0x70, 0x2d, 0x69, 0x6e, 0x6e, 0x6f, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x68,
	0x79, 0x70, 0x65, 0x72, 0x6c, 0x61, 0x6e, 0x65, 0x2d, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f,
	0x75, 0x74, 0x69, 0x6c, 0x2e, 0x48, 0x65, 0x78, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52,
	0x0a, 0x68, 0x79, 0x70, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x49, 0x64, 0x12, 0x68, 0x0a, 0x0d, 0x76,
	0x61, 0x75, 0x6c, 0x74, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0c, 0x42, 0x43, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x3b, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x62, 0x63, 0x70, 0x2d, 0x69, 0x6e, 0x6e, 0x6f, 0x76,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x68, 0x79, 0x70, 0x65, 0x72, 0x6c, 0x61, 0x6e, 0x65,
	0x2d, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x75, 0x74, 0x69, 0x6c, 0x2e, 0x48, 0x65, 0x78,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0c, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x51, 0x0a, 0x0b, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x5f,
	0x68, 0x65, 0x6c, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f,
	0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0a, 0x73, 0x68,
	0x61, 0x72, 0x65, 0x73, 0x48, 0x65, 0x6c, 0x64, 0x12, 0x4e, 0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e,
	0x63, 0x69, 0x70, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69,
	0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x09, 0x70,
	0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x12, 0x57, 0x0a, 0x0b, 0x73, 0x68, 0x61, 0x72,
	0x65, 0x5f, 0x70, 0x72, 0x69, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x36, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b,
	0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44,
	0x65, 0x63, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63,
	0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0a, 0x73, 0x68, 0x61, 0x72, 0x65, 0x50, 0x72, 0x69, 0x63,
	0x65, 0x12, 0x51, 0x0a, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74,
	0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x12, 0x45, 0x0a, 0x0b, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52,
	0x0a, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x44, 0x0a, 0x06, 0x73,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x6e, 0x6f,
	0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74,
	0x73, 0x2e, 0x76, 0x32, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x6f, 0x73, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x12, 0x25, 0x0a, 0x0e, 0x6f, 0x72, 0x61, 0x63, 0x6c, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x6f, 0x72, 0x61, 0x63, 0x6c,
	0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x6d, 0x61, 0x78, 0x5f,
	0x73, 0x74, 0x61, 0x6c, 0x65, 0x6e, 0x65, 0x73, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x03, 0x52,
	0x0c, 0x6d, 0x61, 0x78, 0x53, 0x74, 0x61, 0x6c, 0x65, 0x6e, 0x65, 0x73, 0x73, 0x22, 0xff, 0x06,
	0x0a, 0x0c, 0x49, 0x6e, 0x66, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x46, 0x75, 0x6e, 0x64, 0x12, 0x0e,
	0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x12, 0x25,
	0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x48, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49,
	0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12,
	0x4a, 0x0a, 0x0c, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x5f, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f,
	0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x2e, 0x4e,
	0x6f, 0x62, 0x6c, 0x65, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x0b,
	0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x4f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x12, 0x4d, 0x0a, 0x0d, 0x72,
	0x65, 0x6d, 0x6f, 0x74, 0x65, 0x5f, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61,
	0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x2e, 0x52, 0x65, 0x6d, 0x6f,
	0x74, 0x65, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x0c, 0x72, 0x65,
	0x6d, 0x6f, 0x74, 0x65, 0x4f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x12, 0x54, 0x0a, 0x11, 0x6e, 0x6f,
	0x62, 0x6c, 0x65, 0x5f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f,
	0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x2e, 0x4e,
	0x6f, 0x62, 0x6c, 0x65, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x48, 0x01, 0x52, 0x10,
	0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x57, 0x0a, 0x12, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x5f, 0x64, 0x65, 0x73, 0x74, 0x69,
	0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6e,
	0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c,
	0x74, 0x73, 0x2e, 0x76, 0x32, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x6f, 0x73, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x48, 0x01, 0x52, 0x11, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x44, 0x65,
	0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x47, 0x0a, 0x0c, 0x69, 0x6e, 0x69,
	0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f,
	0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x0b, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64,
	0x41, 0x74, 0x12, 0x45, 0x0a, 0x0b, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x5f, 0x61,
	0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x0a, 0x65,
	0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x3e, 0x0a, 0x06, 0x73, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x6e, 0x6f, 0x62, 0x6c,
	0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e,
	0x76, 0x32, 0x2e, 0x49, 0x6e, 0x66, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x60, 0x0a, 0x13, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x5f, 0x61, 0x74, 0x5f, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74,
	0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x11, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x41,
	0x74, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x59, 0x0a, 0x11, 0x70,
	0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67,
	0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x2e,
	0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67,
	0x49, 0x6e, 0x66, 0x6f, 0x52, 0x10, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x54, 0x72,
	0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x42, 0x08, 0x0a, 0x06, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e,
	0x42, 0x0d, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22,
	0x5d, 0x0a, 0x0d, 0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74,
	0x12, 0x4c, 0x0a, 0x0e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79,
	0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x25, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65,
	0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76,
	0x32, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52,
	0x0d, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x22, 0x87,
	0x01, 0x0a, 0x14, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x54, 0x72, 0x61, 0x63, 0x6b,
	0x69, 0x6e, 0x67, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x5e, 0x0a, 0x12, 0x68, 0x79, 0x70, 0x65, 0x72,
	0x6c, 0x61, 0x6e, 0x65, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c,
	0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x2e, 0x48, 0x79, 0x70,
	0x65, 0x72, 0x6c, 0x61, 0x6e, 0x65, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x49, 0x6e,
	0x66, 0x6f, 0x48, 0x00, 0x52, 0x11, 0x68, 0x79, 0x70, 0x65, 0x72, 0x6c, 0x61, 0x6e, 0x65, 0x54,
	0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x42, 0x0f, 0x0a, 0x0d, 0x74, 0x72, 0x61, 0x63, 0x6b,
	0x69, 0x6e, 0x67, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x22, 0x94, 0x02, 0x0a, 0x15, 0x48, 0x79, 0x70,
	0x65, 0x72, 0x6c, 0x61, 0x6e, 0x65, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x49, 0x6e,
	0x66, 0x6f, 0x12, 0x1d, 0x0a, 0x0a, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x49,
	0x64, 0x12, 0x23, 0x0a, 0x0d, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x5f, 0x64, 0x6f, 0x6d, 0x61,
	0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e,
	0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x2d, 0x0a, 0x12, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x11, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44,
	0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x12, 0x24, 0x0a, 0x0e, 0x6f,
	0x72, 0x69, 0x67, 0x69, 0x6e, 0x5f, 0x74, 0x78, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0c, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x54, 0x78, 0x48, 0x61, 0x73,
	0x68, 0x12, 0x2e, 0x0a, 0x13, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x5f, 0x74, 0x78, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11,
	0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x78, 0x48, 0x61, 0x73,
	0x68, 0x12, 0x1c, 0x0a, 0x09, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x22,
	0xa8, 0x03, 0x0a, 0x0f, 0x4e, 0x41, 0x56, 0x4f, 0x72, 0x61, 0x63, 0x6c, 0x65, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x49, 0x64, 0x12, 0x57, 0x0a, 0x0b, 0x73, 0x68, 0x61, 0x72, 0x65, 0x5f, 0x70, 0x72,
	0x69, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x36, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f,
	0x6d, 0x61, 0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0xd2, 0xb4,
	0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x44, 0x65, 0x63, 0xa8, 0xe7, 0xb0, 0x2a,
	0x01, 0x52, 0x0a, 0x73, 0x68, 0x61, 0x72, 0x65, 0x50, 0x72, 0x69, 0x63, 0x65, 0x12, 0x51, 0x0a,
	0x0b, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x5f, 0x68, 0x65, 0x6c, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e,
	0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8,
	0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x0a, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x48, 0x65, 0x6c, 0x64,
	0x12, 0x42, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42,
	0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x63,
	0x68, 0x61, 0x69, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x43, 0x68, 0x61, 0x69, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x6d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x49, 0x64, 0x12, 0x42, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2a, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x2e,
	0x4f, 0x72, 0x61, 0x63, 0x6c, 0x65, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0xe7, 0x02, 0x0a, 0x14, 0x50,
	0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x72, 0x61, 0x63, 0x6c, 0x65, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x12, 0x1f, 0x0a, 0x0b, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x49, 0x64, 0x12, 0x2b, 0x0a, 0x11, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x5f, 0x69,
	0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x10, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65,
	0x72, 0x12, 0x23, 0x0a, 0x0d, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x74, 0x61, 0x6c, 0x65, 0x6e, 0x65,
	0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x6d, 0x61, 0x78, 0x53, 0x74, 0x61,
	0x6c, 0x65, 0x6e, 0x65, 0x73, 0x73, 0x12, 0x27, 0x0a, 0x0f, 0x6f, 0x72, 0x61, 0x63, 0x6c, 0x65,
	0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0e, 0x6f, 0x72, 0x61, 0x63, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x74, 0x12,
	0x21, 0x0a, 0x0c, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x43, 0x68, 0x61,
	0x69, 0x6e, 0x12, 0x45, 0x0a, 0x0b, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74,
	0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x42, 0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x0a, 0x6c,
	0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x49, 0x0a, 0x0d, 0x70, 0x72, 0x6f,
	0x76, 0x69, 0x64, 0x65, 0x72, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x24, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e,
	0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64,
	0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0c, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72,
	0x54, 0x79, 0x70, 0x65, 0x22, 0x84, 0x04, 0x0a, 0x1a, 0x43, 0x72, 0x6f, 0x73, 0x73, 0x43, 0x68,
	0x61, 0x69, 0x6e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x6e, 0x61, 0x70, 0x73,
	0x68, 0x6f, 0x74, 0x12, 0x5e, 0x0a, 0x12, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x72, 0x65, 0x6d,
	0x6f, 0x74, 0x65, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4,
	0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a,
	0x01, 0x52, 0x10, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x56, 0x61,
	0x6c, 0x75, 0x65, 0x12, 0x62, 0x0a, 0x14, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x69, 0x6e, 0x66,
	0x6c, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74,
	0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7,
	0xb0, 0x2a, 0x01, 0x52, 0x12, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6c, 0x69, 0x67,
	0x68, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x29, 0x0a, 0x10, 0x61, 0x63, 0x74, 0x69, 0x76,
	0x65, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x0f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x12, 0x27, 0x0a, 0x0f, 0x73, 0x74, 0x61, 0x6c, 0x65, 0x5f, 0x70, 0x6f, 0x73, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0e, 0x73, 0x74, 0x61,
	0x6c, 0x65, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x62,
	0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x0b, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x6a,
	0x0a, 0x0e, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x62, 0x79, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65,
	0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x44, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64,
	0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x2e,
	0x43, 0x72, 0x6f, 0x73, 0x73, 0x43, 0x68, 0x61, 0x69, 0x6e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x42, 0x79, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0c, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x42, 0x79, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x1a, 0x3f, 0x0a, 0x11, 0x56, 0x61,
	0x6c, 0x75, 0x65, 0x42, 0x79, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12,
	0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x6b, 0x65,
	0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xf4, 0x03, 0x0a, 0x10,
	0x43, 0x72, 0x6f, 0x73, 0x73, 0x43, 0x68, 0x61, 0x69, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x12, 0x2e, 0x0a, 0x13, 0x6d, 0x61, 0x78, 0x5f, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x5f, 0x65,
	0x78, 0x70, 0x6f, 0x73, 0x75, 0x72, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x11, 0x6d,
	0x61, 0x78, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x45, 0x78, 0x70, 0x6f, 0x73, 0x75, 0x72, 0x65,
	0x12, 0x27, 0x0a, 0x0f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65,
	0x6f, 0x75, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0e, 0x64, 0x65, 0x66, 0x61, 0x75,
	0x6c, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x29, 0x0a, 0x10, 0x75, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x5f, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x03, 0x52, 0x0f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x46, 0x72, 0x65, 0x71, 0x75,
	0x65, 0x6e, 0x63, 0x79, 0x12, 0x30, 0x0a, 0x14, 0x6d, 0x61, 0x78, 0x5f, 0x72, 0x65, 0x6d, 0x6f,
	0x74, 0x65, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x12, 0x6d, 0x61, 0x78, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x6f, 0x73,
	0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65,
	0x64, 0x5f, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0d,
	0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x43, 0x68, 0x61, 0x69, 0x6e, 0x73, 0x12, 0x18, 0x0a,
	0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07,
	0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x32, 0x0a, 0x15, 0x6d, 0x61, 0x78, 0x5f, 0x69,
	0x6e, 0x66, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x03, 0x52, 0x13, 0x6d, 0x61, 0x78, 0x49, 0x6e, 0x66, 0x6c, 0x69,
	0x67, 0x68, 0x74, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x5e, 0x0a, 0x12, 0x6d,
	0x61, 0x78, 0x5f, 0x69, 0x6e, 0x66, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75,
	0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f,
	0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61,
	0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2e, 0x49, 0x6e, 0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x10, 0x6d, 0x61, 0x78, 0x49, 0x6e,
	0x66, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x55, 0x0a, 0x13, 0x73,
	0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,
	0x72, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65,
	0x2e, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76,
	0x32, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x52, 0x12,
	0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,
	0x72, 0x73, 0x22, 0x89, 0x02, 0x0a, 0x12, 0x53, 0x74, 0x61, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6c,
	0x69, 0x67, 0x68, 0x74, 0x41, 0x6c, 0x65, 0x72, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x72, 0x6f, 0x75,
	0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x72, 0x6f, 0x75,
	0x74, 0x65, 0x49, 0x64, 0x12, 0x25, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x74, 0x72,
	0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x68,
	0x6f, 0x75, 0x72, 0x73, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x64, 0x75, 0x65, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x01, 0x52, 0x0c, 0x68, 0x6f, 0x75, 0x72, 0x73, 0x4f, 0x76, 0x65, 0x72, 0x64, 0x75, 0x65,
	0x12, 0x42, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42,
	0x08, 0xc8, 0xde, 0x1f, 0x00, 0x90, 0xdf, 0x1f, 0x01, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x12, 0x48, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x30, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x49, 0x6e, 0x74, 0xd2, 0xb4, 0x2d, 0x0a, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x49, 0x6e,
	0x74, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x2a, 0x90,
	0x01, 0x0a, 0x14, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1a, 0x0a, 0x16, 0x52, 0x45, 0x4d, 0x4f, 0x54,
	0x45, 0x5f, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x56,
	0x45, 0x10, 0x00, 0x12, 0x1f, 0x0a, 0x1b, 0x52, 0x45, 0x4d, 0x4f, 0x54, 0x45, 0x5f, 0x50, 0x4f,
	0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x57, 0x49, 0x54, 0x48, 0x44, 0x52, 0x41, 0x57, 0x49,
	0x4e, 0x47, 0x10, 0x01, 0x12, 0x1a, 0x0a, 0x16, 0x52, 0x45, 0x4d, 0x4f, 0x54, 0x45, 0x5f, 0x50,
	0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x43, 0x4c, 0x4f, 0x53, 0x45, 0x44, 0x10, 0x02,
	0x12, 0x19, 0x0a, 0x15, 0x52, 0x45, 0x4d, 0x4f, 0x54, 0x45, 0x5f, 0x50, 0x4f, 0x53, 0x49, 0x54,
	0x49, 0x4f, 0x4e, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x03, 0x1a, 0x04, 0x88, 0xa3, 0x1e,
	0x00, 0x2a, 0x6e, 0x0a, 0x0d, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x1a, 0x0a, 0x16, 0x4f, 0x50, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x44, 0x45, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x10, 0x00, 0x12, 0x1d,
	0x0a, 0x19, 0x4f, 0x50, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x57, 0x49, 0x54, 0x48, 0x44, 0x52, 0x41, 0x57, 0x41, 0x4c, 0x10, 0x01, 0x12, 0x1c, 0x0a,
	0x18, 0x4f, 0x50, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x52, 0x45, 0x42, 0x41, 0x4c, 0x41, 0x4e, 0x43, 0x45, 0x10, 0x02, 0x1a, 0x04, 0x88, 0xa3, 0x1e,
	0x00, 0x2a, 0xd6, 0x01, 0x0a, 0x0c, 0x49, 0x6e, 0x66, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x20, 0x0a, 0x1c, 0x49, 0x4e, 0x46, 0x4c, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x44,
	0x45, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x5f, 0x54, 0x4f, 0x5f, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49,
	0x4f, 0x4e, 0x10, 0x00, 0x12, 0x25, 0x0a, 0x21, 0x49, 0x4e, 0x46, 0x4c, 0x49, 0x47, 0x48, 0x54,
	0x5f, 0x57, 0x49, 0x54, 0x48, 0x44, 0x52, 0x41, 0x57, 0x41, 0x4c, 0x5f, 0x46, 0x52, 0x4f, 0x4d,
	0x5f, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x01, 0x12, 0x28, 0x0a, 0x24, 0x49,
	0x4e, 0x46, 0x4c, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x52, 0x45, 0x42, 0x41, 0x4c, 0x41, 0x4e, 0x43,
	0x45, 0x5f, 0x42, 0x45, 0x54, 0x57, 0x45, 0x45, 0x4e, 0x5f, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49,
	0x4f, 0x4e, 0x53, 0x10, 0x02, 0x12, 0x1f, 0x0a, 0x1b, 0x49, 0x4e, 0x46, 0x4c, 0x49, 0x47, 0x48,
	0x54, 0x5f, 0x50, 0x45, 0x4e, 0x44, 0x49, 0x4e, 0x47, 0x5f, 0x44, 0x45, 0x50, 0x4c, 0x4f, 0x59,
	0x4d, 0x45, 0x4e, 0x54, 0x10, 0x03, 0x12, 0x2c, 0x0a, 0x28, 0x49, 0x4e, 0x46, 0x4c, 0x49, 0x47,
	0x48, 0x54, 0x5f, 0x50, 0x45, 0x4e, 0x44, 0x49, 0x4e, 0x47, 0x5f, 0x57, 0x49, 0x54, 0x48, 0x44,
	0x52, 0x41, 0x57, 0x41, 0x4c, 0x5f, 0x44, 0x49, 0x53, 0x54, 0x52, 0x49, 0x42, 0x55, 0x54, 0x49,
	0x4f, 0x4e, 0x10, 0x04, 0x1a, 0x04, 0x88, 0xa3, 0x1e, 0x00, 0x2a, 0x87, 0x01, 0x0a, 0x0e, 0x49,
	0x6e, 0x66, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x14, 0x0a,
	0x10, 0x49, 0x4e, 0x46, 0x4c, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x50, 0x45, 0x4e, 0x44, 0x49, 0x4e,
	0x47, 0x10, 0x00, 0x12, 0x16, 0x0a, 0x12, 0x49, 0x4e, 0x46, 0x4c, 0x49, 0x47, 0x48, 0x54, 0x5f,
	0x43, 0x4f, 0x4e, 0x46, 0x49, 0x52, 0x4d, 0x45, 0x44, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x49,
	0x4e, 0x46, 0x4c, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x4c, 0x45, 0x54, 0x45,
	0x44, 0x10, 0x02, 0x12, 0x13, 0x0a, 0x0f, 0x49, 0x4e, 0x46, 0x4c, 0x49, 0x47, 0x48, 0x54, 0x5f,
	0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x03, 0x12, 0x14, 0x0a, 0x10, 0x49, 0x4e, 0x46, 0x4c,
	0x49, 0x47, 0x48, 0x54, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x4f, 0x55, 0x54, 0x10, 0x04, 0x1a, 0x04,
	0x88, 0xa3, 0x1e, 0x00, 0x2a, 0x6e, 0x0a, 0x12, 0x4f, 0x72, 0x61, 0x63, 0x6c, 0x65, 0x55, 0x70,
	0x64, 0x61, 0x74, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1b, 0x0a, 0x17, 0x4f, 0x52,
	0x41, 0x43, 0x4c, 0x45, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x5f, 0x56, 0x41, 0x4c, 0x49,
	0x44, 0x41, 0x54, 0x45, 0x44, 0x10, 0x00, 0x12, 0x19, 0x0a, 0x15, 0x4f, 0x52, 0x41, 0x43, 0x4c,
	0x45, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x5f, 0x41, 0x50, 0x50, 0x4c, 0x49, 0x45, 0x44,
	0x10, 0x01, 0x12, 0x1a, 0x0a, 0x16, 0x4f, 0x52, 0x41, 0x43, 0x4c, 0x45, 0x5f, 0x55, 0x50, 0x44,
	0x41, 0x54, 0x45, 0x5f, 0x52, 0x45, 0x4a, 0x45, 0x43, 0x54, 0x45, 0x44, 0x10, 0x02, 0x1a, 0x04,
	0x88, 0xa3, 0x1e, 0x00, 0x2a, 0x48, 0x0a, 0x0c, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x1b, 0x0a, 0x17, 0x50, 0x52, 0x4f, 0x56, 0x49, 0x44, 0x45, 0x52,
	0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x48, 0x59, 0x50, 0x45, 0x52, 0x4c, 0x41, 0x4e, 0x45, 0x10,
	0x00, 0x12, 0x15, 0x0a, 0x11, 0x50, 0x52, 0x4f, 0x56, 0x49, 0x44, 0x45, 0x52, 0x5f, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x49, 0x42, 0x43, 0x10, 0x01, 0x1a, 0x04, 0x88, 0xa3, 0x1e, 0x00, 0x42, 0xe1,
	0x01, 0x0a, 0x1a, 0x63, 0x6f, 0x6d, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x64, 0x6f, 0x6c,
	0x6c, 0x61, 0x72, 0x2e, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x76, 0x32, 0x42, 0x0f, 0x43,
	0x72, 0x6f, 0x73, 0x73, 0x43, 0x68, 0x61, 0x69, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01,
	0x5a, 0x37, 0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x78,
	0x79, 0x7a, 0x2f, 0x76, 0x33, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2f,
	0x64, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2f, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x2f, 0x76, 0x32,
	0x3b, 0x76, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x76, 0x32, 0xa2, 0x02, 0x03, 0x4e, 0x44, 0x56, 0xaa,
	0x02, 0x16, 0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x2e, 0x44, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x2e, 0x56,
	0x61, 0x75, 0x6c, 0x74, 0x73, 0x2e, 0x56, 0x32, 0xca, 0x02, 0x16, 0x4e, 0x6f, 0x62, 0x6c, 0x65,
	0x5c, 0x44, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x5c, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x5c, 0x56,
	0x32, 0xe2, 0x02, 0x22, 0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x5c, 0x44, 0x6f, 0x6c, 0x6c, 0x61, 0x72,
	0x5c, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x5c, 0x56, 0x32, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x19, 0x4e, 0x6f, 0x62, 0x6c, 0x65, 0x3a, 0x3a,
	0x44, 0x6f, 0x6c, 0x6c, 0x61, 0x72, 0x3a, 0x3a, 0x56, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x3a, 0x3a,
	0x56, 0x32, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_noble_dollar_vaults_v2_cross_chain_proto_rawDescOnce sync.Once
	file_noble_dollar_vaults_v2_cross_chain_proto_rawDescData = file_noble_dollar_vaults_v2_cross_chain_proto_rawDesc
)

func file_noble_dollar_vaults_v2_cross_chain_proto_rawDescGZIP() []byte {
	file_noble_dollar_vaults_v2_cross_chain_proto_rawDescOnce.Do(func() {
		file_noble_dollar_vaults_v2_cross_chain_proto_rawDescData = protoimpl.X.CompressGZIP(file_noble_dollar_vaults_v2_cross_chain_proto_rawDescData)
	})
	return file_noble_dollar_vaults_v2_cross_chain_proto_rawDescData
}

var file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_noble_dollar_vaults_v2_cross_chain_proto_goTypes = []interface{}{
	(RemotePositionStatus)(0),          // 0: noble.dollar.vaults.v2.RemotePositionStatus
	(OperationType)(0),                 // 1: noble.dollar.vaults.v2.OperationType
	(InflightType)(0),                  // 2: noble.dollar.vaults.v2.InflightType
	(InflightStatus)(0),                // 3: noble.dollar.vaults.v2.InflightStatus
	(OracleUpdateStatus)(0),            // 4: noble.dollar.vaults.v2.OracleUpdateStatus
	(ProviderType)(0),                  // 5: noble.dollar.vaults.v2.ProviderType
	(*CrossChainRoute)(nil),            // 6: noble.dollar.vaults.v2.CrossChainRoute
	(*RemotePosition)(nil),             // 7: noble.dollar.vaults.v2.RemotePosition
	(*InflightFund)(nil),               // 8: noble.dollar.vaults.v2.InflightFund
	(*NobleEndpoint)(nil),              // 9: noble.dollar.vaults.v2.NobleEndpoint
	(*ProviderTrackingInfo)(nil),       // 10: noble.dollar.vaults.v2.ProviderTrackingInfo
	(*HyperlaneTrackingInfo)(nil),      // 11: noble.dollar.vaults.v2.HyperlaneTrackingInfo
	(*NAVOracleUpdate)(nil),            // 12: noble.dollar.vaults.v2.NAVOracleUpdate
	(*PositionOracleConfig)(nil),       // 13: noble.dollar.vaults.v2.PositionOracleConfig
	(*CrossChainPositionSnapshot)(nil), // 14: noble.dollar.vaults.v2.CrossChainPositionSnapshot
	(*CrossChainConfig)(nil),           // 15: noble.dollar.vaults.v2.CrossChainConfig
	(*StaleInflightAlert)(nil),         // 16: noble.dollar.vaults.v2.StaleInflightAlert
	nil,                                // 17: noble.dollar.vaults.v2.CrossChainPositionSnapshot.ValueByRouteEntry
	(*timestamppb.Timestamp)(nil),      // 18: google.protobuf.Timestamp
}
var file_noble_dollar_vaults_v2_cross_chain_proto_depIdxs = []int32{
	18, // 0: noble.dollar.vaults.v2.RemotePosition.last_update:type_name -> google.protobuf.Timestamp
	0,  // 1: noble.dollar.vaults.v2.RemotePosition.status:type_name -> noble.dollar.vaults.v2.RemotePositionStatus
	9,  // 2: noble.dollar.vaults.v2.InflightFund.noble_origin:type_name -> noble.dollar.vaults.v2.NobleEndpoint
	7,  // 3: noble.dollar.vaults.v2.InflightFund.remote_origin:type_name -> noble.dollar.vaults.v2.RemotePosition
	9,  // 4: noble.dollar.vaults.v2.InflightFund.noble_destination:type_name -> noble.dollar.vaults.v2.NobleEndpoint
	7,  // 5: noble.dollar.vaults.v2.InflightFund.remote_destination:type_name -> noble.dollar.vaults.v2.RemotePosition
	18, // 6: noble.dollar.vaults.v2.InflightFund.initiated_at:type_name -> google.protobuf.Timestamp
	18, // 7: noble.dollar.vaults.v2.InflightFund.expected_at:type_name -> google.protobuf.Timestamp
	3,  // 8: noble.dollar.vaults.v2.InflightFund.status:type_name -> noble.dollar.vaults.v2.InflightStatus
	10, // 9: noble.dollar.vaults.v2.InflightFund.provider_tracking:type_name -> noble.dollar.vaults.v2.ProviderTrackingInfo
	1,  // 10: noble.dollar.vaults.v2.NobleEndpoint.operation_type:type_name -> noble.dollar.vaults.v2.OperationType
	11, // 11: noble.dollar.vaults.v2.ProviderTrackingInfo.hyperlane_tracking:type_name -> noble.dollar.vaults.v2.HyperlaneTrackingInfo
	18, // 12: noble.dollar.vaults.v2.NAVOracleUpdate.timestamp:type_name -> google.protobuf.Timestamp
	4,  // 13: noble.dollar.vaults.v2.NAVOracleUpdate.status:type_name -> noble.dollar.vaults.v2.OracleUpdateStatus
	18, // 14: noble.dollar.vaults.v2.PositionOracleConfig.last_update:type_name -> google.protobuf.Timestamp
	5,  // 15: noble.dollar.vaults.v2.PositionOracleConfig.provider_type:type_name -> noble.dollar.vaults.v2.ProviderType
	17, // 16: noble.dollar.vaults.v2.CrossChainPositionSnapshot.value_by_route:type_name -> noble.dollar.vaults.v2.CrossChainPositionSnapshot.ValueByRouteEntry
	5,  // 17: noble.dollar.vaults.v2.CrossChainConfig.supported_providers:type_name -> noble.dollar.vaults.v2.ProviderType
	18, // 18: noble.dollar.vaults.v2.StaleInflightAlert.timestamp:type_name -> google.protobuf.Timestamp
	19, // [19:19] is the sub-list for method output_type
	19, // [19:19] is the sub-list for method input_type
	19, // [19:19] is the sub-list for extension type_name
	19, // [19:19] is the sub-list for extension extendee
	0,  // [0:19] is the sub-list for field type_name
}

func init() { file_noble_dollar_vaults_v2_cross_chain_proto_init() }
func file_noble_dollar_vaults_v2_cross_chain_proto_init() {
	if File_noble_dollar_vaults_v2_cross_chain_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CrossChainRoute); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemotePosition); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*InflightFund); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NobleEndpoint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ProviderTrackingInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HyperlaneTrackingInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NAVOracleUpdate); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PositionOracleConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CrossChainPositionSnapshot); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CrossChainConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StaleInflightAlert); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[2].OneofWrappers = []interface{}{
		(*InflightFund_NobleOrigin)(nil),
		(*InflightFund_RemoteOrigin)(nil),
		(*InflightFund_NobleDestination)(nil),
		(*InflightFund_RemoteDestination)(nil),
	}
	file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*ProviderTrackingInfo_HyperlaneTracking)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_noble_dollar_vaults_v2_cross_chain_proto_rawDesc,
			NumEnums:      6,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_noble_dollar_vaults_v2_cross_chain_proto_goTypes,
		DependencyIndexes: file_noble_dollar_vaults_v2_cross_chain_proto_depIdxs,
		EnumInfos:         file_noble_dollar_vaults_v2_cross_chain_proto_enumTypes,
		MessageInfos:      file_noble_dollar_vaults_v2_cross_chain_proto_msgTypes,
	}.Build()
	File_noble_dollar_vaults_v2_cross_chain_proto = out.File
	file_noble_dollar_vaults_v2_cross_chain_proto_rawDesc = nil
	file_noble_dollar_vaults_v2_cross_chain_proto_goTypes = nil
	file_noble_dollar_vaults_v2_cross_chain_proto_depIdxs = nil
}
