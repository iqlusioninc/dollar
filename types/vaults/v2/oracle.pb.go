// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/oracle.proto

package v2

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_bcp_innovations_hyperlane_cosmos_util "github.com/bcp-innovations/hyperlane-cosmos/util"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// StalenessLevel represents the freshness of oracle data
type StalenessLevel int32

const (
	// Data is fresh
	STALENESS_LEVEL_FRESH StalenessLevel = 0
	// Data is stale
	STALENESS_LEVEL_STALE StalenessLevel = 1
	// Data is in warning threshold
	STALENESS_LEVEL_WARNING StalenessLevel = 2
	// Data is in critical threshold
	STALENESS_LEVEL_CRITICAL StalenessLevel = 3
)

var StalenessLevel_name = map[int32]string{
	0: "STALENESS_LEVEL_FRESH",
	1: "STALENESS_LEVEL_STALE",
	2: "STALENESS_LEVEL_WARNING",
	3: "STALENESS_LEVEL_CRITICAL",
}

var StalenessLevel_value = map[string]int32{
	"STALENESS_LEVEL_FRESH":    0,
	"STALENESS_LEVEL_STALE":    1,
	"STALENESS_LEVEL_WARNING":  2,
	"STALENESS_LEVEL_CRITICAL": 3,
}

func (x StalenessLevel) String() string {
	return proto.EnumName(StalenessLevel_name, int32(x))
}

func (StalenessLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{0}
}

// RemotePosition represents a position tracked by an oracle
type RemotePositionOracle struct {
	// Unique position identifier
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Chain ID where the position exists
	ChainId uint32 `protobuf:"varint,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Oracle contract address on the remote chain
	OracleAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,3,opt,name=oracle_address,json=oracleAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"oracle_address"`
	// Vault address holding this position
	VaultAddress string `protobuf:"bytes,4,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// Number of shares held
	SharesHeld cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=shares_held,json=sharesHeld,proto3,customtype=cosmossdk.io/math.Int" json:"shares_held"`
	// Current share price
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
	// Last update timestamp
	LastUpdate time.Time `protobuf:"bytes,7,opt,name=last_update,json=lastUpdate,proto3,stdtime" json:"last_update"`
}

func (m *RemotePositionOracle) Reset()         { *m = RemotePositionOracle{} }
func (m *RemotePositionOracle) String() string { return proto.CompactTextString(m) }
func (*RemotePositionOracle) ProtoMessage()    {}
func (*RemotePositionOracle) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{0}
}
func (m *RemotePositionOracle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemotePositionOracle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemotePositionOracle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemotePositionOracle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemotePositionOracle.Merge(m, src)
}
func (m *RemotePositionOracle) XXX_Size() int {
	return m.Size()
}
func (m *RemotePositionOracle) XXX_DiscardUnknown() {
	xxx_messageInfo_RemotePositionOracle.DiscardUnknown(m)
}

var xxx_messageInfo_RemotePositionOracle proto.InternalMessageInfo

func (m *RemotePositionOracle) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *RemotePositionOracle) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *RemotePositionOracle) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *RemotePositionOracle) GetLastUpdate() time.Time {
	if m != nil {
		return m.LastUpdate
	}
	return time.Time{}
}

// OracleMapping defines the mapping between an oracle and its position
type OracleMapping struct {
	// Oracle contract address
	OracleAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=oracle_address,json=oracleAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"oracle_address"`
	// Source chain ID
	ChainId uint32 `protobuf:"varint,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Position identifier this oracle reports for
	PositionId uint64 `protobuf:"varint,3,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *OracleMapping) Reset()         { *m = OracleMapping{} }
func (m *OracleMapping) String() string { return proto.CompactTextString(m) }
func (*OracleMapping) ProtoMessage()    {}
func (*OracleMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{1}
}
func (m *OracleMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleMapping.Merge(m, src)
}
func (m *OracleMapping) XXX_Size() int {
	return m.Size()
}
func (m *OracleMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleMapping.DiscardUnknown(m)
}

var xxx_messageInfo_OracleMapping proto.InternalMessageInfo

func (m *OracleMapping) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *OracleMapping) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

// EnrolledOracleRouter represents an enrolled oracle router
type EnrolledOracleRouter struct {
	// Position identifier
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,2,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Oracle contract address
	OracleAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,3,opt,name=oracle_address,json=oracleAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"oracle_address"`
}

func (m *EnrolledOracleRouter) Reset()         { *m = EnrolledOracleRouter{} }
func (m *EnrolledOracleRouter) String() string { return proto.CompactTextString(m) }
func (*EnrolledOracleRouter) ProtoMessage()    {}
func (*EnrolledOracleRouter) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{2}
}
func (m *EnrolledOracleRouter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnrolledOracleRouter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnrolledOracleRouter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnrolledOracleRouter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnrolledOracleRouter.Merge(m, src)
}
func (m *EnrolledOracleRouter) XXX_Size() int {
	return m.Size()
}
func (m *EnrolledOracleRouter) XXX_DiscardUnknown() {
	xxx_messageInfo_EnrolledOracleRouter.DiscardUnknown(m)
}

var xxx_messageInfo_EnrolledOracleRouter proto.InternalMessageInfo

func (m *EnrolledOracleRouter) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *EnrolledOracleRouter) GetSourceChain() string {
	if m != nil {
		return m.SourceChain
	}
	return ""
}

// EnrolledOracle represents a registered oracle
type EnrolledOracle struct {
	// Position identifier
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,2,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Oracle address on remote chain
	OracleAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,3,opt,name=oracle_address,json=oracleAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"oracle_address"`
	// Maximum staleness (seconds)
	MaxStaleness int64 `protobuf:"varint,4,opt,name=max_staleness,json=maxStaleness,proto3" json:"max_staleness,omitempty"`
	// Registration timestamp
	RegisteredAt time.Time `protobuf:"bytes,5,opt,name=registered_at,json=registeredAt,proto3,stdtime" json:"registered_at"`
	// Whether the oracle is active
	Active bool `protobuf:"varint,6,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *EnrolledOracle) Reset()         { *m = EnrolledOracle{} }
func (m *EnrolledOracle) String() string { return proto.CompactTextString(m) }
func (*EnrolledOracle) ProtoMessage()    {}
func (*EnrolledOracle) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{3}
}
func (m *EnrolledOracle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnrolledOracle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnrolledOracle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnrolledOracle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnrolledOracle.Merge(m, src)
}
func (m *EnrolledOracle) XXX_Size() int {
	return m.Size()
}
func (m *EnrolledOracle) XXX_DiscardUnknown() {
	xxx_messageInfo_EnrolledOracle.DiscardUnknown(m)
}

var xxx_messageInfo_EnrolledOracle proto.InternalMessageInfo

func (m *EnrolledOracle) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *EnrolledOracle) GetSourceChain() string {
	if m != nil {
		return m.SourceChain
	}
	return ""
}

func (m *EnrolledOracle) GetMaxStaleness() int64 {
	if m != nil {
		return m.MaxStaleness
	}
	return 0
}

func (m *EnrolledOracle) GetRegisteredAt() time.Time {
	if m != nil {
		return m.RegisteredAt
	}
	return time.Time{}
}

func (m *EnrolledOracle) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// StalenessConfig defines staleness thresholds
type StalenessConfig struct {
	// Warning threshold in seconds
	WarningThreshold int64 `protobuf:"varint,1,opt,name=warning_threshold,json=warningThreshold,proto3" json:"warning_threshold,omitempty"`
	// Critical threshold in seconds
	CriticalThreshold int64 `protobuf:"varint,2,opt,name=critical_threshold,json=criticalThreshold,proto3" json:"critical_threshold,omitempty"`
	// Maximum allowed staleness before fallback
	MaxStaleness int64 `protobuf:"varint,3,opt,name=max_staleness,json=maxStaleness,proto3" json:"max_staleness,omitempty"`
}

func (m *StalenessConfig) Reset()         { *m = StalenessConfig{} }
func (m *StalenessConfig) String() string { return proto.CompactTextString(m) }
func (*StalenessConfig) ProtoMessage()    {}
func (*StalenessConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{4}
}
func (m *StalenessConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StalenessConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StalenessConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StalenessConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StalenessConfig.Merge(m, src)
}
func (m *StalenessConfig) XXX_Size() int {
	return m.Size()
}
func (m *StalenessConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StalenessConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StalenessConfig proto.InternalMessageInfo

func (m *StalenessConfig) GetWarningThreshold() int64 {
	if m != nil {
		return m.WarningThreshold
	}
	return 0
}

func (m *StalenessConfig) GetCriticalThreshold() int64 {
	if m != nil {
		return m.CriticalThreshold
	}
	return 0
}

func (m *StalenessConfig) GetMaxStaleness() int64 {
	if m != nil {
		return m.MaxStaleness
	}
	return 0
}

// NAVPayload represents the oracle update payload (105 bytes when encoded)
type NAVPayload struct {
	// Message type (0x01 for NAV update)
	MessageType uint32 `protobuf:"varint,1,opt,name=message_type,json=messageType,proto3" json:"message_type,omitempty"`
	// Position identifier (32 bytes)
	PositionId uint64 `protobuf:"varint,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Share price (32 bytes, 1e18 precision)
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
	// Shares held (32 bytes, 1e18 precision)
	SharesHeld cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=shares_held,json=sharesHeld,proto3,customtype=cosmossdk.io/math.Int" json:"shares_held"`
	// Unix timestamp (8 bytes)
	Timestamp int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *NAVPayload) Reset()         { *m = NAVPayload{} }
func (m *NAVPayload) String() string { return proto.CompactTextString(m) }
func (*NAVPayload) ProtoMessage()    {}
func (*NAVPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{5}
}
func (m *NAVPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NAVPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NAVPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NAVPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NAVPayload.Merge(m, src)
}
func (m *NAVPayload) XXX_Size() int {
	return m.Size()
}
func (m *NAVPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_NAVPayload.DiscardUnknown(m)
}

var xxx_messageInfo_NAVPayload proto.InternalMessageInfo

func (m *NAVPayload) GetMessageType() uint32 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *NAVPayload) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *NAVPayload) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// FallbackStrategy defines the fallback strategy for stale data
type FallbackStrategy struct {
	// Whether to use last known good value
	UseLastKnownGood bool `protobuf:"varint,1,opt,name=use_last_known_good,json=useLastKnownGood,proto3" json:"use_last_known_good,omitempty"`
	// Maximum cache age allowed (seconds)
	MaxCacheAge int64 `protobuf:"varint,2,opt,name=max_cache_age,json=maxCacheAge,proto3" json:"max_cache_age,omitempty"`
	// Alert threshold for notifications (seconds)
	AlertThreshold int64 `protobuf:"varint,3,opt,name=alert_threshold,json=alertThreshold,proto3" json:"alert_threshold,omitempty"`
}

func (m *FallbackStrategy) Reset()         { *m = FallbackStrategy{} }
func (m *FallbackStrategy) String() string { return proto.CompactTextString(m) }
func (*FallbackStrategy) ProtoMessage()    {}
func (*FallbackStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{6}
}
func (m *FallbackStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FallbackStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FallbackStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FallbackStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FallbackStrategy.Merge(m, src)
}
func (m *FallbackStrategy) XXX_Size() int {
	return m.Size()
}
func (m *FallbackStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_FallbackStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_FallbackStrategy proto.InternalMessageInfo

func (m *FallbackStrategy) GetUseLastKnownGood() bool {
	if m != nil {
		return m.UseLastKnownGood
	}
	return false
}

func (m *FallbackStrategy) GetMaxCacheAge() int64 {
	if m != nil {
		return m.MaxCacheAge
	}
	return 0
}

func (m *FallbackStrategy) GetAlertThreshold() int64 {
	if m != nil {
		return m.AlertThreshold
	}
	return 0
}

// OracleGovernanceParams defines governance parameters for oracles
type OracleGovernanceParams struct {
	// Maximum update interval allowed (seconds)
	MaxUpdateInterval int64 `protobuf:"varint,1,opt,name=max_update_interval,json=maxUpdateInterval,proto3" json:"max_update_interval,omitempty"`
	// Minimum update interval to prevent spam (seconds)
	MinUpdateInterval int64 `protobuf:"varint,2,opt,name=min_update_interval,json=minUpdateInterval,proto3" json:"min_update_interval,omitempty"`
	// Maximum price deviation per update (basis points)
	MaxPriceDeviationBps int32 `protobuf:"varint,3,opt,name=max_price_deviation_bps,json=maxPriceDeviationBps,proto3" json:"max_price_deviation_bps,omitempty"`
	// Default staleness config
	DefaultStaleness *StalenessConfig `protobuf:"bytes,4,opt,name=default_staleness,json=defaultStaleness,proto3" json:"default_staleness,omitempty"`
	// Default fallback strategy
	DefaultFallback *FallbackStrategy `protobuf:"bytes,5,opt,name=default_fallback,json=defaultFallback,proto3" json:"default_fallback,omitempty"`
}

func (m *OracleGovernanceParams) Reset()         { *m = OracleGovernanceParams{} }
func (m *OracleGovernanceParams) String() string { return proto.CompactTextString(m) }
func (*OracleGovernanceParams) ProtoMessage()    {}
func (*OracleGovernanceParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{7}
}
func (m *OracleGovernanceParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleGovernanceParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleGovernanceParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleGovernanceParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleGovernanceParams.Merge(m, src)
}
func (m *OracleGovernanceParams) XXX_Size() int {
	return m.Size()
}
func (m *OracleGovernanceParams) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleGovernanceParams.DiscardUnknown(m)
}

var xxx_messageInfo_OracleGovernanceParams proto.InternalMessageInfo

func (m *OracleGovernanceParams) GetMaxUpdateInterval() int64 {
	if m != nil {
		return m.MaxUpdateInterval
	}
	return 0
}

func (m *OracleGovernanceParams) GetMinUpdateInterval() int64 {
	if m != nil {
		return m.MinUpdateInterval
	}
	return 0
}

func (m *OracleGovernanceParams) GetMaxPriceDeviationBps() int32 {
	if m != nil {
		return m.MaxPriceDeviationBps
	}
	return 0
}

func (m *OracleGovernanceParams) GetDefaultStaleness() *StalenessConfig {
	if m != nil {
		return m.DefaultStaleness
	}
	return nil
}

func (m *OracleGovernanceParams) GetDefaultFallback() *FallbackStrategy {
	if m != nil {
		return m.DefaultFallback
	}
	return nil
}

// AlertConfig defines alert configuration
type AlertConfig struct {
	// Stale data threshold (seconds)
	StaleDataThreshold int64 `protobuf:"varint,1,opt,name=stale_data_threshold,json=staleDataThreshold,proto3" json:"stale_data_threshold,omitempty"`
	// Price deviation threshold (basis points)
	PriceDeviationThreshold int32 `protobuf:"varint,2,opt,name=price_deviation_threshold,json=priceDeviationThreshold,proto3" json:"price_deviation_threshold,omitempty"`
	// Failed update threshold (count)
	FailedUpdateThreshold int32 `protobuf:"varint,3,opt,name=failed_update_threshold,json=failedUpdateThreshold,proto3" json:"failed_update_threshold,omitempty"`
}

func (m *AlertConfig) Reset()         { *m = AlertConfig{} }
func (m *AlertConfig) String() string { return proto.CompactTextString(m) }
func (*AlertConfig) ProtoMessage()    {}
func (*AlertConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{8}
}
func (m *AlertConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlertConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlertConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlertConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlertConfig.Merge(m, src)
}
func (m *AlertConfig) XXX_Size() int {
	return m.Size()
}
func (m *AlertConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_AlertConfig.DiscardUnknown(m)
}

var xxx_messageInfo_AlertConfig proto.InternalMessageInfo

func (m *AlertConfig) GetStaleDataThreshold() int64 {
	if m != nil {
		return m.StaleDataThreshold
	}
	return 0
}

func (m *AlertConfig) GetPriceDeviationThreshold() int32 {
	if m != nil {
		return m.PriceDeviationThreshold
	}
	return 0
}

func (m *AlertConfig) GetFailedUpdateThreshold() int32 {
	if m != nil {
		return m.FailedUpdateThreshold
	}
	return 0
}

// OracleStatus represents the current status of an oracle
type OracleStatus struct {
	// Oracle identifier
	OracleId string `protobuf:"bytes,1,opt,name=oracle_id,json=oracleId,proto3" json:"oracle_id,omitempty"`
	// Position ID
	PositionId uint64 `protobuf:"varint,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Last successful update
	LastSuccess time.Time `protobuf:"bytes,3,opt,name=last_success,json=lastSuccess,proto3,stdtime" json:"last_success"`
	// Number of consecutive failures
	ConsecutiveFailures int32 `protobuf:"varint,4,opt,name=consecutive_failures,json=consecutiveFailures,proto3" json:"consecutive_failures,omitempty"`
	// Whether oracle is healthy
	IsHealthy bool `protobuf:"varint,5,opt,name=is_healthy,json=isHealthy,proto3" json:"is_healthy,omitempty"`
	// Current staleness level
	StalenessLevel StalenessLevel `protobuf:"varint,6,opt,name=staleness_level,json=stalenessLevel,proto3,enum=noble.dollar.vaults.v2.StalenessLevel" json:"staleness_level,omitempty"`
	// Last error message if any
	LastError string `protobuf:"bytes,7,opt,name=last_error,json=lastError,proto3" json:"last_error,omitempty"`
}

func (m *OracleStatus) Reset()         { *m = OracleStatus{} }
func (m *OracleStatus) String() string { return proto.CompactTextString(m) }
func (*OracleStatus) ProtoMessage()    {}
func (*OracleStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{9}
}
func (m *OracleStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleStatus.Merge(m, src)
}
func (m *OracleStatus) XXX_Size() int {
	return m.Size()
}
func (m *OracleStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleStatus.DiscardUnknown(m)
}

var xxx_messageInfo_OracleStatus proto.InternalMessageInfo

func (m *OracleStatus) GetOracleId() string {
	if m != nil {
		return m.OracleId
	}
	return ""
}

func (m *OracleStatus) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *OracleStatus) GetLastSuccess() time.Time {
	if m != nil {
		return m.LastSuccess
	}
	return time.Time{}
}

func (m *OracleStatus) GetConsecutiveFailures() int32 {
	if m != nil {
		return m.ConsecutiveFailures
	}
	return 0
}

func (m *OracleStatus) GetIsHealthy() bool {
	if m != nil {
		return m.IsHealthy
	}
	return false
}

func (m *OracleStatus) GetStalenessLevel() StalenessLevel {
	if m != nil {
		return m.StalenessLevel
	}
	return STALENESS_LEVEL_FRESH
}

func (m *OracleStatus) GetLastError() string {
	if m != nil {
		return m.LastError
	}
	return ""
}

// CrossChainOracleMessage represents an oracle update delivered by cross-chain messaging
// This is not a Msg type as it's handled internally when messages are delivered
type CrossChainOracleMessage struct {
	// Mailbox/channel identifier
	MailboxId []byte `protobuf:"bytes,1,opt,name=mailbox_id,json=mailboxId,proto3" json:"mailbox_id,omitempty"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,2,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Sender address on origin chain
	Sender []byte `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	// Hyperlane metadata for verification
	Metadata []byte `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// NAV oracle update payload (105 bytes)
	Payload []byte `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
	// Timestamp when received
	ReceivedAt time.Time `protobuf:"bytes,6,opt,name=received_at,json=receivedAt,proto3,stdtime" json:"received_at"`
	// Provider type (HYPERLANE, IBC)
	ProviderType ProviderType `protobuf:"varint,7,opt,name=provider_type,json=providerType,proto3,enum=noble.dollar.vaults.v2.ProviderType" json:"provider_type,omitempty"`
}

func (m *CrossChainOracleMessage) Reset()         { *m = CrossChainOracleMessage{} }
func (m *CrossChainOracleMessage) String() string { return proto.CompactTextString(m) }
func (*CrossChainOracleMessage) ProtoMessage()    {}
func (*CrossChainOracleMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{10}
}
func (m *CrossChainOracleMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainOracleMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainOracleMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainOracleMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainOracleMessage.Merge(m, src)
}
func (m *CrossChainOracleMessage) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainOracleMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainOracleMessage.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainOracleMessage proto.InternalMessageInfo

func (m *CrossChainOracleMessage) GetMailboxId() []byte {
	if m != nil {
		return m.MailboxId
	}
	return nil
}

func (m *CrossChainOracleMessage) GetSourceChain() string {
	if m != nil {
		return m.SourceChain
	}
	return ""
}

func (m *CrossChainOracleMessage) GetSender() []byte {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *CrossChainOracleMessage) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CrossChainOracleMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CrossChainOracleMessage) GetReceivedAt() time.Time {
	if m != nil {
		return m.ReceivedAt
	}
	return time.Time{}
}

func (m *CrossChainOracleMessage) GetProviderType() ProviderType {
	if m != nil {
		return m.ProviderType
	}
	return PROVIDER_TYPE_HYPERLANE
}

// OracleUpdateResult represents the result of processing an oracle update
type OracleUpdateResult struct {
	// Position ID that was updated
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// New share price
	NewSharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=new_share_price,json=newSharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"new_share_price"`
	// New shares held
	NewShares cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=new_shares,json=newShares,proto3,customtype=cosmossdk.io/math.Int" json:"new_shares"`
	// Calculated position value
	PositionValue cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=position_value,json=positionValue,proto3,customtype=cosmossdk.io/math.Int" json:"position_value"`
	// Updated total NAV
	UpdatedNav cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=updated_nav,json=updatedNav,proto3,customtype=cosmossdk.io/math.Int" json:"updated_nav"`
}

func (m *OracleUpdateResult) Reset()         { *m = OracleUpdateResult{} }
func (m *OracleUpdateResult) String() string { return proto.CompactTextString(m) }
func (*OracleUpdateResult) ProtoMessage()    {}
func (*OracleUpdateResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{11}
}
func (m *OracleUpdateResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleUpdateResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleUpdateResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleUpdateResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleUpdateResult.Merge(m, src)
}
func (m *OracleUpdateResult) XXX_Size() int {
	return m.Size()
}
func (m *OracleUpdateResult) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleUpdateResult.DiscardUnknown(m)
}

var xxx_messageInfo_OracleUpdateResult proto.InternalMessageInfo

func (m *OracleUpdateResult) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

// MsgRegisterOracle registers a new oracle for a position
type MsgRegisterOracle struct {
	// Authority (governance module account)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Position identifier to track
	PositionId uint64 `protobuf:"varint,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Oracle contract address on remote chain
	OracleAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,3,opt,name=oracle_address,json=oracleAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"oracle_address"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,4,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Maximum staleness allowed (seconds)
	MaxStaleness int64 `protobuf:"varint,5,opt,name=max_staleness,json=maxStaleness,proto3" json:"max_staleness,omitempty"`
	// Provider type (HYPERLANE, IBC)
	ProviderType ProviderType `protobuf:"varint,6,opt,name=provider_type,json=providerType,proto3,enum=noble.dollar.vaults.v2.ProviderType" json:"provider_type,omitempty"`
	// Origin identifier (mailbox for Hyperlane, channel for IBC)
	OriginIdentifier string `protobuf:"bytes,7,opt,name=origin_identifier,json=originIdentifier,proto3" json:"origin_identifier,omitempty"`
}

func (m *MsgRegisterOracle) Reset()         { *m = MsgRegisterOracle{} }
func (m *MsgRegisterOracle) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterOracle) ProtoMessage()    {}
func (*MsgRegisterOracle) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{12}
}
func (m *MsgRegisterOracle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterOracle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterOracle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterOracle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterOracle.Merge(m, src)
}
func (m *MsgRegisterOracle) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterOracle) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterOracle.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterOracle proto.InternalMessageInfo

// MsgRegisterOracleResponse confirms oracle registration
type MsgRegisterOracleResponse struct {
	// Oracle ID assigned
	OracleId string `protobuf:"bytes,1,opt,name=oracle_id,json=oracleId,proto3" json:"oracle_id,omitempty"`
	// Position ID
	PositionId uint64 `protobuf:"varint,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Registration timestamp
	RegisteredAt time.Time `protobuf:"bytes,3,opt,name=registered_at,json=registeredAt,proto3,stdtime" json:"registered_at"`
}

func (m *MsgRegisterOracleResponse) Reset()         { *m = MsgRegisterOracleResponse{} }
func (m *MsgRegisterOracleResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterOracleResponse) ProtoMessage()    {}
func (*MsgRegisterOracleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{13}
}
func (m *MsgRegisterOracleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterOracleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterOracleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterOracleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterOracleResponse.Merge(m, src)
}
func (m *MsgRegisterOracleResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterOracleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterOracleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterOracleResponse proto.InternalMessageInfo

func (m *MsgRegisterOracleResponse) GetOracleId() string {
	if m != nil {
		return m.OracleId
	}
	return ""
}

func (m *MsgRegisterOracleResponse) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *MsgRegisterOracleResponse) GetRegisteredAt() time.Time {
	if m != nil {
		return m.RegisteredAt
	}
	return time.Time{}
}

// MsgUpdateOracleConfig updates an oracle's configuration
type MsgUpdateOracleConfig struct {
	// Authority (governance module account)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Oracle ID to update
	OracleId string `protobuf:"bytes,2,opt,name=oracle_id,json=oracleId,proto3" json:"oracle_id,omitempty"`
	// New maximum staleness (0 to keep current)
	MaxStaleness int64 `protobuf:"varint,3,opt,name=max_staleness,json=maxStaleness,proto3" json:"max_staleness,omitempty"`
	// Whether to activate/deactivate
	Active bool `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *MsgUpdateOracleConfig) Reset()         { *m = MsgUpdateOracleConfig{} }
func (m *MsgUpdateOracleConfig) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateOracleConfig) ProtoMessage()    {}
func (*MsgUpdateOracleConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{14}
}
func (m *MsgUpdateOracleConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateOracleConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateOracleConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateOracleConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateOracleConfig.Merge(m, src)
}
func (m *MsgUpdateOracleConfig) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateOracleConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateOracleConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateOracleConfig proto.InternalMessageInfo

// MsgUpdateOracleConfigResponse confirms configuration update
type MsgUpdateOracleConfigResponse struct {
	// Oracle ID
	OracleId string `protobuf:"bytes,1,opt,name=oracle_id,json=oracleId,proto3" json:"oracle_id,omitempty"`
	// Updated configuration
	UpdatedConfig *EnrolledOracle `protobuf:"bytes,2,opt,name=updated_config,json=updatedConfig,proto3" json:"updated_config,omitempty"`
}

func (m *MsgUpdateOracleConfigResponse) Reset()         { *m = MsgUpdateOracleConfigResponse{} }
func (m *MsgUpdateOracleConfigResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateOracleConfigResponse) ProtoMessage()    {}
func (*MsgUpdateOracleConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{15}
}
func (m *MsgUpdateOracleConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateOracleConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateOracleConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateOracleConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateOracleConfigResponse.Merge(m, src)
}
func (m *MsgUpdateOracleConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateOracleConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateOracleConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateOracleConfigResponse proto.InternalMessageInfo

func (m *MsgUpdateOracleConfigResponse) GetOracleId() string {
	if m != nil {
		return m.OracleId
	}
	return ""
}

func (m *MsgUpdateOracleConfigResponse) GetUpdatedConfig() *EnrolledOracle {
	if m != nil {
		return m.UpdatedConfig
	}
	return nil
}

// MsgRemoveOracle removes an oracle from the system
type MsgRemoveOracle struct {
	// Authority (governance module account)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Oracle ID to remove
	OracleId string `protobuf:"bytes,2,opt,name=oracle_id,json=oracleId,proto3" json:"oracle_id,omitempty"`
	// Reason for removal
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgRemoveOracle) Reset()         { *m = MsgRemoveOracle{} }
func (m *MsgRemoveOracle) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveOracle) ProtoMessage()    {}
func (*MsgRemoveOracle) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{16}
}
func (m *MsgRemoveOracle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveOracle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveOracle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveOracle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveOracle.Merge(m, src)
}
func (m *MsgRemoveOracle) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveOracle) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveOracle.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveOracle proto.InternalMessageInfo

// MsgRemoveOracleResponse confirms oracle removal
type MsgRemoveOracleResponse struct {
	// Oracle ID removed
	OracleId string `protobuf:"bytes,1,opt,name=oracle_id,json=oracleId,proto3" json:"oracle_id,omitempty"`
	// Position ID affected
	PositionId uint64 `protobuf:"varint,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Removal timestamp
	RemovedAt time.Time `protobuf:"bytes,3,opt,name=removed_at,json=removedAt,proto3,stdtime" json:"removed_at"`
}

func (m *MsgRemoveOracleResponse) Reset()         { *m = MsgRemoveOracleResponse{} }
func (m *MsgRemoveOracleResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveOracleResponse) ProtoMessage()    {}
func (*MsgRemoveOracleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{17}
}
func (m *MsgRemoveOracleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveOracleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveOracleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveOracleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveOracleResponse.Merge(m, src)
}
func (m *MsgRemoveOracleResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveOracleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveOracleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveOracleResponse proto.InternalMessageInfo

func (m *MsgRemoveOracleResponse) GetOracleId() string {
	if m != nil {
		return m.OracleId
	}
	return ""
}

func (m *MsgRemoveOracleResponse) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *MsgRemoveOracleResponse) GetRemovedAt() time.Time {
	if m != nil {
		return m.RemovedAt
	}
	return time.Time{}
}

// MsgUpdateOracleParams updates global oracle parameters
type MsgUpdateOracleParams struct {
	// Authority (governance module account)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Updated governance parameters
	Params OracleGovernanceParams `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateOracleParams) Reset()         { *m = MsgUpdateOracleParams{} }
func (m *MsgUpdateOracleParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateOracleParams) ProtoMessage()    {}
func (*MsgUpdateOracleParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{18}
}
func (m *MsgUpdateOracleParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateOracleParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateOracleParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateOracleParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateOracleParams.Merge(m, src)
}
func (m *MsgUpdateOracleParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateOracleParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateOracleParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateOracleParams proto.InternalMessageInfo

// MsgUpdateOracleParamsResponse confirms parameter update
type MsgUpdateOracleParamsResponse struct {
	// Previous parameters
	PreviousParams OracleGovernanceParams `protobuf:"bytes,1,opt,name=previous_params,json=previousParams,proto3" json:"previous_params"`
	// New parameters
	NewParams OracleGovernanceParams `protobuf:"bytes,2,opt,name=new_params,json=newParams,proto3" json:"new_params"`
}

func (m *MsgUpdateOracleParamsResponse) Reset()         { *m = MsgUpdateOracleParamsResponse{} }
func (m *MsgUpdateOracleParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateOracleParamsResponse) ProtoMessage()    {}
func (*MsgUpdateOracleParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e470ac00e47b462, []int{19}
}
func (m *MsgUpdateOracleParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateOracleParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateOracleParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateOracleParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateOracleParamsResponse.Merge(m, src)
}
func (m *MsgUpdateOracleParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateOracleParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateOracleParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateOracleParamsResponse proto.InternalMessageInfo

func (m *MsgUpdateOracleParamsResponse) GetPreviousParams() OracleGovernanceParams {
	if m != nil {
		return m.PreviousParams
	}
	return OracleGovernanceParams{}
}

func (m *MsgUpdateOracleParamsResponse) GetNewParams() OracleGovernanceParams {
	if m != nil {
		return m.NewParams
	}
	return OracleGovernanceParams{}
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v2.StalenessLevel", StalenessLevel_name, StalenessLevel_value)
	proto.RegisterType((*RemotePositionOracle)(nil), "noble.dollar.vaults.v2.RemotePositionOracle")
	proto.RegisterType((*OracleMapping)(nil), "noble.dollar.vaults.v2.OracleMapping")
	proto.RegisterType((*EnrolledOracleRouter)(nil), "noble.dollar.vaults.v2.EnrolledOracleRouter")
	proto.RegisterType((*EnrolledOracle)(nil), "noble.dollar.vaults.v2.EnrolledOracle")
	proto.RegisterType((*StalenessConfig)(nil), "noble.dollar.vaults.v2.StalenessConfig")
	proto.RegisterType((*NAVPayload)(nil), "noble.dollar.vaults.v2.NAVPayload")
	proto.RegisterType((*FallbackStrategy)(nil), "noble.dollar.vaults.v2.FallbackStrategy")
	proto.RegisterType((*OracleGovernanceParams)(nil), "noble.dollar.vaults.v2.OracleGovernanceParams")
	proto.RegisterType((*AlertConfig)(nil), "noble.dollar.vaults.v2.AlertConfig")
	proto.RegisterType((*OracleStatus)(nil), "noble.dollar.vaults.v2.OracleStatus")
	proto.RegisterType((*CrossChainOracleMessage)(nil), "noble.dollar.vaults.v2.CrossChainOracleMessage")
	proto.RegisterType((*OracleUpdateResult)(nil), "noble.dollar.vaults.v2.OracleUpdateResult")
	proto.RegisterType((*MsgRegisterOracle)(nil), "noble.dollar.vaults.v2.MsgRegisterOracle")
	proto.RegisterType((*MsgRegisterOracleResponse)(nil), "noble.dollar.vaults.v2.MsgRegisterOracleResponse")
	proto.RegisterType((*MsgUpdateOracleConfig)(nil), "noble.dollar.vaults.v2.MsgUpdateOracleConfig")
	proto.RegisterType((*MsgUpdateOracleConfigResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateOracleConfigResponse")
	proto.RegisterType((*MsgRemoveOracle)(nil), "noble.dollar.vaults.v2.MsgRemoveOracle")
	proto.RegisterType((*MsgRemoveOracleResponse)(nil), "noble.dollar.vaults.v2.MsgRemoveOracleResponse")
	proto.RegisterType((*MsgUpdateOracleParams)(nil), "noble.dollar.vaults.v2.MsgUpdateOracleParams")
	proto.RegisterType((*MsgUpdateOracleParamsResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateOracleParamsResponse")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v2/oracle.proto", fileDescriptor_0e470ac00e47b462)
}

var fileDescriptor_0e470ac00e47b462 = []byte{
	// 1811 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0x77, 0xcf, 0xd8, 0x8e, 0xa7, 0x66, 0x3c, 0x1e, 0x77, 0x1c, 0x7f, 0x65, 0x63, 0x87, 0x0e,
	0x62, 0xad, 0x20, 0xcf, 0xec, 0x7a, 0x45, 0x84, 0x8c, 0x40, 0x1a, 0x3b, 0x4e, 0x32, 0xc2, 0x71,
	0x4c, 0x8d, 0x49, 0x24, 0x24, 0x68, 0x95, 0xbb, 0xcb, 0x3d, 0x4d, 0xba, 0xbb, 0x5a, 0x55, 0xd5,
	0x1d, 0x0f, 0x47, 0x2e, 0xac, 0x40, 0x42, 0xab, 0x3d, 0x22, 0x0e, 0x2b, 0xc1, 0x81, 0x63, 0x24,
	0x56, 0x02, 0x89, 0x3b, 0xca, 0x71, 0xb5, 0x20, 0x40, 0x2b, 0xb1, 0xa0, 0xe4, 0x10, 0xf8, 0x2f,
	0x50, 0x7d, 0xf4, 0x7c, 0xb5, 0xbd, 0x71, 0x9c, 0x10, 0x69, 0x2f, 0xf6, 0xd4, 0x7b, 0xaf, 0x5e,
	0xbd, 0xf7, 0x7e, 0xef, 0xab, 0xc1, 0xb5, 0x88, 0x1c, 0x06, 0xb8, 0xe1, 0x92, 0x20, 0x40, 0xb4,
	0x91, 0xa2, 0x24, 0xe0, 0xac, 0x91, 0x6e, 0x34, 0x08, 0x45, 0x4e, 0x80, 0xeb, 0x31, 0x25, 0x9c,
	0x98, 0xf3, 0x52, 0xa8, 0xae, 0x84, 0xea, 0x4a, 0xa8, 0x9e, 0x6e, 0x2c, 0xcf, 0xa2, 0xd0, 0x8f,
	0x48, 0x43, 0xfe, 0x55, 0xa2, 0xcb, 0x0b, 0x0e, 0x61, 0x21, 0x61, 0x8d, 0x90, 0x79, 0x8d, 0xf4,
	0x5d, 0xf1, 0x4f, 0x33, 0x96, 0x14, 0xc3, 0x96, 0xa7, 0x86, 0x3a, 0x68, 0xd6, 0x9c, 0x47, 0x3c,
	0xa2, 0xe8, 0xe2, 0x97, 0xa6, 0xae, 0x7a, 0x84, 0x78, 0x01, 0x6e, 0xc8, 0xd3, 0x61, 0x72, 0xd4,
	0xe0, 0x7e, 0x88, 0x19, 0x47, 0x61, 0xac, 0x05, 0xd6, 0x4e, 0x31, 0xdd, 0xa1, 0x84, 0x31, 0xdb,
	0xe9, 0x20, 0x3f, 0x52, 0x92, 0xd6, 0xdf, 0x8a, 0x60, 0x0e, 0xe2, 0x90, 0x70, 0xbc, 0x4f, 0x98,
	0xcf, 0x7d, 0x12, 0xdd, 0x93, 0xee, 0x99, 0xab, 0xa0, 0x1c, 0x6b, 0x8a, 0xed, 0xbb, 0x8b, 0xc6,
	0x55, 0x63, 0x6d, 0x1c, 0x82, 0x8c, 0xd4, 0x72, 0xcd, 0x25, 0x30, 0x25, 0x15, 0x09, 0x6e, 0xe1,
	0xaa, 0xb1, 0x36, 0x0d, 0x2f, 0xc8, 0x73, 0xcb, 0x35, 0x7f, 0x0c, 0xaa, 0x2a, 0x48, 0x36, 0x72,
	0x5d, 0x8a, 0x19, 0x5b, 0x2c, 0x5e, 0x35, 0xd6, 0x4a, 0x5b, 0xdb, 0x4f, 0x3e, 0x5f, 0x1d, 0xfb,
	0xec, 0xf3, 0xd5, 0x6f, 0x79, 0x3e, 0xef, 0x24, 0x87, 0x75, 0x87, 0x84, 0x8d, 0x43, 0x27, 0x5e,
	0xf7, 0xa3, 0x88, 0xa4, 0x48, 0xe8, 0x65, 0x8d, 0x4e, 0x37, 0xc6, 0x34, 0x40, 0x11, 0x5e, 0xd7,
	0xe1, 0x4a, 0xb8, 0x1f, 0xd4, 0xef, 0xe0, 0xe3, 0xa6, 0x52, 0x05, 0xa7, 0x95, 0x6a, 0x7d, 0x34,
	0xaf, 0x81, 0x69, 0xe9, 0x5f, 0xef, 0xa9, 0x71, 0xf1, 0x14, 0xac, 0x48, 0x62, 0x26, 0xf4, 0x3d,
	0x50, 0x66, 0x1d, 0x44, 0x31, 0xb3, 0x3b, 0x38, 0x70, 0x17, 0x27, 0xa4, 0x35, 0xef, 0x68, 0x6b,
	0x2e, 0xa9, 0x87, 0x98, 0xfb, 0xb0, 0xee, 0x93, 0x46, 0x88, 0x78, 0xa7, 0xde, 0x8a, 0xf8, 0xa7,
	0x1f, 0xaf, 0x03, 0x0d, 0x45, 0x2b, 0xe2, 0xbf, 0x7b, 0xfe, 0xf8, 0xba, 0x01, 0x81, 0x52, 0x72,
	0x07, 0x07, 0xae, 0xf9, 0x40, 0xab, 0xb4, 0x63, 0xea, 0x3b, 0x78, 0x71, 0x52, 0xaa, 0xbc, 0xa1,
	0x55, 0x5e, 0xce, 0xab, 0xdc, 0xc5, 0x1e, 0x72, 0xba, 0x37, 0xb1, 0x33, 0xa0, 0xf8, 0x26, 0x76,
	0x06, 0x15, 0xef, 0x0b, 0x4d, 0xe6, 0x0e, 0x28, 0x07, 0x88, 0x71, 0x3b, 0x89, 0x5d, 0xc4, 0xf1,
	0xe2, 0x85, 0xab, 0xc6, 0x5a, 0x79, 0x63, 0xb9, 0xae, 0x20, 0xaf, 0x67, 0x90, 0xd7, 0x0f, 0x32,
	0xc8, 0xb7, 0xa6, 0xc4, 0xa3, 0x1f, 0xfc, 0x6b, 0xd5, 0x80, 0x40, 0x5c, 0xfc, 0xbe, 0xbc, 0x67,
	0xfd, 0xc1, 0x00, 0xd3, 0x0a, 0xca, 0xbb, 0x28, 0x8e, 0xfd, 0xc8, 0x3b, 0x01, 0x15, 0xe3, 0xff,
	0x86, 0xca, 0x17, 0x24, 0xc7, 0x48, 0x62, 0x15, 0x47, 0x13, 0xcb, 0xfa, 0xb3, 0x01, 0xe6, 0x76,
	0x22, 0x4a, 0x82, 0x00, 0xbb, 0xca, 0x03, 0x48, 0x12, 0x8e, 0xe9, 0x8b, 0x53, 0xf2, 0x2b, 0xa0,
	0xc2, 0x48, 0x42, 0x1d, 0xac, 0x52, 0x5c, 0xbe, 0x5c, 0x82, 0x65, 0x45, 0xdb, 0x16, 0xa4, 0x37,
	0x99, 0x9a, 0xd6, 0x93, 0x02, 0xa8, 0x0e, 0x3b, 0xf2, 0x65, 0x73, 0x41, 0x54, 0x57, 0x88, 0x8e,
	0x6d, 0xc6, 0x51, 0x80, 0xa3, 0xac, 0xba, 0x8a, 0xb0, 0x12, 0xa2, 0xe3, 0x76, 0x46, 0x33, 0x5b,
	0x60, 0x9a, 0x62, 0xcf, 0x67, 0x1c, 0x53, 0xec, 0xda, 0x88, 0xcb, 0xfa, 0x3a, 0x6b, 0xce, 0x56,
	0xfa, 0x57, 0x9b, 0xdc, 0x9c, 0x07, 0x93, 0xc8, 0xe1, 0x7e, 0xaa, 0x0a, 0x6a, 0x0a, 0xea, 0x93,
	0xf5, 0xa1, 0x01, 0x66, 0x7a, 0x0f, 0x6e, 0x93, 0xe8, 0xc8, 0xf7, 0xcc, 0xaf, 0x83, 0xd9, 0x47,
	0x88, 0x46, 0x7e, 0xe4, 0xd9, 0xbc, 0x43, 0x31, 0xeb, 0x90, 0x40, 0x45, 0xb4, 0x08, 0x6b, 0x9a,
	0x71, 0x90, 0xd1, 0xcd, 0x75, 0x60, 0x3a, 0xd4, 0xe7, 0xbe, 0x83, 0x82, 0x01, 0xe9, 0x82, 0x94,
	0x9e, 0xcd, 0x38, 0x7d, 0xf1, 0x9c, 0xdf, 0xc5, 0xbc, 0xdf, 0xd6, 0xaf, 0x0a, 0x00, 0xec, 0x35,
	0xef, 0xef, 0xa3, 0x6e, 0x40, 0x90, 0x84, 0x2e, 0xc4, 0x8c, 0x21, 0x0f, 0xdb, 0xbc, 0x1b, 0x63,
	0x69, 0xca, 0x34, 0x2c, 0x6b, 0xda, 0x41, 0x37, 0xce, 0xc1, 0x5f, 0xc8, 0xc1, 0x3f, 0xd2, 0x55,
	0x8a, 0xaf, 0xad, 0xab, 0x8c, 0x74, 0xc0, 0xf1, 0xd7, 0xd0, 0x01, 0xdf, 0x02, 0xa5, 0xde, 0xdc,
	0x91, 0x90, 0x17, 0x61, 0x9f, 0x60, 0xfd, 0xd2, 0x00, 0xb5, 0x5b, 0x28, 0x08, 0x0e, 0x91, 0xf3,
	0xb0, 0xcd, 0x29, 0xe2, 0xd8, 0xeb, 0x9a, 0xeb, 0xe0, 0x62, 0xc2, 0xb0, 0x2d, 0xfb, 0xdb, 0xc3,
	0x88, 0x3c, 0x8a, 0x6c, 0x8f, 0x10, 0x05, 0xda, 0x14, 0xac, 0x25, 0x0c, 0xef, 0x22, 0xc6, 0xbf,
	0x2b, 0x18, 0xb7, 0x09, 0x71, 0x4d, 0x4b, 0xa1, 0xe0, 0x20, 0xa7, 0x83, 0x6d, 0xe4, 0x61, 0x8d,
	0x57, 0x39, 0x44, 0xc7, 0xdb, 0x82, 0xd6, 0xf4, 0xb0, 0xf9, 0x36, 0x98, 0x41, 0x01, 0xa6, 0x7c,
	0x00, 0x55, 0x85, 0x55, 0x55, 0x92, 0x7b, 0x90, 0x5a, 0x9f, 0x15, 0xc0, 0xbc, 0xaa, 0xc2, 0xdb,
	0x24, 0xc5, 0x34, 0x42, 0x91, 0x83, 0xf7, 0x11, 0x45, 0x21, 0x33, 0xeb, 0xe0, 0xa2, 0x78, 0x47,
	0x75, 0x5c, 0xdb, 0x8f, 0x38, 0xa6, 0x29, 0x0a, 0x74, 0x2e, 0xcd, 0x86, 0xe8, 0x58, 0xf5, 0xd4,
	0x96, 0x66, 0x48, 0x79, 0x3f, 0xca, 0xc9, 0xeb, 0x6c, 0x0a, 0xfd, 0x68, 0x44, 0xfe, 0x1b, 0x60,
	0x41, 0xe8, 0x97, 0x98, 0xda, 0x2e, 0x4e, 0x7d, 0x59, 0x8d, 0xf6, 0x61, 0xac, 0xf2, 0x6a, 0x02,
	0xce, 0x85, 0xe8, 0x58, 0xe2, 0x74, 0x33, 0x63, 0x6e, 0xc5, 0xcc, 0x3c, 0x00, 0xb3, 0x2e, 0x3e,
	0x92, 0xc3, 0x6d, 0xb8, 0x00, 0xcb, 0x1b, 0x6f, 0xd7, 0x4f, 0xde, 0x3b, 0xea, 0x23, 0x45, 0x02,
	0x6b, 0x5a, 0x43, 0xbf, 0x5a, 0xdb, 0x20, 0xa3, 0xd9, 0x47, 0x1a, 0x1f, 0x5d, 0xb0, 0x6b, 0xa7,
	0x29, 0x1d, 0xc5, 0x11, 0xce, 0x68, 0x0d, 0x19, 0xc3, 0xfa, 0xbd, 0x01, 0xca, 0x4d, 0x11, 0x6f,
	0x5d, 0x9b, 0xef, 0x80, 0x39, 0x69, 0xb2, 0xed, 0x22, 0x8e, 0x72, 0xe5, 0x69, 0x4a, 0xde, 0x4d,
	0xc4, 0x51, 0xbf, 0xe2, 0x36, 0xc1, 0xd2, 0x68, 0x7c, 0x86, 0xeb, 0x74, 0x02, 0x2e, 0xc4, 0x43,
	0x21, 0xea, 0xdf, 0xbd, 0x01, 0x16, 0x8e, 0x90, 0x1f, 0x60, 0x37, 0x83, 0x64, 0x38, 0x17, 0x26,
	0xe0, 0x25, 0xc5, 0x56, 0xb0, 0xf4, 0x53, 0xe2, 0xef, 0x05, 0x50, 0x51, 0x29, 0xd1, 0xe6, 0x88,
	0x27, 0xcc, 0xbc, 0x0c, 0x4a, 0xba, 0xb5, 0xea, 0xe6, 0x5c, 0x82, 0x53, 0x8a, 0x90, 0x1f, 0x5c,
	0xf9, 0xe2, 0xbd, 0x0d, 0x2a, 0x32, 0xb3, 0x59, 0xe2, 0x38, 0x59, 0xcf, 0x38, 0x6b, 0x1b, 0x94,
	0x33, 0xbf, 0xad, 0x2e, 0x9a, 0xef, 0x82, 0x39, 0x87, 0x44, 0x0c, 0x3b, 0x89, 0x68, 0x7e, 0xb6,
	0x30, 0x3e, 0xa1, 0x58, 0x61, 0x3f, 0x01, 0x2f, 0x0e, 0xf0, 0x6e, 0x69, 0x96, 0x79, 0x05, 0x00,
	0x5f, 0xd4, 0x36, 0x0a, 0x78, 0xa7, 0x2b, 0xf1, 0x9c, 0x82, 0x25, 0x9f, 0xdd, 0x51, 0x04, 0xf3,
	0x1e, 0x98, 0xe9, 0xa5, 0x90, 0x1d, 0xe0, 0x14, 0x07, 0xb2, 0xc1, 0x56, 0x37, 0xbe, 0xf6, 0xc2,
	0x44, 0xda, 0x15, 0xd2, 0xb0, 0xca, 0x86, 0xce, 0xe2, 0x3d, 0xe9, 0x2b, 0xa6, 0x94, 0x50, 0xb9,
	0xa4, 0x94, 0x60, 0x49, 0x50, 0x76, 0x04, 0xc1, 0xfa, 0x53, 0x01, 0x2c, 0x6c, 0x8b, 0x65, 0x53,
	0x8e, 0x2c, 0xbd, 0x87, 0xa8, 0x46, 0x28, 0xae, 0x86, 0xc8, 0x0f, 0x0e, 0xc9, 0x71, 0x16, 0xe5,
	0x0a, 0x2c, 0x69, 0xca, 0xd9, 0x26, 0xe0, 0x3c, 0x98, 0x64, 0x38, 0x72, 0x31, 0x95, 0x21, 0xae,
	0x40, 0x7d, 0x32, 0x97, 0xc1, 0x54, 0x88, 0x39, 0x12, 0x39, 0x27, 0x63, 0x55, 0x81, 0xbd, 0xb3,
	0xb9, 0x08, 0x2e, 0xc4, 0xaa, 0x51, 0xcb, 0xe8, 0x54, 0x60, 0x76, 0x14, 0x0b, 0x17, 0xc5, 0x0e,
	0xf6, 0x53, 0x35, 0xbc, 0x26, 0x5f, 0x66, 0xe1, 0xca, 0x2e, 0x36, 0xb9, 0x98, 0x82, 0x31, 0x25,
	0xa9, 0xef, 0x62, 0xaa, 0xfa, 0xff, 0x05, 0x19, 0xe0, 0xaf, 0x9e, 0x16, 0xe0, 0x7d, 0x2d, 0x2c,
	0x06, 0x03, 0xac, 0xc4, 0x03, 0x27, 0xeb, 0xc3, 0x22, 0x30, 0x55, 0xcc, 0x54, 0xc6, 0x42, 0xcc,
	0x92, 0x80, 0xbf, 0x78, 0x79, 0xf8, 0x11, 0x98, 0x89, 0xf0, 0x23, 0x7b, 0x70, 0x82, 0x14, 0x5e,
	0x69, 0x82, 0x4c, 0x47, 0xf8, 0x51, 0xbb, 0x3f, 0x44, 0xee, 0x01, 0xd0, 0xd3, 0x9f, 0x6d, 0x1d,
	0x2f, 0x3f, 0x43, 0x4a, 0x99, 0x52, 0x66, 0x3e, 0x00, 0xd5, 0x9e, 0x47, 0x29, 0x0a, 0x12, 0x7c,
	0xee, 0xc1, 0x34, 0x9d, 0xe9, 0xb9, 0x2f, 0xd4, 0x88, 0x71, 0xa7, 0x5a, 0x81, 0x6b, 0x47, 0x28,
	0x3d, 0xff, 0xc2, 0xaf, 0x95, 0xec, 0xa1, 0xd4, 0xfa, 0x6b, 0x11, 0xcc, 0xde, 0x65, 0x1e, 0xd4,
	0xeb, 0x8a, 0x5e, 0xe8, 0x6e, 0x80, 0x12, 0x4a, 0x78, 0x87, 0x50, 0x9f, 0x77, 0xf5, 0x3e, 0xbd,
	0xf8, 0xe9, 0xc7, 0xeb, 0x73, 0x5a, 0x93, 0xde, 0xa3, 0xda, 0x9c, 0xfa, 0x91, 0x07, 0xfb, 0xa2,
	0x2f, 0x6e, 0x26, 0x6f, 0x72, 0xcb, 0x1b, 0x2d, 0xb9, 0xf1, 0x7c, 0xc9, 0xe5, 0x16, 0xa2, 0x89,
	0x93, 0x17, 0xc1, 0xe1, 0x12, 0x98, 0x3c, 0x6f, 0x09, 0x88, 0xe5, 0x8e, 0x50, 0xdf, 0x93, 0x5f,
	0x10, 0x38, 0xe2, 0xfe, 0x91, 0x8f, 0xb3, 0x36, 0x53, 0x53, 0x8c, 0x56, 0x8f, 0xbe, 0xb9, 0xf9,
	0xfe, 0x47, 0xab, 0x63, 0xff, 0xf9, 0x68, 0x75, 0xec, 0xa7, 0xcf, 0x1f, 0x5f, 0xef, 0x07, 0xf9,
	0xe7, 0xcf, 0x1f, 0x5f, 0x5f, 0xcd, 0x7d, 0x03, 0x0f, 0x03, 0x68, 0xfd, 0xd6, 0x00, 0x4b, 0x39,
	0x58, 0x21, 0x66, 0xb1, 0x68, 0xb2, 0xaf, 0x38, 0x10, 0x72, 0x8b, 0x71, 0xf1, 0xbc, 0x8b, 0xb1,
	0xf5, 0x5f, 0x03, 0x5c, 0xba, 0xcb, 0x3c, 0xd5, 0x0f, 0x94, 0x91, 0x7a, 0xd4, 0x9e, 0x37, 0x03,
	0x87, 0x5c, 0x2b, 0x8c, 0xb8, 0x76, 0x96, 0xfd, 0x77, 0x60, 0x59, 0x1f, 0x1f, 0x5c, 0xd6, 0x37,
	0xbf, 0x73, 0x3a, 0x1c, 0xd7, 0x72, 0x70, 0xe4, 0x3d, 0xb2, 0x7e, 0x61, 0x80, 0x2b, 0x27, 0xfa,
	0x7a, 0x36, 0x58, 0xee, 0x82, 0x6a, 0x56, 0xfb, 0x8e, 0xbc, 0x26, 0xbd, 0x2b, 0x9f, 0x3e, 0xea,
	0x46, 0x3e, 0x36, 0xa7, 0xf5, 0x6d, 0x6d, 0xcd, 0x1f, 0x0d, 0x30, 0x23, 0x13, 0x24, 0x24, 0x29,
	0x7e, 0xc5, 0xaa, 0xff, 0xc2, 0x98, 0xcf, 0x83, 0x49, 0x8a, 0x11, 0x23, 0x91, 0xaa, 0x74, 0xa8,
	0x4f, 0x9b, 0xdf, 0x3c, 0x3d, 0x9c, 0x57, 0x4e, 0xc8, 0xee, 0xbe, 0x99, 0xd6, 0xaf, 0x0d, 0xb0,
	0x30, 0x62, 0xfa, 0x6b, 0xca, 0xec, 0x6d, 0x00, 0xa8, 0xd4, 0xfa, 0xd2, 0x69, 0x5d, 0xd2, 0xf7,
	0x9a, 0xdc, 0xfa, 0x67, 0x3e, 0xa7, 0xf5, 0x42, 0x7e, 0xde, 0xf8, 0xee, 0x82, 0xc9, 0x58, 0x6a,
	0xd0, 0x90, 0xd7, 0x4f, 0x83, 0xfc, 0xe4, 0x0f, 0x81, 0xad, 0x71, 0x61, 0x26, 0xd4, 0x3a, 0xce,
	0x9f, 0xc7, 0x4a, 0x9b, 0xf5, 0x97, 0x7c, 0x1e, 0x2b, 0x4e, 0x0f, 0x84, 0x1f, 0x82, 0x99, 0x98,
	0xe2, 0xd4, 0x27, 0x09, 0xb3, 0xb5, 0xe1, 0xc6, 0x2b, 0x18, 0x5e, 0xcd, 0x94, 0xe9, 0x30, 0xb6,
	0xd5, 0xbc, 0x7e, 0x0d, 0x21, 0x11, 0x33, 0x5b, 0x11, 0xae, 0xff, 0xcc, 0x00, 0xd5, 0xe1, 0xe5,
	0xd0, 0x5c, 0x02, 0x97, 0xda, 0x07, 0xcd, 0xdd, 0x9d, 0xbd, 0x9d, 0x76, 0xdb, 0xde, 0xdd, 0xb9,
	0xbf, 0xb3, 0x6b, 0xdf, 0x82, 0x3b, 0xed, 0x3b, 0xb5, 0xb1, 0x93, 0x58, 0xf2, 0x5c, 0x33, 0xcc,
	0xcb, 0x60, 0x61, 0x94, 0xf5, 0xa0, 0x09, 0xf7, 0x5a, 0x7b, 0xb7, 0x6b, 0x05, 0xf3, 0x2d, 0xb0,
	0x38, 0xca, 0xdc, 0x86, 0xad, 0x83, 0xd6, 0x76, 0x73, 0xb7, 0x56, 0x5c, 0x1e, 0x7f, 0xff, 0x37,
	0x2b, 0x63, 0x5b, 0xdf, 0x7e, 0xf2, 0x74, 0xc5, 0xf8, 0xe4, 0xe9, 0x8a, 0xf1, 0xef, 0xa7, 0x2b,
	0xc6, 0x07, 0xcf, 0x56, 0xc6, 0x3e, 0x79, 0xb6, 0x32, 0xf6, 0x8f, 0x67, 0x2b, 0x63, 0x3f, 0xd0,
	0xf0, 0x68, 0x57, 0x8f, 0xbb, 0x3f, 0x69, 0xa4, 0xef, 0x35, 0xc4, 0x44, 0x62, 0x7d, 0xc4, 0x0e,
	0x27, 0x65, 0x9e, 0xbe, 0xf7, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x13, 0x6b, 0x38, 0x37, 0xe8,
	0x15, 0x00, 0x00,
}

func (m *RemotePositionOracle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemotePositionOracle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemotePositionOracle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastUpdate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdate):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintOracle(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x3a
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.SharesHeld.Size()
		i -= size
		if _, err := m.SharesHeld.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.OracleAddress.Size()
		i -= size
		if _, err := m.OracleAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ChainId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x10
	}
	if m.PositionId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OracleMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x18
	}
	if m.ChainId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.OracleAddress.Size()
		i -= size
		if _, err := m.OracleAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EnrolledOracleRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnrolledOracleRouter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnrolledOracleRouter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.OracleAddress.Size()
		i -= size
		if _, err := m.OracleAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnrolledOracle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnrolledOracle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnrolledOracle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RegisteredAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.RegisteredAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintOracle(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x2a
	if m.MaxStaleness != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxStaleness))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.OracleAddress.Size()
		i -= size
		if _, err := m.OracleAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StalenessConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StalenessConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StalenessConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxStaleness != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxStaleness))
		i--
		dAtA[i] = 0x18
	}
	if m.CriticalThreshold != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.CriticalThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.WarningThreshold != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.WarningThreshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NAVPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NAVPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NAVPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.SharesHeld.Size()
		i -= size
		if _, err := m.SharesHeld.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PositionId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x10
	}
	if m.MessageType != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FallbackStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FallbackStrategy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FallbackStrategy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AlertThreshold != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AlertThreshold))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxCacheAge != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxCacheAge))
		i--
		dAtA[i] = 0x10
	}
	if m.UseLastKnownGood {
		i--
		if m.UseLastKnownGood {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OracleGovernanceParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleGovernanceParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleGovernanceParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultFallback != nil {
		{
			size, err := m.DefaultFallback.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOracle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DefaultStaleness != nil {
		{
			size, err := m.DefaultStaleness.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOracle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxPriceDeviationBps != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxPriceDeviationBps))
		i--
		dAtA[i] = 0x18
	}
	if m.MinUpdateInterval != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MinUpdateInterval))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxUpdateInterval != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxUpdateInterval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlertConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlertConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FailedUpdateThreshold != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.FailedUpdateThreshold))
		i--
		dAtA[i] = 0x18
	}
	if m.PriceDeviationThreshold != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PriceDeviationThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.StaleDataThreshold != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.StaleDataThreshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OracleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LastError) > 0 {
		i -= len(m.LastError)
		copy(dAtA[i:], m.LastError)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.LastError)))
		i--
		dAtA[i] = 0x3a
	}
	if m.StalenessLevel != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.StalenessLevel))
		i--
		dAtA[i] = 0x30
	}
	if m.IsHealthy {
		i--
		if m.IsHealthy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ConsecutiveFailures != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ConsecutiveFailures))
		i--
		dAtA[i] = 0x20
	}
	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastSuccess, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSuccess):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintOracle(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x1a
	if m.PositionId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.OracleId) > 0 {
		i -= len(m.OracleId)
		copy(dAtA[i:], m.OracleId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.OracleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainOracleMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainOracleMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainOracleMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProviderType != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ProviderType))
		i--
		dAtA[i] = 0x38
	}
	n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ReceivedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ReceivedAt):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintOracle(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x32
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MailboxId) > 0 {
		i -= len(m.MailboxId)
		copy(dAtA[i:], m.MailboxId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.MailboxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleUpdateResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleUpdateResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleUpdateResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.UpdatedNav.Size()
		i -= size
		if _, err := m.UpdatedNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.PositionValue.Size()
		i -= size
		if _, err := m.PositionValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.NewShares.Size()
		i -= size
		if _, err := m.NewShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.NewSharePrice.Size()
		i -= size
		if _, err := m.NewSharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PositionId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterOracle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterOracle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterOracle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OriginIdentifier) > 0 {
		i -= len(m.OriginIdentifier)
		copy(dAtA[i:], m.OriginIdentifier)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.OriginIdentifier)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ProviderType != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.ProviderType))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxStaleness != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxStaleness))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.OracleAddress.Size()
		i -= size
		if _, err := m.OracleAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PositionId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterOracleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterOracleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterOracleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RegisteredAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.RegisteredAt):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintOracle(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x1a
	if m.PositionId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.OracleId) > 0 {
		i -= len(m.OracleId)
		copy(dAtA[i:], m.OracleId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.OracleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateOracleConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateOracleConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateOracleConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MaxStaleness != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.MaxStaleness))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OracleId) > 0 {
		i -= len(m.OracleId)
		copy(dAtA[i:], m.OracleId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.OracleId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateOracleConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateOracleConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateOracleConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdatedConfig != nil {
		{
			size, err := m.UpdatedConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOracle(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.OracleId) > 0 {
		i -= len(m.OracleId)
		copy(dAtA[i:], m.OracleId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.OracleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveOracle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveOracle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveOracle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OracleId) > 0 {
		i -= len(m.OracleId)
		copy(dAtA[i:], m.OracleId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.OracleId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveOracleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveOracleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveOracleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n9, err9 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RemovedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.RemovedAt):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintOracle(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x1a
	if m.PositionId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.OracleId) > 0 {
		i -= len(m.OracleId)
		copy(dAtA[i:], m.OracleId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.OracleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateOracleParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateOracleParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateOracleParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateOracleParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateOracleParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateOracleParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NewParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.PreviousParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOracle(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintOracle(dAtA []byte, offset int, v uint64) int {
	offset -= sovOracle(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RemotePositionOracle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovOracle(uint64(m.PositionId))
	}
	if m.ChainId != 0 {
		n += 1 + sovOracle(uint64(m.ChainId))
	}
	l = m.OracleAddress.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = m.SharesHeld.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUpdate)
	n += 1 + l + sovOracle(uint64(l))
	return n
}

func (m *OracleMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OracleAddress.Size()
	n += 1 + l + sovOracle(uint64(l))
	if m.ChainId != 0 {
		n += 1 + sovOracle(uint64(m.ChainId))
	}
	if m.PositionId != 0 {
		n += 1 + sovOracle(uint64(m.PositionId))
	}
	return n
}

func (m *EnrolledOracleRouter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovOracle(uint64(m.PositionId))
	}
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = m.OracleAddress.Size()
	n += 1 + l + sovOracle(uint64(l))
	return n
}

func (m *EnrolledOracle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovOracle(uint64(m.PositionId))
	}
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = m.OracleAddress.Size()
	n += 1 + l + sovOracle(uint64(l))
	if m.MaxStaleness != 0 {
		n += 1 + sovOracle(uint64(m.MaxStaleness))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RegisteredAt)
	n += 1 + l + sovOracle(uint64(l))
	if m.Active {
		n += 2
	}
	return n
}

func (m *StalenessConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WarningThreshold != 0 {
		n += 1 + sovOracle(uint64(m.WarningThreshold))
	}
	if m.CriticalThreshold != 0 {
		n += 1 + sovOracle(uint64(m.CriticalThreshold))
	}
	if m.MaxStaleness != 0 {
		n += 1 + sovOracle(uint64(m.MaxStaleness))
	}
	return n
}

func (m *NAVPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageType != 0 {
		n += 1 + sovOracle(uint64(m.MessageType))
	}
	if m.PositionId != 0 {
		n += 1 + sovOracle(uint64(m.PositionId))
	}
	l = m.SharePrice.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = m.SharesHeld.Size()
	n += 1 + l + sovOracle(uint64(l))
	if m.Timestamp != 0 {
		n += 1 + sovOracle(uint64(m.Timestamp))
	}
	return n
}

func (m *FallbackStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseLastKnownGood {
		n += 2
	}
	if m.MaxCacheAge != 0 {
		n += 1 + sovOracle(uint64(m.MaxCacheAge))
	}
	if m.AlertThreshold != 0 {
		n += 1 + sovOracle(uint64(m.AlertThreshold))
	}
	return n
}

func (m *OracleGovernanceParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxUpdateInterval != 0 {
		n += 1 + sovOracle(uint64(m.MaxUpdateInterval))
	}
	if m.MinUpdateInterval != 0 {
		n += 1 + sovOracle(uint64(m.MinUpdateInterval))
	}
	if m.MaxPriceDeviationBps != 0 {
		n += 1 + sovOracle(uint64(m.MaxPriceDeviationBps))
	}
	if m.DefaultStaleness != nil {
		l = m.DefaultStaleness.Size()
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.DefaultFallback != nil {
		l = m.DefaultFallback.Size()
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *AlertConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StaleDataThreshold != 0 {
		n += 1 + sovOracle(uint64(m.StaleDataThreshold))
	}
	if m.PriceDeviationThreshold != 0 {
		n += 1 + sovOracle(uint64(m.PriceDeviationThreshold))
	}
	if m.FailedUpdateThreshold != 0 {
		n += 1 + sovOracle(uint64(m.FailedUpdateThreshold))
	}
	return n
}

func (m *OracleStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OracleId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.PositionId != 0 {
		n += 1 + sovOracle(uint64(m.PositionId))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSuccess)
	n += 1 + l + sovOracle(uint64(l))
	if m.ConsecutiveFailures != 0 {
		n += 1 + sovOracle(uint64(m.ConsecutiveFailures))
	}
	if m.IsHealthy {
		n += 2
	}
	if m.StalenessLevel != 0 {
		n += 1 + sovOracle(uint64(m.StalenessLevel))
	}
	l = len(m.LastError)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *CrossChainOracleMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MailboxId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.ReceivedAt)
	n += 1 + l + sovOracle(uint64(l))
	if m.ProviderType != 0 {
		n += 1 + sovOracle(uint64(m.ProviderType))
	}
	return n
}

func (m *OracleUpdateResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovOracle(uint64(m.PositionId))
	}
	l = m.NewSharePrice.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = m.NewShares.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = m.PositionValue.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = m.UpdatedNav.Size()
	n += 1 + l + sovOracle(uint64(l))
	return n
}

func (m *MsgRegisterOracle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.PositionId != 0 {
		n += 1 + sovOracle(uint64(m.PositionId))
	}
	l = m.OracleAddress.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.MaxStaleness != 0 {
		n += 1 + sovOracle(uint64(m.MaxStaleness))
	}
	if m.ProviderType != 0 {
		n += 1 + sovOracle(uint64(m.ProviderType))
	}
	l = len(m.OriginIdentifier)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *MsgRegisterOracleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OracleId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.PositionId != 0 {
		n += 1 + sovOracle(uint64(m.PositionId))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RegisteredAt)
	n += 1 + l + sovOracle(uint64(l))
	return n
}

func (m *MsgUpdateOracleConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.OracleId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.MaxStaleness != 0 {
		n += 1 + sovOracle(uint64(m.MaxStaleness))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *MsgUpdateOracleConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OracleId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.UpdatedConfig != nil {
		l = m.UpdatedConfig.Size()
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *MsgRemoveOracle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.OracleId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *MsgRemoveOracleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OracleId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.PositionId != 0 {
		n += 1 + sovOracle(uint64(m.PositionId))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RemovedAt)
	n += 1 + l + sovOracle(uint64(l))
	return n
}

func (m *MsgUpdateOracleParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovOracle(uint64(l))
	return n
}

func (m *MsgUpdateOracleParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PreviousParams.Size()
	n += 1 + l + sovOracle(uint64(l))
	l = m.NewParams.Size()
	n += 1 + l + sovOracle(uint64(l))
	return n
}

func sovOracle(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOracle(x uint64) (n int) {
	return sovOracle(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RemotePositionOracle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemotePositionOracle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemotePositionOracle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OracleAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesHeld", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesHeld.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OracleAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnrolledOracleRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnrolledOracleRouter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnrolledOracleRouter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OracleAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnrolledOracle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnrolledOracle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnrolledOracle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OracleAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStaleness", wireType)
			}
			m.MaxStaleness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxStaleness |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RegisteredAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StalenessConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StalenessConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StalenessConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarningThreshold", wireType)
			}
			m.WarningThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarningThreshold |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CriticalThreshold", wireType)
			}
			m.CriticalThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CriticalThreshold |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStaleness", wireType)
			}
			m.MaxStaleness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxStaleness |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NAVPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NAVPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NAVPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesHeld", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesHeld.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FallbackStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FallbackStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FallbackStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLastKnownGood", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseLastKnownGood = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCacheAge", wireType)
			}
			m.MaxCacheAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCacheAge |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertThreshold", wireType)
			}
			m.AlertThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlertThreshold |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleGovernanceParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleGovernanceParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleGovernanceParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUpdateInterval", wireType)
			}
			m.MaxUpdateInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUpdateInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUpdateInterval", wireType)
			}
			m.MinUpdateInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUpdateInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPriceDeviationBps", wireType)
			}
			m.MaxPriceDeviationBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPriceDeviationBps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStaleness", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultStaleness == nil {
				m.DefaultStaleness = &StalenessConfig{}
			}
			if err := m.DefaultStaleness.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFallback", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultFallback == nil {
				m.DefaultFallback = &FallbackStrategy{}
			}
			if err := m.DefaultFallback.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleDataThreshold", wireType)
			}
			m.StaleDataThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StaleDataThreshold |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceDeviationThreshold", wireType)
			}
			m.PriceDeviationThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceDeviationThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedUpdateThreshold", wireType)
			}
			m.FailedUpdateThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailedUpdateThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastSuccess, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveFailures", wireType)
			}
			m.ConsecutiveFailures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsecutiveFailures |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHealthy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHealthy = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalenessLevel", wireType)
			}
			m.StalenessLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StalenessLevel |= StalenessLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainOracleMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainOracleMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainOracleMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailboxId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailboxId = append(m.MailboxId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailboxId == nil {
				m.MailboxId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.ReceivedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderType", wireType)
			}
			m.ProviderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProviderType |= ProviderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleUpdateResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleUpdateResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleUpdateResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewSharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PositionValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterOracle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterOracle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterOracle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OracleAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStaleness", wireType)
			}
			m.MaxStaleness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxStaleness |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderType", wireType)
			}
			m.ProviderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProviderType |= ProviderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterOracleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterOracleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterOracleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RegisteredAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateOracleConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateOracleConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateOracleConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStaleness", wireType)
			}
			m.MaxStaleness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxStaleness |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateOracleConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateOracleConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateOracleConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedConfig == nil {
				m.UpdatedConfig = &EnrolledOracle{}
			}
			if err := m.UpdatedConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveOracle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveOracle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveOracle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveOracleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveOracleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveOracleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RemovedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateOracleParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateOracleParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateOracleParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateOracleParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateOracleParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateOracleParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreviousParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOracle(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOracle
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOracle
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOracle
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOracle        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOracle          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOracle = fmt.Errorf("proto: unexpected end of group")
)
