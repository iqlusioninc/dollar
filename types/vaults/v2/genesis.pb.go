// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/genesis.proto

package v2

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the V2 vaults module's genesis state
type GenesisState struct {
	// Module parameters
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	// V2 vault configurations
	VaultConfig VaultConfig `protobuf:"bytes,2,opt,name=vault_config,json=vaultConfig,proto3" json:"vault_config"`
	// All user positions in V2
	UserPositions []UserPositionEntry `protobuf:"bytes,3,rep,name=user_positions,json=userPositions,proto3" json:"user_positions"`
	// Current NAV information for each vault type
	NavEntries []NAVEntry `protobuf:"bytes,4,rep,name=nav_entries,json=navEntries,proto3" json:"nav_entries"`
	// Withdrawal queue entries
	WithdrawalQueue []WithdrawalRequestEntry `protobuf:"bytes,5,rep,name=withdrawal_queue,json=withdrawalQueue,proto3" json:"withdrawal_queue"`
	// Total deposits and yield
	VaultTotals VaultTotalEntry `protobuf:"bytes,6,opt,name=vault_totals,json=vaultTotals,proto3" json:"vault_totals"`
	// Vault statistics
	VaultStats VaultStatsEntry `protobuf:"bytes,7,opt,name=vault_stats,json=vaultStats,proto3" json:"vault_stats"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{0}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

func (m *GenesisState) GetVaultConfig() VaultConfig {
	if m != nil {
		return m.VaultConfig
	}
	return VaultConfig{}
}

func (m *GenesisState) GetUserPositions() []UserPositionEntry {
	if m != nil {
		return m.UserPositions
	}
	return nil
}

func (m *GenesisState) GetNavEntries() []NAVEntry {
	if m != nil {
		return m.NavEntries
	}
	return nil
}

func (m *GenesisState) GetWithdrawalQueue() []WithdrawalRequestEntry {
	if m != nil {
		return m.WithdrawalQueue
	}
	return nil
}

func (m *GenesisState) GetVaultTotals() VaultTotalEntry {
	if m != nil {
		return m.VaultTotals
	}
	return VaultTotalEntry{}
}

func (m *GenesisState) GetVaultStats() VaultStatsEntry {
	if m != nil {
		return m.VaultStats
	}
	return VaultStatsEntry{}
}

// Params defines the parameters for the V2 vaults module
type Params struct {
	// Authority address that can update parameters
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Minimum deposit amount
	MinDepositAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=min_deposit_amount,json=minDepositAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_deposit_amount"`
	// Minimum withdrawal amount
	MinWithdrawalAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=min_withdrawal_amount,json=minWithdrawalAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_withdrawal_amount"`
	// Maximum NAV change percentage allowed per update (basis points)
	MaxNavChangeBps int32 `protobuf:"varint,4,opt,name=max_nav_change_bps,json=maxNavChangeBps,proto3" json:"max_nav_change_bps,omitempty"`
	// Withdrawal request timeout duration (in seconds)
	WithdrawalRequestTimeout int64 `protobuf:"varint,5,opt,name=withdrawal_request_timeout,json=withdrawalRequestTimeout,proto3" json:"withdrawal_request_timeout,omitempty"`
	// Maximum number of withdrawal requests to process per block
	MaxWithdrawalRequestsPerBlock int32 `protobuf:"varint,6,opt,name=max_withdrawal_requests_per_block,json=maxWithdrawalRequestsPerBlock,proto3" json:"max_withdrawal_requests_per_block,omitempty"`
	// Whether V2 vault are enabled
	VaultEnabled bool `protobuf:"varint,7,opt,name=vault_enabled,json=vaultEnabled,proto3" json:"vault_enabled,omitempty"`
	// TWAP configuration for share pricing
	TwapConfig TWAPConfig `protobuf:"bytes,8,opt,name=twap_config,json=twapConfig,proto3" json:"twap_config"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{1}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *Params) GetMaxNavChangeBps() int32 {
	if m != nil {
		return m.MaxNavChangeBps
	}
	return 0
}

func (m *Params) GetWithdrawalRequestTimeout() int64 {
	if m != nil {
		return m.WithdrawalRequestTimeout
	}
	return 0
}

func (m *Params) GetMaxWithdrawalRequestsPerBlock() int32 {
	if m != nil {
		return m.MaxWithdrawalRequestsPerBlock
	}
	return 0
}

func (m *Params) GetVaultEnabled() bool {
	if m != nil {
		return m.VaultEnabled
	}
	return false
}

func (m *Params) GetTwapConfig() TWAPConfig {
	if m != nil {
		return m.TwapConfig
	}
	return TWAPConfig{}
}

// VaultConfig stores configuration for a specific vault type
type VaultConfig struct {
	// Whether this vault type is enabled for new deposits
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Maximum total deposits allowed
	MaxTotalDeposits cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=max_total_deposits,json=maxTotalDeposits,proto3,customtype=cosmossdk.io/math.Int" json:"max_total_deposits"`
	// Target yield rate (informational)
	TargetYieldRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=target_yield_rate,json=targetYieldRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"target_yield_rate"`
}

func (m *VaultConfig) Reset()         { *m = VaultConfig{} }
func (m *VaultConfig) String() string { return proto.CompactTextString(m) }
func (*VaultConfig) ProtoMessage()    {}
func (*VaultConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{2}
}
func (m *VaultConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VaultConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VaultConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultConfig.Merge(m, src)
}
func (m *VaultConfig) XXX_Size() int {
	return m.Size()
}
func (m *VaultConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VaultConfig proto.InternalMessageInfo

func (m *VaultConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// UserPositionEntry stores a user's position in the V2 system
type UserPositionEntry struct {
	// User address
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// User position details
	Position UserPosition `protobuf:"bytes,2,opt,name=position,proto3" json:"position"`
}

func (m *UserPositionEntry) Reset()         { *m = UserPositionEntry{} }
func (m *UserPositionEntry) String() string { return proto.CompactTextString(m) }
func (*UserPositionEntry) ProtoMessage()    {}
func (*UserPositionEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{3}
}
func (m *UserPositionEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPositionEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPositionEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPositionEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPositionEntry.Merge(m, src)
}
func (m *UserPositionEntry) XXX_Size() int {
	return m.Size()
}
func (m *UserPositionEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPositionEntry.DiscardUnknown(m)
}

var xxx_messageInfo_UserPositionEntry proto.InternalMessageInfo

func (m *UserPositionEntry) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *UserPositionEntry) GetPosition() UserPosition {
	if m != nil {
		return m.Position
	}
	return UserPosition{}
}

// NAVEntry stores NAV information for a vault type
type NAVEntry struct {
	// NAV information
	NavInfo NAVInfo `protobuf:"bytes,1,opt,name=nav_info,json=navInfo,proto3" json:"nav_info"`
}

func (m *NAVEntry) Reset()         { *m = NAVEntry{} }
func (m *NAVEntry) String() string { return proto.CompactTextString(m) }
func (*NAVEntry) ProtoMessage()    {}
func (*NAVEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{4}
}
func (m *NAVEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NAVEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NAVEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NAVEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NAVEntry.Merge(m, src)
}
func (m *NAVEntry) XXX_Size() int {
	return m.Size()
}
func (m *NAVEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_NAVEntry.DiscardUnknown(m)
}

var xxx_messageInfo_NAVEntry proto.InternalMessageInfo

func (m *NAVEntry) GetNavInfo() NAVInfo {
	if m != nil {
		return m.NavInfo
	}
	return NAVInfo{}
}

// WithdrawalRequestEntry stores a withdrawal request in the queue
type WithdrawalRequestEntry struct {
	// User address
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Withdrawal request details
	WithdrawalRequest WithdrawalRequest `protobuf:"bytes,2,opt,name=withdrawal_request,json=withdrawalRequest,proto3" json:"withdrawal_request"`
}

func (m *WithdrawalRequestEntry) Reset()         { *m = WithdrawalRequestEntry{} }
func (m *WithdrawalRequestEntry) String() string { return proto.CompactTextString(m) }
func (*WithdrawalRequestEntry) ProtoMessage()    {}
func (*WithdrawalRequestEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{5}
}
func (m *WithdrawalRequestEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawalRequestEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawalRequestEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawalRequestEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawalRequestEntry.Merge(m, src)
}
func (m *WithdrawalRequestEntry) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawalRequestEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawalRequestEntry.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawalRequestEntry proto.InternalMessageInfo

func (m *WithdrawalRequestEntry) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *WithdrawalRequestEntry) GetWithdrawalRequest() WithdrawalRequest {
	if m != nil {
		return m.WithdrawalRequest
	}
	return WithdrawalRequest{}
}

// VaultTotalEntry tracks total deposits and yield for a vault type
type VaultTotalEntry struct {
	// Total deposits in the vault
	TotalDeposits cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_deposits,json=totalDeposits,proto3,customtype=cosmossdk.io/math.Int" json:"total_deposits"`
	// Total accrued yield
	TotalAccruedYield cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_accrued_yield,json=totalAccruedYield,proto3,customtype=cosmossdk.io/math.Int" json:"total_accrued_yield"`
	// Total NAV (Net Asset Value = deposits + yield)
	TotalNav cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_nav,json=totalNav,proto3,customtype=cosmossdk.io/math.Int" json:"total_nav"`
}

func (m *VaultTotalEntry) Reset()         { *m = VaultTotalEntry{} }
func (m *VaultTotalEntry) String() string { return proto.CompactTextString(m) }
func (*VaultTotalEntry) ProtoMessage()    {}
func (*VaultTotalEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{6}
}
func (m *VaultTotalEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultTotalEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VaultTotalEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VaultTotalEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultTotalEntry.Merge(m, src)
}
func (m *VaultTotalEntry) XXX_Size() int {
	return m.Size()
}
func (m *VaultTotalEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultTotalEntry.DiscardUnknown(m)
}

var xxx_messageInfo_VaultTotalEntry proto.InternalMessageInfo

// VaultStatsEntry tracks statistics for a vault type
type VaultStatsEntry struct {
	// Total number of depositors
	TotalDepositors uint64 `protobuf:"varint,1,opt,name=total_depositors,json=totalDepositors,proto3" json:"total_depositors,omitempty"`
	// Total value deposited (cumulative)
	TotalDeposited cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_deposited,json=totalDeposited,proto3,customtype=cosmossdk.io/math.Int" json:"total_deposited"`
	// Total value withdrawn (cumulative)
	TotalWithdrawn cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_withdrawn,json=totalWithdrawn,proto3,customtype=cosmossdk.io/math.Int" json:"total_withdrawn"`
	// Total fees collected
	TotalFeesCollected cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=total_fees_collected,json=totalFeesCollected,proto3,customtype=cosmossdk.io/math.Int" json:"total_fees_collected"`
	// Total yield distributed
	TotalYieldDistributed cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=total_yield_distributed,json=totalYieldDistributed,proto3,customtype=cosmossdk.io/math.Int" json:"total_yield_distributed"`
	// Number of active positions
	ActivePositions uint64 `protobuf:"varint,6,opt,name=active_positions,json=activePositions,proto3" json:"active_positions,omitempty"`
}

func (m *VaultStatsEntry) Reset()         { *m = VaultStatsEntry{} }
func (m *VaultStatsEntry) String() string { return proto.CompactTextString(m) }
func (*VaultStatsEntry) ProtoMessage()    {}
func (*VaultStatsEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a687c7a1c262a427, []int{7}
}
func (m *VaultStatsEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultStatsEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VaultStatsEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VaultStatsEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultStatsEntry.Merge(m, src)
}
func (m *VaultStatsEntry) XXX_Size() int {
	return m.Size()
}
func (m *VaultStatsEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultStatsEntry.DiscardUnknown(m)
}

var xxx_messageInfo_VaultStatsEntry proto.InternalMessageInfo

func (m *VaultStatsEntry) GetTotalDepositors() uint64 {
	if m != nil {
		return m.TotalDepositors
	}
	return 0
}

func (m *VaultStatsEntry) GetActivePositions() uint64 {
	if m != nil {
		return m.ActivePositions
	}
	return 0
}

func init() {
	proto.RegisterType((*GenesisState)(nil), "noble.dollar.vaults.v2.GenesisState")
	proto.RegisterType((*Params)(nil), "noble.dollar.vaults.v2.Params")
	proto.RegisterType((*VaultConfig)(nil), "noble.dollar.vaults.v2.VaultConfig")
	proto.RegisterType((*UserPositionEntry)(nil), "noble.dollar.vaults.v2.UserPositionEntry")
	proto.RegisterType((*NAVEntry)(nil), "noble.dollar.vaults.v2.NAVEntry")
	proto.RegisterType((*WithdrawalRequestEntry)(nil), "noble.dollar.vaults.v2.WithdrawalRequestEntry")
	proto.RegisterType((*VaultTotalEntry)(nil), "noble.dollar.vaults.v2.VaultTotalEntry")
	proto.RegisterType((*VaultStatsEntry)(nil), "noble.dollar.vaults.v2.VaultStatsEntry")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v2/genesis.proto", fileDescriptor_a687c7a1c262a427)
}

var fileDescriptor_a687c7a1c262a427 = []byte{
	// 1068 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x96, 0xcf, 0x4f, 0x1b, 0x47,
	0x14, 0xc7, 0xd9, 0x60, 0xc0, 0x8c, 0x01, 0xc3, 0x04, 0xd2, 0x2d, 0x55, 0x0d, 0x35, 0x91, 0x0a,
	0xad, 0xe2, 0xad, 0x88, 0x94, 0x53, 0x2a, 0x15, 0x03, 0x49, 0x91, 0x28, 0xa2, 0x1b, 0x0a, 0x4a,
	0x0f, 0xd9, 0x8e, 0x77, 0x87, 0x65, 0x95, 0xdd, 0x19, 0x67, 0x66, 0x76, 0xb1, 0xfb, 0x57, 0x54,
	0xbd, 0xf6, 0x1f, 0xa8, 0xd4, 0x4b, 0x0f, 0x39, 0xf7, 0x9c, 0x63, 0x94, 0x53, 0xd5, 0x43, 0x54,
	0xc1, 0xa1, 0x87, 0xfc, 0x13, 0xd5, 0xfc, 0x58, 0xbc, 0xe0, 0x18, 0x21, 0xe7, 0x62, 0x79, 0x66,
	0xbf, 0xfb, 0x79, 0xf3, 0xde, 0x7c, 0xdf, 0xd3, 0x82, 0xbb, 0x84, 0xb6, 0x62, 0xec, 0x04, 0x34,
	0x8e, 0x11, 0x73, 0x32, 0x94, 0xc6, 0x82, 0x3b, 0xd9, 0xba, 0x13, 0x62, 0x82, 0x79, 0xc4, 0x1b,
	0x6d, 0x46, 0x05, 0x85, 0x77, 0x94, 0xaa, 0xa1, 0x55, 0x0d, 0xad, 0x6a, 0x64, 0xeb, 0x8b, 0x73,
	0x28, 0x89, 0x08, 0x75, 0xd4, 0xaf, 0x96, 0x2e, 0x7e, 0xec, 0x53, 0x9e, 0x50, 0xee, 0xa9, 0x95,
	0xa3, 0x17, 0xe6, 0xd1, 0x7c, 0x48, 0x43, 0xaa, 0xf7, 0xe5, 0x3f, 0xb3, 0xbb, 0x14, 0x52, 0x1a,
	0xc6, 0xd8, 0x51, 0xab, 0x56, 0x7a, 0xec, 0x88, 0x28, 0xc1, 0x5c, 0xa0, 0xa4, 0x6d, 0x04, 0xcb,
	0x03, 0x8e, 0x48, 0x50, 0x66, 0x14, 0x2b, 0x03, 0x14, 0xe6, 0xa0, 0x4a, 0x54, 0xff, 0xab, 0x04,
	0xa6, 0x1e, 0xeb, 0xac, 0x9e, 0x08, 0x24, 0x30, 0x7c, 0x08, 0xc6, 0xdb, 0x88, 0xa1, 0x84, 0xdb,
	0xd6, 0xb2, 0xb5, 0x5a, 0x59, 0xaf, 0x35, 0xde, 0x9f, 0x65, 0x63, 0x5f, 0xa9, 0x9a, 0xa5, 0x57,
	0x6f, 0x97, 0x46, 0x5c, 0xf3, 0x0e, 0xdc, 0x05, 0x53, 0x4a, 0xe1, 0xf9, 0x94, 0x1c, 0x47, 0xa1,
	0x7d, 0x4b, 0x31, 0x56, 0x06, 0x31, 0x0e, 0xe5, 0xbf, 0x4d, 0x25, 0x35, 0xa0, 0x4a, 0xd6, 0xdb,
	0x82, 0x87, 0x60, 0x26, 0xe5, 0x98, 0x79, 0x6d, 0xca, 0x23, 0x11, 0x51, 0xc2, 0xed, 0xd1, 0xe5,
	0xd1, 0xd5, 0xca, 0xfa, 0xda, 0x20, 0xde, 0x0f, 0x1c, 0xb3, 0x7d, 0x23, 0xde, 0x26, 0x82, 0x75,
	0x0d, 0x75, 0x3a, 0x2d, 0x3c, 0xe0, 0xf0, 0x31, 0xa8, 0x10, 0x94, 0x79, 0x98, 0x08, 0x16, 0x61,
	0x6e, 0x97, 0x14, 0x74, 0x79, 0x10, 0x74, 0x6f, 0xe3, 0xb0, 0xc8, 0x02, 0x04, 0x65, 0xdb, 0xfa,
	0x4d, 0xe8, 0x81, 0xd9, 0xd3, 0x48, 0x9c, 0x04, 0x0c, 0x9d, 0xa2, 0xd8, 0x7b, 0x91, 0xe2, 0x14,
	0xdb, 0x63, 0x8a, 0xd6, 0x18, 0x44, 0x3b, 0xba, 0xd0, 0xbb, 0xf8, 0x45, 0x8a, 0xb9, 0x28, 0xb2,
	0xab, 0x3d, 0xda, 0xf7, 0x12, 0x06, 0xf7, 0xf3, 0x7a, 0x0a, 0x2a, 0x50, 0xcc, 0xed, 0x71, 0x55,
	0xcf, 0xcf, 0xaf, 0xad, 0xe7, 0x81, 0x94, 0x16, 0xa9, 0xba, 0xa6, 0x6a, 0x9b, 0xc3, 0x3d, 0xa0,
	0x97, 0x1e, 0x17, 0x48, 0x70, 0x7b, 0xe2, 0x06, 0x40, 0x69, 0x0c, 0x7e, 0xa9, 0x04, 0xd9, 0xc5,
	0x76, 0xfd, 0x8f, 0x12, 0x18, 0xd7, 0x56, 0x80, 0x0f, 0xc0, 0x24, 0x4a, 0xc5, 0x09, 0x65, 0x91,
	0xe8, 0x2a, 0xf7, 0x4c, 0x36, 0xed, 0x37, 0x2f, 0xef, 0xcd, 0x1b, 0xbb, 0x6f, 0x04, 0x01, 0xc3,
	0x9c, 0x3f, 0x11, 0x2c, 0x22, 0xa1, 0xdb, 0x93, 0xc2, 0x67, 0x00, 0x26, 0x11, 0xf1, 0x02, 0xac,
	0xee, 0xd9, 0x43, 0x09, 0x4d, 0x89, 0x50, 0xd6, 0x99, 0x6c, 0x7e, 0x25, 0x03, 0xfe, 0xf3, 0x76,
	0x69, 0x41, 0x43, 0x78, 0xf0, 0xbc, 0x11, 0x51, 0x27, 0x41, 0xe2, 0xa4, 0xb1, 0x43, 0xc4, 0x9b,
	0x97, 0xf7, 0x80, 0xa1, 0xef, 0x10, 0xf1, 0xfb, 0x7f, 0x7f, 0x7e, 0x61, 0xb9, 0xb3, 0x49, 0x44,
	0xb6, 0x34, 0x6a, 0x43, 0x91, 0x60, 0x00, 0x16, 0x24, 0xbf, 0x70, 0x53, 0x26, 0xc4, 0xe8, 0x90,
	0x21, 0x6e, 0x27, 0x11, 0xe9, 0xdd, 0xa3, 0x89, 0xf2, 0x25, 0x80, 0x09, 0xea, 0x78, 0xd2, 0x58,
	0xfe, 0x09, 0x22, 0x21, 0xf6, 0x5a, 0x6d, 0xe9, 0x2d, 0x6b, 0x75, 0xcc, 0xad, 0x26, 0xa8, 0xb3,
	0x87, 0xb2, 0x4d, 0xb5, 0xdf, 0x6c, 0x73, 0xf8, 0x10, 0x2c, 0x16, 0x8e, 0xc3, 0xb4, 0x13, 0x3c,
	0xd9, 0xe3, 0x34, 0x15, 0xf6, 0xd8, 0xb2, 0xb5, 0x3a, 0xea, 0xda, 0xa7, 0x57, 0xad, 0x72, 0xa0,
	0x9f, 0xc3, 0x6f, 0xc1, 0x67, 0x32, 0x54, 0x3f, 0x81, 0x7b, 0x6d, 0xcc, 0xbc, 0x56, 0x4c, 0xfd,
	0xe7, 0xca, 0x2a, 0x63, 0xee, 0xa7, 0x09, 0xea, 0xf4, 0x59, 0x8e, 0xef, 0x63, 0xd6, 0x94, 0x22,
	0xb8, 0x02, 0xa6, 0xb5, 0x1b, 0x30, 0x41, 0xad, 0x18, 0x07, 0xca, 0x0f, 0x65, 0x57, 0x9b, 0x6e,
	0x5b, 0xef, 0xc1, 0x1d, 0x50, 0x11, 0xa7, 0xa8, 0x9d, 0xf7, 0x74, 0x59, 0x59, 0xa6, 0x3e, 0xc8,
	0x32, 0x07, 0x47, 0x1b, 0xfb, 0x97, 0x5a, 0x1a, 0xc8, 0x97, 0xf5, 0x4e, 0xfd, 0x9d, 0x05, 0x2a,
	0x85, 0xa6, 0x87, 0x36, 0x98, 0xc8, 0x23, 0x5b, 0x2a, 0x72, 0xbe, 0x54, 0xa6, 0x40, 0x1d, 0xed,
	0xfb, 0xdc, 0x1a, 0xfc, 0x03, 0x4c, 0x81, 0x3a, 0xaa, 0x01, 0x8c, 0x33, 0x38, 0x6c, 0x81, 0x39,
	0x81, 0x58, 0x88, 0x85, 0xd7, 0x8d, 0x70, 0x1c, 0x78, 0x0c, 0x09, 0x6c, 0x0c, 0xf1, 0xc0, 0xe0,
	0x3f, 0xe9, 0xc7, 0xef, 0xe2, 0x10, 0xf9, 0xdd, 0x2d, 0xec, 0x17, 0x82, 0x6c, 0x61, 0x5f, 0x07,
	0xa9, 0x6a, 0xe0, 0x53, 0xc9, 0x73, 0x91, 0xc0, 0xf5, 0x14, 0xcc, 0xf5, 0x4d, 0x24, 0x99, 0x32,
	0xd2, 0x9d, 0xa0, 0x52, 0x9e, 0x72, 0xf3, 0x25, 0x7c, 0x04, 0xca, 0xf9, 0xa4, 0x33, 0x83, 0xf3,
	0xee, 0x4d, 0x06, 0x9d, 0x29, 0xf3, 0xc5, 0xbb, 0xf5, 0x5d, 0x50, 0xce, 0x67, 0x16, 0xfc, 0x06,
	0x94, 0xa5, 0x23, 0x23, 0x72, 0x4c, 0xcd, 0x40, 0x5f, 0xba, 0x66, 0xce, 0xed, 0x90, 0x63, 0x6a,
	0x70, 0x13, 0x04, 0x65, 0x72, 0x59, 0xff, 0xd5, 0x02, 0x77, 0xde, 0x3f, 0xb4, 0xae, 0x49, 0xe5,
	0x19, 0x80, 0xfd, 0xee, 0x34, 0x49, 0xad, 0xdd, 0x78, 0x34, 0x9a, 0xa3, 0xcc, 0xf5, 0x35, 0x42,
	0xfd, 0xb7, 0x5b, 0xa0, 0x7a, 0x65, 0xd8, 0xc1, 0x23, 0x30, 0x73, 0xc5, 0x2d, 0xd6, 0x90, 0x6e,
	0x99, 0x16, 0x97, 0xac, 0xf2, 0x13, 0xb8, 0xad, 0xc1, 0xc8, 0xf7, 0x59, 0x8a, 0x03, 0xed, 0x98,
	0xa1, 0xbd, 0x38, 0xa7, 0x60, 0x1b, 0x9a, 0xa5, 0xcc, 0x02, 0xbf, 0x03, 0x93, 0x3a, 0x02, 0x41,
	0xd9, 0xd0, 0x53, 0xa9, 0xac, 0x10, 0x7b, 0x28, 0xab, 0xbf, 0x1b, 0x35, 0xd5, 0xe9, 0x4d, 0x6e,
	0xb8, 0x06, 0x66, 0x2f, 0x55, 0x87, 0x32, 0x5d, 0x9f, 0x92, 0x5b, 0x2d, 0x66, 0x4b, 0x19, 0x87,
	0x4f, 0x41, 0xf5, 0x92, 0x14, 0x0f, 0x9f, 0xeb, 0x4c, 0x91, 0x8d, 0x83, 0x1e, 0x3a, 0xbf, 0x52,
	0x32, 0x74, 0xba, 0x1a, 0x9d, 0x7b, 0x86, 0xc0, 0x16, 0x98, 0xd7, 0xe8, 0x63, 0x8c, 0xb9, 0xe7,
	0xd3, 0x38, 0xc6, 0xbe, 0x3c, 0x7a, 0x69, 0x48, 0x3e, 0x54, 0xb4, 0x47, 0x18, 0xf3, 0xcd, 0x9c,
	0x05, 0x4f, 0xc0, 0x47, 0x3a, 0x86, 0x9e, 0x19, 0x41, 0xc4, 0x05, 0x8b, 0x5a, 0xa9, 0x0c, 0x33,
	0x36, 0x64, 0x98, 0x05, 0x05, 0x54, 0x36, 0xd8, 0xea, 0xe1, 0xe4, 0x75, 0x21, 0x5f, 0x44, 0x19,
	0x2e, 0x7c, 0xfc, 0x8c, 0xeb, 0xeb, 0xd2, 0xfb, 0x17, 0x5f, 0x33, 0xcd, 0xaf, 0x5f, 0x9d, 0xd5,
	0xac, 0xd7, 0x67, 0x35, 0xeb, 0xdf, 0xb3, 0x9a, 0xf5, 0xcb, 0x79, 0x6d, 0xe4, 0xf5, 0x79, 0x6d,
	0xe4, 0xef, 0xf3, 0xda, 0xc8, 0x8f, 0x2b, 0xa6, 0xc5, 0x74, 0xbf, 0x75, 0xba, 0x3f, 0x3b, 0xd9,
	0x7d, 0x47, 0x74, 0xdb, 0x98, 0xf7, 0x3e, 0x07, 0x5b, 0xe3, 0xea, 0x43, 0xf0, 0xfe, 0xff, 0x01,
	0x00, 0x00, 0xff, 0xff, 0xf6, 0x01, 0xf2, 0xd2, 0xf4, 0x0a, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.VaultStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.VaultTotals.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.WithdrawalQueue) > 0 {
		for iNdEx := len(m.WithdrawalQueue) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WithdrawalQueue[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NavEntries) > 0 {
		for iNdEx := len(m.NavEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NavEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UserPositions) > 0 {
		for iNdEx := len(m.UserPositions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserPositions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.VaultConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TwapConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.VaultEnabled {
		i--
		if m.VaultEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.MaxWithdrawalRequestsPerBlock != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.MaxWithdrawalRequestsPerBlock))
		i--
		dAtA[i] = 0x30
	}
	if m.WithdrawalRequestTimeout != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.WithdrawalRequestTimeout))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxNavChangeBps != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.MaxNavChangeBps))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.MinWithdrawalAmount.Size()
		i -= size
		if _, err := m.MinWithdrawalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MinDepositAmount.Size()
		i -= size
		if _, err := m.MinDepositAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TargetYieldRate.Size()
		i -= size
		if _, err := m.TargetYieldRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MaxTotalDeposits.Size()
		i -= size
		if _, err := m.MaxTotalDeposits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserPositionEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPositionEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPositionEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NAVEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NAVEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NAVEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NavInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WithdrawalRequestEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawalRequestEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawalRequestEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.WithdrawalRequest.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultTotalEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultTotalEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultTotalEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalNav.Size()
		i -= size
		if _, err := m.TotalNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalAccruedYield.Size()
		i -= size
		if _, err := m.TotalAccruedYield.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalDeposits.Size()
		i -= size
		if _, err := m.TotalDeposits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VaultStatsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultStatsEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultStatsEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActivePositions != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.ActivePositions))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.TotalYieldDistributed.Size()
		i -= size
		if _, err := m.TotalYieldDistributed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.TotalFeesCollected.Size()
		i -= size
		if _, err := m.TotalFeesCollected.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalWithdrawn.Size()
		i -= size
		if _, err := m.TotalWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalDeposited.Size()
		i -= size
		if _, err := m.TotalDeposited.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TotalDepositors != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.TotalDepositors))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenesis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.VaultConfig.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if len(m.UserPositions) > 0 {
		for _, e := range m.UserPositions {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.NavEntries) > 0 {
		for _, e := range m.NavEntries {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.WithdrawalQueue) > 0 {
		for _, e := range m.WithdrawalQueue {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	l = m.VaultTotals.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.VaultStats.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.MinDepositAmount.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.MinWithdrawalAmount.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if m.MaxNavChangeBps != 0 {
		n += 1 + sovGenesis(uint64(m.MaxNavChangeBps))
	}
	if m.WithdrawalRequestTimeout != 0 {
		n += 1 + sovGenesis(uint64(m.WithdrawalRequestTimeout))
	}
	if m.MaxWithdrawalRequestsPerBlock != 0 {
		n += 1 + sovGenesis(uint64(m.MaxWithdrawalRequestsPerBlock))
	}
	if m.VaultEnabled {
		n += 2
	}
	l = m.TwapConfig.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *VaultConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = m.MaxTotalDeposits.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TargetYieldRate.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *UserPositionEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.Position.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *NAVEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NavInfo.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *WithdrawalRequestEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.WithdrawalRequest.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *VaultTotalEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalDeposits.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalAccruedYield.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalNav.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *VaultStatsEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalDepositors != 0 {
		n += 1 + sovGenesis(uint64(m.TotalDepositors))
	}
	l = m.TotalDeposited.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalWithdrawn.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalFeesCollected.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.TotalYieldDistributed.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if m.ActivePositions != 0 {
		n += 1 + sovGenesis(uint64(m.ActivePositions))
	}
	return n
}

func sovGenesis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenesis(x uint64) (n int) {
	return sovGenesis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VaultConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserPositions = append(m.UserPositions, UserPositionEntry{})
			if err := m.UserPositions[len(m.UserPositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NavEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NavEntries = append(m.NavEntries, NAVEntry{})
			if err := m.NavEntries[len(m.NavEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawalQueue = append(m.WithdrawalQueue, WithdrawalRequestEntry{})
			if err := m.WithdrawalQueue[len(m.WithdrawalQueue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultTotals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VaultTotals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VaultStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDepositAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinDepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinWithdrawalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinWithdrawalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNavChangeBps", wireType)
			}
			m.MaxNavChangeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNavChangeBps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalRequestTimeout", wireType)
			}
			m.WithdrawalRequestTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithdrawalRequestTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWithdrawalRequestsPerBlock", wireType)
			}
			m.MaxWithdrawalRequestsPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWithdrawalRequestsPerBlock |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VaultEnabled = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TwapConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TwapConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTotalDeposits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxTotalDeposits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetYieldRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetYieldRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPositionEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPositionEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPositionEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NAVEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NAVEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NAVEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NavInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NavInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawalRequestEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawalRequestEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawalRequestEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WithdrawalRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultTotalEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultTotalEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultTotalEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalDeposits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAccruedYield", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAccruedYield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultStatsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultStatsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultStatsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDepositors", wireType)
			}
			m.TotalDepositors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDepositors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalDeposited.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFeesCollected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFeesCollected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalYieldDistributed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalYieldDistributed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePositions", wireType)
			}
			m.ActivePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivePositions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenesis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenesis
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenesis
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenesis
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
