// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/vaults.proto

package v2

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// WithdrawalRequestStatus represents the status of a withdrawal request
type WithdrawalRequestStatus int32

const (
	// Request is pending (waiting for unlock time)
	WITHDRAWAL_REQUEST_STATUS_PENDING WithdrawalRequestStatus = 0
	// Request is ready to be processed
	WITHDRAWAL_REQUEST_STATUS_READY WithdrawalRequestStatus = 1
	// Request has been processed
	WITHDRAWAL_REQUEST_STATUS_PROCESSED WithdrawalRequestStatus = 2
	// Request was cancelled by user
	WITHDRAWAL_REQUEST_STATUS_CANCELLED WithdrawalRequestStatus = 3
	// Request expired without processing
	WITHDRAWAL_REQUEST_STATUS_EXPIRED WithdrawalRequestStatus = 4
)

var WithdrawalRequestStatus_name = map[int32]string{
	0: "WITHDRAWAL_REQUEST_STATUS_PENDING",
	1: "WITHDRAWAL_REQUEST_STATUS_READY",
	2: "WITHDRAWAL_REQUEST_STATUS_PROCESSED",
	3: "WITHDRAWAL_REQUEST_STATUS_CANCELLED",
	4: "WITHDRAWAL_REQUEST_STATUS_EXPIRED",
}

var WithdrawalRequestStatus_value = map[string]int32{
	"WITHDRAWAL_REQUEST_STATUS_PENDING":   0,
	"WITHDRAWAL_REQUEST_STATUS_READY":     1,
	"WITHDRAWAL_REQUEST_STATUS_PROCESSED": 2,
	"WITHDRAWAL_REQUEST_STATUS_CANCELLED": 3,
	"WITHDRAWAL_REQUEST_STATUS_EXPIRED":   4,
}

func (x WithdrawalRequestStatus) String() string {
	return proto.EnumName(WithdrawalRequestStatus_name, int32(x))
}

func (WithdrawalRequestStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{0}
}

// UserPosition represents a user's position in the V2 yield-tracking vault system
// Users can have multiple independent positions, each identified by position_id
type UserPosition struct {
	// Unique position ID for this user (auto-incremented per user)
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Current deposit amount (principal)
	DepositAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=deposit_amount,json=depositAmount,proto3,customtype=cosmossdk.io/math.Int" json:"deposit_amount"`
	// Accrued yield on the position
	AccruedYield cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=accrued_yield,json=accruedYield,proto3,customtype=cosmossdk.io/math.Int" json:"accrued_yield"`
	// Timestamp of first deposit
	FirstDepositTime time.Time `protobuf:"bytes,4,opt,name=first_deposit_time,json=firstDepositTime,proto3,stdtime" json:"first_deposit_time"`
	// Timestamp of last deposit/withdrawal
	LastActivityTime time.Time `protobuf:"bytes,5,opt,name=last_activity_time,json=lastActivityTime,proto3,stdtime" json:"last_activity_time"`
	// Whether user wants to receive yield (vs contributing to fee pool)
	ReceiveYield bool `protobuf:"varint,6,opt,name=receive_yield,json=receiveYield,proto3" json:"receive_yield,omitempty"`
	// Amount pending withdrawal
	AmountPendingWithdrawal cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=amount_pending_withdrawal,json=amountPendingWithdrawal,proto3,customtype=cosmossdk.io/math.Int" json:"amount_pending_withdrawal"`
	// Number of active withdrawal requests
	ActiveWithdrawalRequests int32 `protobuf:"varint,8,opt,name=active_withdrawal_requests,json=activeWithdrawalRequests,proto3" json:"active_withdrawal_requests,omitempty"`
}

func (m *UserPosition) Reset()         { *m = UserPosition{} }
func (m *UserPosition) String() string { return proto.CompactTextString(m) }
func (*UserPosition) ProtoMessage()    {}
func (*UserPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{0}
}
func (m *UserPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPosition.Merge(m, src)
}
func (m *UserPosition) XXX_Size() int {
	return m.Size()
}
func (m *UserPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPosition.DiscardUnknown(m)
}

var xxx_messageInfo_UserPosition proto.InternalMessageInfo

func (m *UserPosition) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *UserPosition) GetFirstDepositTime() time.Time {
	if m != nil {
		return m.FirstDepositTime
	}
	return time.Time{}
}

func (m *UserPosition) GetLastActivityTime() time.Time {
	if m != nil {
		return m.LastActivityTime
	}
	return time.Time{}
}

func (m *UserPosition) GetReceiveYield() bool {
	if m != nil {
		return m.ReceiveYield
	}
	return false
}

func (m *UserPosition) GetActiveWithdrawalRequests() int32 {
	if m != nil {
		return m.ActiveWithdrawalRequests
	}
	return 0
}

// AccountingSnapshot represents a pending update to a user position during accounting.
// These snapshots are used to stage all accounting changes before atomically committing
// them when the accounting session completes. This ensures consistency even if accounting
// is performed across multiple message invocations.
type AccountingSnapshot struct {
	// User address
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// Position ID for this user
	PositionId uint64 `protobuf:"varint,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// New deposit amount after accounting
	DepositAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=deposit_amount,json=depositAmount,proto3,customtype=cosmossdk.io/math.Int" json:"deposit_amount"`
	// New accrued yield after accounting
	AccruedYield cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=accrued_yield,json=accruedYield,proto3,customtype=cosmossdk.io/math.Int" json:"accrued_yield"`
	// NAV value used for this snapshot
	AccountingNav cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=accounting_nav,json=accountingNav,proto3,customtype=cosmossdk.io/math.Int" json:"accounting_nav"`
	// Timestamp when this snapshot was created
	CreatedAt time.Time `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
}

func (m *AccountingSnapshot) Reset()         { *m = AccountingSnapshot{} }
func (m *AccountingSnapshot) String() string { return proto.CompactTextString(m) }
func (*AccountingSnapshot) ProtoMessage()    {}
func (*AccountingSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{1}
}
func (m *AccountingSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountingSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountingSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountingSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountingSnapshot.Merge(m, src)
}
func (m *AccountingSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *AccountingSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountingSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_AccountingSnapshot proto.InternalMessageInfo

func (m *AccountingSnapshot) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *AccountingSnapshot) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *AccountingSnapshot) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

// WithdrawalRequest represents a pending withdrawal request
type WithdrawalRequest struct {
	// Unique request ID
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Address of the account that created the request
	Requester string `protobuf:"bytes,2,opt,name=requester,proto3" json:"requester,omitempty"`
	// Position ID being withdrawn from
	PositionId uint64 `protobuf:"varint,3,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Amount to withdraw (including yield)
	WithdrawAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=withdraw_amount,json=withdrawAmount,proto3,customtype=cosmossdk.io/math.Int" json:"withdraw_amount"`
	// When the withdrawal was requested
	RequestTime time.Time `protobuf:"bytes,5,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time"`
	// When the withdrawal can be processed
	UnlockTime time.Time `protobuf:"bytes,6,opt,name=unlock_time,json=unlockTime,proto3,stdtime" json:"unlock_time"`
	// Current status of the withdrawal request
	Status WithdrawalRequestStatus `protobuf:"varint,7,opt,name=status,proto3,enum=noble.dollar.vaults.v2.WithdrawalRequestStatus" json:"status,omitempty"`
	// Estimated amount to receive (calculated at request time)
	EstimatedAmount cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=estimated_amount,json=estimatedAmount,proto3,customtype=cosmossdk.io/math.Int" json:"estimated_amount"`
	// Block height when request was made
	RequestBlockHeight int64 `protobuf:"varint,9,opt,name=request_block_height,json=requestBlockHeight,proto3" json:"request_block_height,omitempty"`
}

func (m *WithdrawalRequest) Reset()         { *m = WithdrawalRequest{} }
func (m *WithdrawalRequest) String() string { return proto.CompactTextString(m) }
func (*WithdrawalRequest) ProtoMessage()    {}
func (*WithdrawalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{2}
}
func (m *WithdrawalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawalRequest.Merge(m, src)
}
func (m *WithdrawalRequest) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawalRequest proto.InternalMessageInfo

func (m *WithdrawalRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *WithdrawalRequest) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

func (m *WithdrawalRequest) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *WithdrawalRequest) GetRequestTime() time.Time {
	if m != nil {
		return m.RequestTime
	}
	return time.Time{}
}

func (m *WithdrawalRequest) GetUnlockTime() time.Time {
	if m != nil {
		return m.UnlockTime
	}
	return time.Time{}
}

func (m *WithdrawalRequest) GetStatus() WithdrawalRequestStatus {
	if m != nil {
		return m.Status
	}
	return WITHDRAWAL_REQUEST_STATUS_PENDING
}

func (m *WithdrawalRequest) GetRequestBlockHeight() int64 {
	if m != nil {
		return m.RequestBlockHeight
	}
	return 0
}

// VaultState represents the current state of a V2 vault
type VaultState struct {
	// Total deposits in the vault
	TotalDeposits cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_deposits,json=totalDeposits,proto3,customtype=cosmossdk.io/math.Int" json:"total_deposits"`
	// Total accrued yield
	TotalAccruedYield cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_accrued_yield,json=totalAccruedYield,proto3,customtype=cosmossdk.io/math.Int" json:"total_accrued_yield"`
	// Total Net Asset Value (deposits + yield)
	TotalNav cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_nav,json=totalNav,proto3,customtype=cosmossdk.io/math.Int" json:"total_nav"`
	// Total number of users with positions
	TotalUsers uint64 `protobuf:"varint,4,opt,name=total_users,json=totalUsers,proto3" json:"total_users,omitempty"`
	// Whether deposits are currently enabled
	DepositsEnabled bool `protobuf:"varint,5,opt,name=deposits_enabled,json=depositsEnabled,proto3" json:"deposits_enabled,omitempty"`
	// Whether withdrawals are currently enabled
	WithdrawalsEnabled bool `protobuf:"varint,6,opt,name=withdrawals_enabled,json=withdrawalsEnabled,proto3" json:"withdrawals_enabled,omitempty"`
	// Last NAV update timestamp
	LastNavUpdate time.Time `protobuf:"bytes,7,opt,name=last_nav_update,json=lastNavUpdate,proto3,stdtime" json:"last_nav_update"`
	// Total amount pending withdrawal
	TotalAmountPendingWithdrawal cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=total_amount_pending_withdrawal,json=totalAmountPendingWithdrawal,proto3,customtype=cosmossdk.io/math.Int" json:"total_amount_pending_withdrawal"`
	// Number of pending withdrawal requests
	PendingWithdrawalRequests int32 `protobuf:"varint,9,opt,name=pending_withdrawal_requests,json=pendingWithdrawalRequests,proto3" json:"pending_withdrawal_requests,omitempty"`
	// Total number of active positions across all users
	TotalPositions uint64 `protobuf:"varint,10,opt,name=total_positions,json=totalPositions,proto3" json:"total_positions,omitempty"`
}

func (m *VaultState) Reset()         { *m = VaultState{} }
func (m *VaultState) String() string { return proto.CompactTextString(m) }
func (*VaultState) ProtoMessage()    {}
func (*VaultState) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{3}
}
func (m *VaultState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VaultState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VaultState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultState.Merge(m, src)
}
func (m *VaultState) XXX_Size() int {
	return m.Size()
}
func (m *VaultState) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultState.DiscardUnknown(m)
}

var xxx_messageInfo_VaultState proto.InternalMessageInfo

func (m *VaultState) GetTotalUsers() uint64 {
	if m != nil {
		return m.TotalUsers
	}
	return 0
}

func (m *VaultState) GetDepositsEnabled() bool {
	if m != nil {
		return m.DepositsEnabled
	}
	return false
}

func (m *VaultState) GetWithdrawalsEnabled() bool {
	if m != nil {
		return m.WithdrawalsEnabled
	}
	return false
}

func (m *VaultState) GetLastNavUpdate() time.Time {
	if m != nil {
		return m.LastNavUpdate
	}
	return time.Time{}
}

func (m *VaultState) GetPendingWithdrawalRequests() int32 {
	if m != nil {
		return m.PendingWithdrawalRequests
	}
	return 0
}

func (m *VaultState) GetTotalPositions() uint64 {
	if m != nil {
		return m.TotalPositions
	}
	return 0
}

// YieldCalculation contains details about yield calculations
type YieldCalculation struct {
	// Total deposits used in calculation
	TotalDeposits cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_deposits,json=totalDeposits,proto3,customtype=cosmossdk.io/math.Int" json:"total_deposits"`
	// Total accrued yield
	TotalYield cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_yield,json=totalYield,proto3,customtype=cosmossdk.io/math.Int" json:"total_yield"`
	// Yield rate (APY percentage)
	YieldRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=yield_rate,json=yieldRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"yield_rate"`
	// Calculation timestamp
	CalculationTime time.Time `protobuf:"bytes,4,opt,name=calculation_time,json=calculationTime,proto3,stdtime" json:"calculation_time"`
}

func (m *YieldCalculation) Reset()         { *m = YieldCalculation{} }
func (m *YieldCalculation) String() string { return proto.CompactTextString(m) }
func (*YieldCalculation) ProtoMessage()    {}
func (*YieldCalculation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{4}
}
func (m *YieldCalculation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *YieldCalculation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_YieldCalculation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *YieldCalculation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YieldCalculation.Merge(m, src)
}
func (m *YieldCalculation) XXX_Size() int {
	return m.Size()
}
func (m *YieldCalculation) XXX_DiscardUnknown() {
	xxx_messageInfo_YieldCalculation.DiscardUnknown(m)
}

var xxx_messageInfo_YieldCalculation proto.InternalMessageInfo

func (m *YieldCalculation) GetCalculationTime() time.Time {
	if m != nil {
		return m.CalculationTime
	}
	return time.Time{}
}

// DepositResult contains the outcome of a deposit operation
type DepositResult struct {
	// Amount deposited
	AmountDeposited cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_deposited,json=amountDeposited,proto3,customtype=cosmossdk.io/math.Int" json:"amount_deposited"`
}

func (m *DepositResult) Reset()         { *m = DepositResult{} }
func (m *DepositResult) String() string { return proto.CompactTextString(m) }
func (*DepositResult) ProtoMessage()    {}
func (*DepositResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{5}
}
func (m *DepositResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositResult.Merge(m, src)
}
func (m *DepositResult) XXX_Size() int {
	return m.Size()
}
func (m *DepositResult) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositResult.DiscardUnknown(m)
}

var xxx_messageInfo_DepositResult proto.InternalMessageInfo

// WithdrawalResult contains the outcome of a withdrawal operation
type WithdrawalResult struct {
	// Principal withdrawn
	PrincipalWithdrawn cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=principal_withdrawn,json=principalWithdrawn,proto3,customtype=cosmossdk.io/math.Int" json:"principal_withdrawn"`
	// Yield withdrawn
	YieldWithdrawn cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=yield_withdrawn,json=yieldWithdrawn,proto3,customtype=cosmossdk.io/math.Int" json:"yield_withdrawn"`
	// Fees paid
	FeesPaid cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=fees_paid,json=feesPaid,proto3,customtype=cosmossdk.io/math.Int" json:"fees_paid"`
	// Total amount received (principal + yield - fees)
	TotalAmountReceived cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=total_amount_received,json=totalAmountReceived,proto3,customtype=cosmossdk.io/math.Int" json:"total_amount_received"`
}

func (m *WithdrawalResult) Reset()         { *m = WithdrawalResult{} }
func (m *WithdrawalResult) String() string { return proto.CompactTextString(m) }
func (*WithdrawalResult) ProtoMessage()    {}
func (*WithdrawalResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{6}
}
func (m *WithdrawalResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawalResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawalResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawalResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawalResult.Merge(m, src)
}
func (m *WithdrawalResult) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawalResult) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawalResult.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawalResult proto.InternalMessageInfo

// YieldDistribution represents yield distribution to shareholders
type YieldDistribution struct {
	// Total yield amount distributed
	TotalYield cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_yield,json=totalYield,proto3,customtype=cosmossdk.io/math.Int" json:"total_yield"`
	// Yield rate applied
	YieldRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=yield_rate,json=yieldRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"yield_rate"`
	// Distribution timestamp
	DistributionTime time.Time `protobuf:"bytes,3,opt,name=distribution_time,json=distributionTime,proto3,stdtime" json:"distribution_time"`
	// Number of eligible depositors
	EligibleDepositors uint64 `protobuf:"varint,4,opt,name=eligible_depositors,json=eligibleDepositors,proto3" json:"eligible_depositors,omitempty"`
}

func (m *YieldDistribution) Reset()         { *m = YieldDistribution{} }
func (m *YieldDistribution) String() string { return proto.CompactTextString(m) }
func (*YieldDistribution) ProtoMessage()    {}
func (*YieldDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{7}
}
func (m *YieldDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *YieldDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_YieldDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *YieldDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YieldDistribution.Merge(m, src)
}
func (m *YieldDistribution) XXX_Size() int {
	return m.Size()
}
func (m *YieldDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_YieldDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_YieldDistribution proto.InternalMessageInfo

func (m *YieldDistribution) GetDistributionTime() time.Time {
	if m != nil {
		return m.DistributionTime
	}
	return time.Time{}
}

func (m *YieldDistribution) GetEligibleDepositors() uint64 {
	if m != nil {
		return m.EligibleDepositors
	}
	return 0
}

// DepositLimit defines deposit limits and risk controls
type DepositLimit struct {
	// Maximum deposit amount per user per time window
	MaxUserDepositPerWindow cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=max_user_deposit_per_window,json=maxUserDepositPerWindow,proto3,customtype=cosmossdk.io/math.Int" json:"max_user_deposit_per_window"`
	// Maximum deposit volume per block
	MaxBlockDepositVolume cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=max_block_deposit_volume,json=maxBlockDepositVolume,proto3,customtype=cosmossdk.io/math.Int" json:"max_block_deposit_volume"`
	// Global maximum total deposits (vault capacity)
	GlobalDepositCap cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=global_deposit_cap,json=globalDepositCap,proto3,customtype=cosmossdk.io/math.Int" json:"global_deposit_cap"`
	// Cooldown period in blocks between deposits
	DepositCooldownBlocks int64 `protobuf:"varint,4,opt,name=deposit_cooldown_blocks,json=depositCooldownBlocks,proto3" json:"deposit_cooldown_blocks,omitempty"`
	// Time window for velocity tracking (in blocks)
	VelocityWindowBlocks int64 `protobuf:"varint,5,opt,name=velocity_window_blocks,json=velocityWindowBlocks,proto3" json:"velocity_window_blocks,omitempty"`
	// Maximum number of deposits per user in time window
	MaxDepositsPerWindow uint32 `protobuf:"varint,6,opt,name=max_deposits_per_window,json=maxDepositsPerWindow,proto3" json:"max_deposits_per_window,omitempty"`
}

func (m *DepositLimit) Reset()         { *m = DepositLimit{} }
func (m *DepositLimit) String() string { return proto.CompactTextString(m) }
func (*DepositLimit) ProtoMessage()    {}
func (*DepositLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{8}
}
func (m *DepositLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositLimit.Merge(m, src)
}
func (m *DepositLimit) XXX_Size() int {
	return m.Size()
}
func (m *DepositLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositLimit.DiscardUnknown(m)
}

var xxx_messageInfo_DepositLimit proto.InternalMessageInfo

func (m *DepositLimit) GetDepositCooldownBlocks() int64 {
	if m != nil {
		return m.DepositCooldownBlocks
	}
	return 0
}

func (m *DepositLimit) GetVelocityWindowBlocks() int64 {
	if m != nil {
		return m.VelocityWindowBlocks
	}
	return 0
}

func (m *DepositLimit) GetMaxDepositsPerWindow() uint32 {
	if m != nil {
		return m.MaxDepositsPerWindow
	}
	return 0
}

// DepositVelocity tracks user deposit velocity for risk monitoring
type DepositVelocity struct {
	// Block height of last deposit
	LastDepositBlock int64 `protobuf:"varint,1,opt,name=last_deposit_block,json=lastDepositBlock,proto3" json:"last_deposit_block,omitempty"`
	// Number of deposits in recent time window
	RecentDepositCount uint32 `protobuf:"varint,2,opt,name=recent_deposit_count,json=recentDepositCount,proto3" json:"recent_deposit_count,omitempty"`
	// Total volume deposited in recent time window
	RecentDepositVolume cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=recent_deposit_volume,json=recentDepositVolume,proto3,customtype=cosmossdk.io/math.Int" json:"recent_deposit_volume"`
	// Time window size in blocks
	TimeWindowBlocks int64 `protobuf:"varint,4,opt,name=time_window_blocks,json=timeWindowBlocks,proto3" json:"time_window_blocks,omitempty"`
}

func (m *DepositVelocity) Reset()         { *m = DepositVelocity{} }
func (m *DepositVelocity) String() string { return proto.CompactTextString(m) }
func (*DepositVelocity) ProtoMessage()    {}
func (*DepositVelocity) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{9}
}
func (m *DepositVelocity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositVelocity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositVelocity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositVelocity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositVelocity.Merge(m, src)
}
func (m *DepositVelocity) XXX_Size() int {
	return m.Size()
}
func (m *DepositVelocity) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositVelocity.DiscardUnknown(m)
}

var xxx_messageInfo_DepositVelocity proto.InternalMessageInfo

func (m *DepositVelocity) GetLastDepositBlock() int64 {
	if m != nil {
		return m.LastDepositBlock
	}
	return 0
}

func (m *DepositVelocity) GetRecentDepositCount() uint32 {
	if m != nil {
		return m.RecentDepositCount
	}
	return 0
}

func (m *DepositVelocity) GetTimeWindowBlocks() int64 {
	if m != nil {
		return m.TimeWindowBlocks
	}
	return 0
}

// TWAPConfig configures Time-Weighted Average Price for share pricing
type TWAPConfig struct {
	// Whether TWAP is enabled for share pricing
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Number of historical NAV snapshots to include in TWAP calculation
	WindowSize uint32 `protobuf:"varint,2,opt,name=window_size,json=windowSize,proto3" json:"window_size,omitempty"`
	// Minimum time between NAV snapshots (in seconds)
	MinSnapshotInterval int64 `protobuf:"varint,3,opt,name=min_snapshot_interval,json=minSnapshotInterval,proto3" json:"min_snapshot_interval,omitempty"`
	// Maximum age of snapshots to include (in seconds)
	MaxSnapshotAge int64 `protobuf:"varint,4,opt,name=max_snapshot_age,json=maxSnapshotAge,proto3" json:"max_snapshot_age,omitempty"`
}

func (m *TWAPConfig) Reset()         { *m = TWAPConfig{} }
func (m *TWAPConfig) String() string { return proto.CompactTextString(m) }
func (*TWAPConfig) ProtoMessage()    {}
func (*TWAPConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{10}
}
func (m *TWAPConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TWAPConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TWAPConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TWAPConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TWAPConfig.Merge(m, src)
}
func (m *TWAPConfig) XXX_Size() int {
	return m.Size()
}
func (m *TWAPConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TWAPConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TWAPConfig proto.InternalMessageInfo

func (m *TWAPConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *TWAPConfig) GetWindowSize() uint32 {
	if m != nil {
		return m.WindowSize
	}
	return 0
}

func (m *TWAPConfig) GetMinSnapshotInterval() int64 {
	if m != nil {
		return m.MinSnapshotInterval
	}
	return 0
}

func (m *TWAPConfig) GetMaxSnapshotAge() int64 {
	if m != nil {
		return m.MaxSnapshotAge
	}
	return 0
}

// NAVSnapshot represents a point-in-time NAV observation for TWAP
type NAVSnapshot struct {
	// NAV value at this snapshot
	Nav cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=nav,proto3,customtype=cosmossdk.io/math.Int" json:"nav"`
	// Timestamp of this snapshot
	Timestamp time.Time `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Block height at this snapshot
	BlockHeight int64 `protobuf:"varint,3,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Total shares at this snapshot (for reference)
	TotalShares cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=total_shares,json=totalShares,proto3,customtype=cosmossdk.io/math.Int" json:"total_shares"`
}

func (m *NAVSnapshot) Reset()         { *m = NAVSnapshot{} }
func (m *NAVSnapshot) String() string { return proto.CompactTextString(m) }
func (*NAVSnapshot) ProtoMessage()    {}
func (*NAVSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{11}
}
func (m *NAVSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NAVSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NAVSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NAVSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NAVSnapshot.Merge(m, src)
}
func (m *NAVSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *NAVSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_NAVSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_NAVSnapshot proto.InternalMessageInfo

func (m *NAVSnapshot) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *NAVSnapshot) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// AccountingCursor tracks progress of yield accounting operations
type AccountingCursor struct {
	// Last user address that was processed
	LastProcessedUser string `protobuf:"bytes,1,opt,name=last_processed_user,json=lastProcessedUser,proto3" json:"last_processed_user,omitempty"`
	// NAV value being applied in this accounting session
	AccountingNav cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=accounting_nav,json=accountingNav,proto3,customtype=cosmossdk.io/math.Int" json:"accounting_nav"`
	// Timestamp of NAV being applied
	AccountingNavTimestamp time.Time `protobuf:"bytes,3,opt,name=accounting_nav_timestamp,json=accountingNavTimestamp,proto3,stdtime" json:"accounting_nav_timestamp"`
	// Number of positions processed in this accounting session
	PositionsProcessed uint64 `protobuf:"varint,4,opt,name=positions_processed,json=positionsProcessed,proto3" json:"positions_processed,omitempty"`
	// Total positions to process in this session
	TotalPositions uint64 `protobuf:"varint,5,opt,name=total_positions,json=totalPositions,proto3" json:"total_positions,omitempty"`
	// Whether accounting is currently in progress
	InProgress bool `protobuf:"varint,6,opt,name=in_progress,json=inProgress,proto3" json:"in_progress,omitempty"`
	// Timestamp when accounting started
	StartedAt time.Time `protobuf:"bytes,7,opt,name=started_at,json=startedAt,proto3,stdtime" json:"started_at"`
	// Accumulated residual from division precision handling
	AccumulatedResidual cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=accumulated_residual,json=accumulatedResidual,proto3,customtype=cosmossdk.io/math.Int" json:"accumulated_residual"`
}

func (m *AccountingCursor) Reset()         { *m = AccountingCursor{} }
func (m *AccountingCursor) String() string { return proto.CompactTextString(m) }
func (*AccountingCursor) ProtoMessage()    {}
func (*AccountingCursor) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9e05010b6747034, []int{12}
}
func (m *AccountingCursor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountingCursor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountingCursor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountingCursor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountingCursor.Merge(m, src)
}
func (m *AccountingCursor) XXX_Size() int {
	return m.Size()
}
func (m *AccountingCursor) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountingCursor.DiscardUnknown(m)
}

var xxx_messageInfo_AccountingCursor proto.InternalMessageInfo

func (m *AccountingCursor) GetLastProcessedUser() string {
	if m != nil {
		return m.LastProcessedUser
	}
	return ""
}

func (m *AccountingCursor) GetAccountingNavTimestamp() time.Time {
	if m != nil {
		return m.AccountingNavTimestamp
	}
	return time.Time{}
}

func (m *AccountingCursor) GetPositionsProcessed() uint64 {
	if m != nil {
		return m.PositionsProcessed
	}
	return 0
}

func (m *AccountingCursor) GetTotalPositions() uint64 {
	if m != nil {
		return m.TotalPositions
	}
	return 0
}

func (m *AccountingCursor) GetInProgress() bool {
	if m != nil {
		return m.InProgress
	}
	return false
}

func (m *AccountingCursor) GetStartedAt() time.Time {
	if m != nil {
		return m.StartedAt
	}
	return time.Time{}
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v2.WithdrawalRequestStatus", WithdrawalRequestStatus_name, WithdrawalRequestStatus_value)
	proto.RegisterType((*UserPosition)(nil), "noble.dollar.vaults.v2.UserPosition")
	proto.RegisterType((*AccountingSnapshot)(nil), "noble.dollar.vaults.v2.AccountingSnapshot")
	proto.RegisterType((*WithdrawalRequest)(nil), "noble.dollar.vaults.v2.WithdrawalRequest")
	proto.RegisterType((*VaultState)(nil), "noble.dollar.vaults.v2.VaultState")
	proto.RegisterType((*YieldCalculation)(nil), "noble.dollar.vaults.v2.YieldCalculation")
	proto.RegisterType((*DepositResult)(nil), "noble.dollar.vaults.v2.DepositResult")
	proto.RegisterType((*WithdrawalResult)(nil), "noble.dollar.vaults.v2.WithdrawalResult")
	proto.RegisterType((*YieldDistribution)(nil), "noble.dollar.vaults.v2.YieldDistribution")
	proto.RegisterType((*DepositLimit)(nil), "noble.dollar.vaults.v2.DepositLimit")
	proto.RegisterType((*DepositVelocity)(nil), "noble.dollar.vaults.v2.DepositVelocity")
	proto.RegisterType((*TWAPConfig)(nil), "noble.dollar.vaults.v2.TWAPConfig")
	proto.RegisterType((*NAVSnapshot)(nil), "noble.dollar.vaults.v2.NAVSnapshot")
	proto.RegisterType((*AccountingCursor)(nil), "noble.dollar.vaults.v2.AccountingCursor")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v2/vaults.proto", fileDescriptor_a9e05010b6747034)
}

var fileDescriptor_a9e05010b6747034 = []byte{
	// 1790 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x92, 0x94, 0x23, 0x3e, 0x7d, 0x51, 0x43, 0xc9, 0xa6, 0xe5, 0x56, 0x52, 0x28, 0x14,
	0x51, 0x03, 0x87, 0x0c, 0x94, 0xd6, 0xa7, 0xb6, 0x00, 0x45, 0x12, 0xb6, 0x00, 0x45, 0xa1, 0x97,
	0x92, 0x55, 0xb7, 0x40, 0xb6, 0xc3, 0xdd, 0x31, 0x35, 0xc8, 0x7e, 0xb0, 0x3b, 0xb3, 0x94, 0xe4,
	0x7b, 0x80, 0x5e, 0x0a, 0xe4, 0x7f, 0x28, 0x0a, 0xf4, 0xd8, 0x02, 0x39, 0xf5, 0x56, 0xf4, 0x92,
	0x53, 0x11, 0xe4, 0x14, 0xf4, 0x90, 0x16, 0x76, 0xd1, 0xde, 0xfa, 0x37, 0x04, 0xf3, 0xb5, 0x4b,
	0x49, 0x96, 0x21, 0x6d, 0x9c, 0x0b, 0xc1, 0x9d, 0x37, 0xef, 0x37, 0x33, 0xef, 0xfd, 0xde, 0xc7,
	0x0c, 0x6c, 0x86, 0xd1, 0xc0, 0x27, 0x4d, 0x2f, 0xf2, 0x7d, 0x1c, 0x37, 0xc7, 0x38, 0xf1, 0x39,
	0x6b, 0x8e, 0xb7, 0xf5, 0xbf, 0xc6, 0x28, 0x8e, 0x78, 0x84, 0x6e, 0xcb, 0x49, 0x0d, 0x35, 0xa9,
	0xa1, 0x45, 0xe3, 0xed, 0xd5, 0x25, 0x1c, 0xd0, 0x30, 0x6a, 0xca, 0x5f, 0x35, 0x75, 0xf5, 0xae,
	0x1b, 0xb1, 0x20, 0x62, 0x8e, 0xfc, 0x6a, 0xaa, 0x0f, 0x2d, 0x5a, 0x1e, 0x46, 0xc3, 0x48, 0x8d,
	0x8b, 0x7f, 0x7a, 0x74, 0x7d, 0x18, 0x45, 0x43, 0x9f, 0x34, 0xe5, 0xd7, 0x20, 0x79, 0xd6, 0xe4,
	0x34, 0x20, 0x8c, 0xe3, 0x60, 0xa4, 0x26, 0xd4, 0xbf, 0x2e, 0xc1, 0xdc, 0x21, 0x23, 0x71, 0x2f,
	0x62, 0x94, 0xd3, 0x28, 0x44, 0xeb, 0x30, 0x3b, 0xd2, 0xff, 0x1d, 0xea, 0xd5, 0xac, 0x0d, 0x6b,
	0xab, 0x64, 0x83, 0x19, 0xda, 0xf5, 0xd0, 0x11, 0x2c, 0x78, 0x44, 0x7e, 0x3b, 0x38, 0x88, 0x92,
	0x90, 0xd7, 0x0a, 0x1b, 0xd6, 0x56, 0x79, 0xe7, 0xfd, 0x2f, 0xbe, 0x59, 0x9f, 0xfa, 0xe7, 0x37,
	0xeb, 0x2b, 0x6a, 0x5b, 0xcc, 0xfb, 0xa4, 0x41, 0xa3, 0x66, 0x80, 0xf9, 0x71, 0x63, 0x37, 0xe4,
	0x5f, 0x7d, 0xfe, 0x1e, 0xe8, 0xfd, 0xee, 0x86, 0xfc, 0x4f, 0xff, 0xfb, 0xf3, 0xbb, 0x96, 0x3d,
	0xaf, 0x71, 0x5a, 0x12, 0x06, 0x1d, 0xc2, 0x3c, 0x76, 0xdd, 0x38, 0x21, 0x9e, 0x73, 0x46, 0x89,
	0xef, 0xd5, 0x8a, 0x39, 0x71, 0xe7, 0x34, 0xcc, 0x53, 0x81, 0x82, 0x6c, 0x40, 0xcf, 0x68, 0xcc,
	0xb8, 0x63, 0x76, 0x2d, 0x4c, 0x50, 0x2b, 0x6d, 0x58, 0x5b, 0xb3, 0xdb, 0xab, 0x0d, 0x65, 0x9f,
	0x86, 0xb1, 0x4f, 0xe3, 0xc0, 0xd8, 0x67, 0x67, 0x46, 0xac, 0xfb, 0xd9, 0xbf, 0xd6, 0x2d, 0xbb,
	0x22, 0xf5, 0x3b, 0x4a, 0x5d, 0x4c, 0x10, 0x98, 0x3e, 0x66, 0xdc, 0xc1, 0x2e, 0xa7, 0x63, 0xca,
	0xcf, 0x14, 0xe6, 0xf4, 0x4d, 0x30, 0x85, 0x7e, 0x4b, 0xab, 0x4b, 0xcc, 0x4d, 0x98, 0x8f, 0x89,
	0x4b, 0xe8, 0x98, 0xe8, 0xe3, 0xdf, 0xda, 0xb0, 0xb6, 0x66, 0xec, 0x39, 0x3d, 0xa8, 0x0e, 0xe3,
	0xc3, 0x5d, 0x65, 0x74, 0x67, 0x44, 0x42, 0x8f, 0x86, 0x43, 0xe7, 0x84, 0xf2, 0x63, 0x2f, 0xc6,
	0x27, 0xd8, 0xaf, 0xbd, 0x95, 0xd3, 0x5e, 0x77, 0x14, 0x64, 0x4f, 0x21, 0x1e, 0xa5, 0x80, 0xe8,
	0x67, 0xb0, 0x2a, 0x4f, 0x48, 0x26, 0x56, 0x71, 0x62, 0xf2, 0xdb, 0x84, 0x30, 0xce, 0x6a, 0x33,
	0x1b, 0xd6, 0xd6, 0xb4, 0x5d, 0x53, 0x33, 0x32, 0x2d, 0x5b, 0xcb, 0xeb, 0x7f, 0x29, 0x02, 0x6a,
	0xb9, 0xae, 0x80, 0xa6, 0xe1, 0xb0, 0x1f, 0xe2, 0x11, 0x3b, 0x8e, 0x38, 0xba, 0x0f, 0xa5, 0x84,
	0x91, 0x58, 0x32, 0xab, 0xbc, 0x53, 0xfb, 0xea, 0xf3, 0xf7, 0x96, 0xf5, 0x86, 0x5a, 0x9e, 0x17,
	0x13, 0xc6, 0xfa, 0x3c, 0xa6, 0xe1, 0xd0, 0x96, 0xb3, 0x2e, 0xd2, 0xb1, 0x70, 0x0d, 0x3a, 0x16,
	0xbf, 0x27, 0x3a, 0x96, 0xde, 0x08, 0x1d, 0x8f, 0x60, 0x01, 0xa7, 0x46, 0x71, 0x42, 0x3c, 0x96,
	0xb4, 0xc9, 0xb5, 0xdf, 0x0c, 0x67, 0x1f, 0x8f, 0x51, 0x1b, 0xc0, 0x8d, 0x09, 0xe6, 0xc4, 0x73,
	0x30, 0x97, 0xe4, 0xb9, 0x2e, 0x17, 0xcb, 0x5a, 0xaf, 0xc5, 0xeb, 0xff, 0x28, 0xc1, 0xd2, 0x25,
	0x57, 0xa2, 0x1f, 0x02, 0x68, 0xaf, 0x9b, 0x94, 0x50, 0xb6, 0xcb, 0x7a, 0x64, 0xd7, 0x43, 0x0f,
	0xc0, 0x7c, 0x90, 0x58, 0x27, 0x83, 0xab, 0xdd, 0x9a, 0x4d, 0xbd, 0xe8, 0xdb, 0xe2, 0x25, 0xdf,
	0x3e, 0x85, 0x45, 0x43, 0x3c, 0xe3, 0xdc, 0xbc, 0x4e, 0x58, 0x30, 0x40, 0xda, 0xbb, 0x0f, 0x61,
	0xce, 0x1c, 0xe9, 0xc6, 0xb1, 0x3b, 0xab, 0x35, 0x65, 0xd8, 0x76, 0x61, 0x36, 0x09, 0xfd, 0xc8,
	0xfd, 0x44, 0xe1, 0xdc, 0xc4, 0xee, 0xa0, 0x14, 0x25, 0xcc, 0x43, 0xb8, 0xc5, 0x38, 0xe6, 0x09,
	0x93, 0x51, 0xbc, 0xb0, 0xdd, 0x6c, 0xbc, 0xba, 0x2a, 0x34, 0x2e, 0x79, 0xa7, 0x2f, 0xd5, 0x6c,
	0xad, 0x8e, 0x7e, 0x0d, 0x15, 0xc2, 0x38, 0x0d, 0x14, 0x11, 0x94, 0xd1, 0x66, 0x72, 0x1a, 0x6d,
	0x31, 0x45, 0xd2, 0x56, 0x7b, 0x1f, 0x96, 0x8d, 0xd5, 0x06, 0xf2, 0xcc, 0xc7, 0x84, 0x0e, 0x8f,
	0x79, 0xad, 0xbc, 0x61, 0x6d, 0x15, 0x6d, 0xa4, 0x65, 0x3b, 0x42, 0xf4, 0x48, 0x4a, 0xea, 0x7f,
	0x9f, 0x06, 0x78, 0x22, 0x36, 0x2f, 0xb6, 0x49, 0x04, 0xfb, 0x79, 0xc4, 0xb1, 0x6f, 0x92, 0x31,
	0xd3, 0x69, 0x20, 0x07, 0xfb, 0x25, 0x8e, 0x4e, 0xca, 0x0c, 0xfd, 0x06, 0xaa, 0x0a, 0xf8, 0x7c,
	0xcc, 0xe6, 0x2d, 0x4d, 0x4b, 0x12, 0xac, 0x35, 0x19, 0xb8, 0x1f, 0x42, 0x59, 0xad, 0x20, 0x62,
	0x36, 0x6f, 0x8e, 0x99, 0x91, 0x10, 0x22, 0x5c, 0xd7, 0x61, 0x56, 0xc1, 0x89, 0x34, 0xc7, 0x24,
	0xaf, 0x4b, 0x36, 0xc8, 0x21, 0x51, 0x8f, 0x19, 0xfa, 0x31, 0x54, 0x8c, 0x91, 0x1c, 0x12, 0xe2,
	0x81, 0x4f, 0x3c, 0xc9, 0xd2, 0x19, 0x7b, 0xd1, 0x8c, 0x77, 0xd5, 0x30, 0x6a, 0x42, 0x35, 0x4b,
	0xd0, 0xd9, 0x6c, 0x55, 0x40, 0xd0, 0x84, 0xc8, 0x28, 0xec, 0xc1, 0xa2, 0xac, 0x5f, 0x21, 0x1e,
	0x3b, 0xc9, 0xc8, 0xc3, 0x9c, 0x48, 0xda, 0x5d, 0x97, 0xb8, 0xf3, 0x42, 0x79, 0x1f, 0x8f, 0x0f,
	0xa5, 0x2a, 0x3a, 0x81, 0x75, 0x6d, 0xfb, 0x2b, 0x4b, 0x53, 0x5e, 0x06, 0xfe, 0x40, 0xf9, 0xe1,
	0x8a, 0xfa, 0xf4, 0x0b, 0xb8, 0x77, 0x79, 0xad, 0xac, 0x40, 0x95, 0x65, 0x81, 0xba, 0x3b, 0xba,
	0xa8, 0x67, 0x2a, 0x14, 0x7a, 0x07, 0x16, 0xd5, 0xc6, 0x4d, 0xce, 0x61, 0x35, 0x90, 0x7e, 0x50,
	0x24, 0x35, 0x3d, 0x11, 0xab, 0xff, 0xb7, 0x00, 0x15, 0xc9, 0x82, 0x36, 0xf6, 0xdd, 0xc4, 0xc7,
	0xb2, 0x53, 0xfa, 0xde, 0xb8, 0xfc, 0xd8, 0x50, 0xe3, 0xbb, 0x71, 0x58, 0x91, 0x49, 0x91, 0xf7,
	0x10, 0x40, 0x82, 0x39, 0xb1, 0xf0, 0xb5, 0x62, 0xef, 0x03, 0x8d, 0x78, 0xef, 0x32, 0xe2, 0x1e,
	0x19, 0x62, 0xf7, 0xac, 0x43, 0xdc, 0x09, 0xdc, 0x0e, 0x71, 0x15, 0x6e, 0x59, 0x22, 0xd9, 0xc2,
	0xf3, 0x1f, 0x41, 0xc5, 0xcd, 0x2c, 0x72, 0xf3, 0xce, 0x6a, 0x71, 0x42, 0x5b, 0xc8, 0xeb, 0x3e,
	0xcc, 0x6b, 0x33, 0xd8, 0x84, 0x25, 0x3e, 0x17, 0xe9, 0x4c, 0xb3, 0x4a, 0x5b, 0x99, 0x78, 0xb9,
	0xcd, 0xbc, 0xa8, 0x90, 0x3a, 0x06, 0xa8, 0xfe, 0x69, 0x11, 0x2a, 0x93, 0xb4, 0x90, 0x2b, 0x62,
	0xa8, 0x8e, 0x62, 0x1a, 0xba, 0x74, 0x84, 0xfd, 0x94, 0x56, 0x61, 0xee, 0x45, 0x51, 0x0a, 0x66,
	0x56, 0x0a, 0x45, 0x5d, 0x53, 0xde, 0xc8, 0xe0, 0xf3, 0x3a, 0x79, 0x41, 0x02, 0x65, 0xd0, 0x1f,
	0x42, 0xf9, 0x19, 0x21, 0xcc, 0x19, 0x61, 0x9a, 0xbf, 0x81, 0x9e, 0x11, 0x10, 0x3d, 0x4c, 0x3d,
	0xe4, 0xc1, 0xca, 0xb9, 0xd0, 0xd6, 0xcd, 0x68, 0xfe, 0x66, 0xa8, 0x3a, 0x11, 0xd0, 0xb6, 0x06,
	0xab, 0xff, 0xad, 0x00, 0x4b, 0x92, 0xa7, 0x1d, 0xca, 0x78, 0x4c, 0x07, 0x89, 0x8c, 0xaf, 0x0b,
	0x61, 0x60, 0xbd, 0xf1, 0x30, 0x28, 0xbc, 0xa9, 0x30, 0x78, 0x0c, 0x4b, 0xde, 0xc4, 0xce, 0x55,
	0x1c, 0x14, 0x6f, 0x72, 0x1b, 0x98, 0x54, 0x97, 0xfd, 0x40, 0x13, 0xaa, 0xc4, 0xa7, 0x43, 0x3a,
	0xf0, 0x89, 0x61, 0x7e, 0x94, 0x96, 0x09, 0x64, 0x44, 0x9d, 0x54, 0x52, 0xff, 0x7f, 0x11, 0xe6,
	0xf4, 0xe7, 0x1e, 0x0d, 0x28, 0x47, 0x21, 0xdc, 0x0b, 0xf0, 0xa9, 0x2c, 0x2f, 0xe9, 0xd5, 0x67,
	0x44, 0x62, 0xe7, 0x84, 0x86, 0x5e, 0x74, 0x92, 0xdb, 0x9c, 0x77, 0x02, 0x7c, 0x2a, 0x0a, 0x94,
	0x5e, 0xab, 0x47, 0xe2, 0x23, 0x09, 0x88, 0x28, 0xd4, 0xc4, 0x7a, 0xaa, 0x2f, 0x30, 0x0b, 0x8e,
	0x23, 0x3f, 0x09, 0x48, 0x6e, 0x76, 0xaf, 0x04, 0xf8, 0x54, 0x76, 0x13, 0x7a, 0xb5, 0x27, 0x12,
	0x0e, 0x7d, 0x0c, 0x68, 0xe8, 0x47, 0x83, 0x2c, 0xf5, 0x3a, 0x2e, 0x1e, 0xe5, 0x66, 0x7b, 0x45,
	0x61, 0xe9, 0x25, 0xda, 0x78, 0x84, 0x1e, 0xc0, 0x9d, 0x14, 0x38, 0x8a, 0x7c, 0x2f, 0x3a, 0x09,
	0xd5, 0xb9, 0x94, 0x03, 0x8a, 0xf6, 0x8a, 0x16, 0xb7, 0xb5, 0x54, 0xee, 0x91, 0xa1, 0x9f, 0xc0,
	0xed, 0x31, 0xf1, 0x23, 0x57, 0xdc, 0x08, 0x95, 0x99, 0x8d, 0xda, 0xb4, 0x54, 0x5b, 0x36, 0x52,
	0x65, 0x32, 0xad, 0xf5, 0x53, 0x10, 0x36, 0x4d, 0xab, 0xc8, 0xa4, 0x93, 0x44, 0x05, 0x9f, 0xb7,
	0x97, 0x03, 0x7c, 0x6a, 0x8a, 0x43, 0x6a, 0xef, 0xfa, 0xa7, 0x05, 0x58, 0x34, 0x66, 0xd1, 0xb0,
	0xe8, 0xbe, 0xbe, 0x97, 0x9a, 0xdd, 0xcb, 0xd5, 0xa5, 0xab, 0x8b, 0xea, 0xc6, 0xa9, 0x15, 0xe4,
	0xca, 0xaa, 0x9b, 0x73, 0x49, 0x96, 0x5b, 0x1d, 0x37, 0xbd, 0xcf, 0xcf, 0x8b, 0x6e, 0x4e, 0xc8,
	0x8c, 0x59, 0x64, 0xff, 0xe7, 0xc1, 0xca, 0x05, 0x0d, 0xed, 0xe0, 0xbc, 0xb6, 0xaf, 0x9e, 0x5b,
	0x44, 0xbb, 0xf7, 0x3e, 0x20, 0x11, 0x41, 0x17, 0x4c, 0xa8, 0x2c, 0x5f, 0x11, 0x92, 0x49, 0xf3,
	0xd5, 0xff, 0x68, 0x01, 0x1c, 0x1c, 0xb5, 0x7a, 0xed, 0x28, 0x7c, 0x46, 0x87, 0xa8, 0x06, 0x6f,
	0x99, 0xfe, 0xc7, 0x92, 0xfd, 0x8f, 0xf9, 0x14, 0x1d, 0x97, 0x46, 0x64, 0xf4, 0x39, 0xd1, 0xa7,
	0x04, 0x35, 0xd4, 0xa7, 0xcf, 0x09, 0xda, 0x86, 0x95, 0x80, 0x86, 0x0e, 0xd3, 0x37, 0x55, 0x87,
	0x86, 0x9c, 0xc4, 0x63, 0xec, 0xcb, 0xd3, 0x15, 0xed, 0x6a, 0x40, 0x43, 0x73, 0x8b, 0xdd, 0xd5,
	0x22, 0xb4, 0x05, 0x15, 0xe1, 0xbc, 0x54, 0x07, 0x0f, 0x89, 0xde, 0xe9, 0x42, 0x80, 0x4f, 0xcd,
	0xf4, 0xd6, 0x90, 0xd4, 0x7f, 0x5f, 0x80, 0xd9, 0xfd, 0xd6, 0x93, 0xf4, 0x1e, 0xbc, 0x03, 0x45,
	0xd1, 0x49, 0xe6, 0x8d, 0x43, 0xa1, 0x8c, 0x76, 0xa0, 0x9c, 0x3e, 0xe8, 0xc8, 0x03, 0x5d, 0xfb,
	0xca, 0x97, 0xaa, 0xa1, 0xb7, 0x61, 0xee, 0x5c, 0x2f, 0xaf, 0x0e, 0x3b, 0x3b, 0xc8, 0x9a, 0x78,
	0xd4, 0x87, 0x39, 0x95, 0x89, 0xd9, 0x31, 0x8e, 0x09, 0xcb, 0x9d, 0xfc, 0x55, 0x3e, 0xef, 0x4b,
	0x90, 0xfa, 0x5f, 0x4b, 0x50, 0xc9, 0x9e, 0x07, 0xda, 0x49, 0xcc, 0xa2, 0x18, 0x3d, 0x82, 0xaa,
	0x24, 0xf0, 0x28, 0x8e, 0x5c, 0xc2, 0x18, 0xf1, 0x9c, 0x6b, 0xbd, 0x15, 0x2c, 0x09, 0xa5, 0x9e,
	0xd1, 0x11, 0xe9, 0xe9, 0x15, 0xf7, 0xec, 0xc2, 0x9b, 0xb9, 0x67, 0x7f, 0x0c, 0xb5, 0xf3, 0xc0,
	0x4e, 0xe6, 0x82, 0x9b, 0xe4, 0xfc, 0xdb, 0xe7, 0x60, 0xd3, 0x19, 0x22, 0xf3, 0xa7, 0xed, 0x68,
	0x66, 0x07, 0x93, 0xf9, 0x53, 0x51, 0x7a, 0xda, 0x57, 0x75, 0xb1, 0xd3, 0xaf, 0xea, 0x62, 0x45,
	0x00, 0xd0, 0x50, 0x40, 0x0e, 0x85, 0xe9, 0xf4, 0xf5, 0x00, 0x68, 0xd8, 0xd3, 0x23, 0xa8, 0x0d,
	0xc0, 0x38, 0x8e, 0xf5, 0x13, 0xc2, 0x4d, 0x6e, 0x04, 0x65, 0xad, 0xd7, 0xe2, 0xc8, 0x85, 0x65,
	0xec, 0xba, 0x49, 0x20, 0xda, 0x3a, 0xe2, 0x39, 0x31, 0x61, 0xd4, 0x4b, 0xbe, 0xc3, 0x15, 0xa0,
	0x3a, 0x81, 0x66, 0x6b, 0xb0, 0x77, 0xff, 0x63, 0xc1, 0x9d, 0x2b, 0x6e, 0xc2, 0xe8, 0x47, 0xf0,
	0xf6, 0xd1, 0xee, 0xc1, 0xa3, 0x8e, 0xdd, 0x3a, 0x6a, 0xed, 0x39, 0x76, 0xf7, 0xf1, 0x61, 0xb7,
	0x7f, 0xe0, 0xf4, 0x0f, 0x5a, 0x07, 0x87, 0x7d, 0xa7, 0xd7, 0xdd, 0xef, 0xec, 0xee, 0x3f, 0xac,
	0x4c, 0xa1, 0x4d, 0x58, 0xbf, 0x7a, 0x9a, 0xdd, 0x6d, 0x75, 0x9e, 0x56, 0x2c, 0xf4, 0x0e, 0x6c,
	0xbe, 0x06, 0xcb, 0xfe, 0xa8, 0xdd, 0xed, 0xf7, 0xbb, 0x9d, 0x4a, 0xe1, 0xf5, 0x13, 0xdb, 0xad,
	0xfd, 0x76, 0x77, 0x6f, 0xaf, 0xdb, 0xa9, 0x14, 0x5f, 0xbf, 0xbb, 0xee, 0x2f, 0x7b, 0xbb, 0x76,
	0xb7, 0x53, 0x29, 0xad, 0x96, 0x7e, 0xf7, 0x87, 0xb5, 0xa9, 0x9d, 0x9f, 0x7f, 0xf1, 0x62, 0xcd,
	0xfa, 0xf2, 0xc5, 0x9a, 0xf5, 0xef, 0x17, 0x6b, 0xd6, 0x67, 0x2f, 0xd7, 0xa6, 0xbe, 0x7c, 0xb9,
	0x36, 0xf5, 0xf5, 0xcb, 0xb5, 0xa9, 0x5f, 0x6d, 0xea, 0x87, 0x01, 0xf5, 0x4a, 0x70, 0x7a, 0xf6,
	0xbc, 0x39, 0xfe, 0xa0, 0xc9, 0xcf, 0x46, 0x84, 0x65, 0xcf, 0xcc, 0x83, 0x5b, 0xd2, 0x67, 0x1f,
	0x7c, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x62, 0x07, 0x27, 0x21, 0x87, 0x16, 0x00, 0x00,
}

func (m *UserPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActiveWithdrawalRequests != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.ActiveWithdrawalRequests))
		i--
		dAtA[i] = 0x40
	}
	{
		size := m.AmountPendingWithdrawal.Size()
		i -= size
		if _, err := m.AmountPendingWithdrawal.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.ReceiveYield {
		i--
		if m.ReceiveYield {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastActivityTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastActivityTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintVaults(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x2a
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.FirstDepositTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.FirstDepositTime):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintVaults(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x22
	{
		size := m.AccruedYield.Size()
		i -= size
		if _, err := m.AccruedYield.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.DepositAmount.Size()
		i -= size
		if _, err := m.DepositAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PositionId != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccountingSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountingSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountingSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintVaults(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x32
	{
		size := m.AccountingNav.Size()
		i -= size
		if _, err := m.AccountingNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.AccruedYield.Size()
		i -= size
		if _, err := m.AccruedYield.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.DepositAmount.Size()
		i -= size
		if _, err := m.DepositAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PositionId != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintVaults(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestBlockHeight != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.RequestBlockHeight))
		i--
		dAtA[i] = 0x48
	}
	{
		size := m.EstimatedAmount.Size()
		i -= size
		if _, err := m.EstimatedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.Status != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UnlockTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UnlockTime):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintVaults(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x32
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.RequestTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RequestTime):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintVaults(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x2a
	{
		size := m.WithdrawAmount.Size()
		i -= size
		if _, err := m.WithdrawAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.PositionId != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintVaults(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintVaults(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalPositions != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.TotalPositions))
		i--
		dAtA[i] = 0x50
	}
	if m.PendingWithdrawalRequests != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.PendingWithdrawalRequests))
		i--
		dAtA[i] = 0x48
	}
	{
		size := m.TotalAmountPendingWithdrawal.Size()
		i -= size
		if _, err := m.TotalAmountPendingWithdrawal.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastNavUpdate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastNavUpdate):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintVaults(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x3a
	if m.WithdrawalsEnabled {
		i--
		if m.WithdrawalsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DepositsEnabled {
		i--
		if m.DepositsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TotalUsers != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.TotalUsers))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.TotalNav.Size()
		i -= size
		if _, err := m.TotalNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalAccruedYield.Size()
		i -= size
		if _, err := m.TotalAccruedYield.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalDeposits.Size()
		i -= size
		if _, err := m.TotalDeposits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *YieldCalculation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *YieldCalculation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *YieldCalculation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CalculationTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CalculationTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintVaults(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x22
	{
		size := m.YieldRate.Size()
		i -= size
		if _, err := m.YieldRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalYield.Size()
		i -= size
		if _, err := m.TotalYield.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalDeposits.Size()
		i -= size
		if _, err := m.TotalDeposits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DepositResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AmountDeposited.Size()
		i -= size
		if _, err := m.AmountDeposited.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WithdrawalResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawalResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawalResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalAmountReceived.Size()
		i -= size
		if _, err := m.TotalAmountReceived.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.FeesPaid.Size()
		i -= size
		if _, err := m.FeesPaid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.YieldWithdrawn.Size()
		i -= size
		if _, err := m.YieldWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.PrincipalWithdrawn.Size()
		i -= size
		if _, err := m.PrincipalWithdrawn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *YieldDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *YieldDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *YieldDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EligibleDepositors != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.EligibleDepositors))
		i--
		dAtA[i] = 0x20
	}
	n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.DistributionTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DistributionTime):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintVaults(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x1a
	{
		size := m.YieldRate.Size()
		i -= size
		if _, err := m.YieldRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalYield.Size()
		i -= size
		if _, err := m.TotalYield.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DepositLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxDepositsPerWindow != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.MaxDepositsPerWindow))
		i--
		dAtA[i] = 0x30
	}
	if m.VelocityWindowBlocks != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.VelocityWindowBlocks))
		i--
		dAtA[i] = 0x28
	}
	if m.DepositCooldownBlocks != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.DepositCooldownBlocks))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.GlobalDepositCap.Size()
		i -= size
		if _, err := m.GlobalDepositCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MaxBlockDepositVolume.Size()
		i -= size
		if _, err := m.MaxBlockDepositVolume.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.MaxUserDepositPerWindow.Size()
		i -= size
		if _, err := m.MaxUserDepositPerWindow.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DepositVelocity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositVelocity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositVelocity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeWindowBlocks != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.TimeWindowBlocks))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.RecentDepositVolume.Size()
		i -= size
		if _, err := m.RecentDepositVolume.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RecentDepositCount != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.RecentDepositCount))
		i--
		dAtA[i] = 0x10
	}
	if m.LastDepositBlock != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.LastDepositBlock))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TWAPConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TWAPConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TWAPConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxSnapshotAge != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.MaxSnapshotAge))
		i--
		dAtA[i] = 0x20
	}
	if m.MinSnapshotInterval != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.MinSnapshotInterval))
		i--
		dAtA[i] = 0x18
	}
	if m.WindowSize != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.WindowSize))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NAVSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NAVSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NAVSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalShares.Size()
		i -= size
		if _, err := m.TotalShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.BlockHeight != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x18
	}
	n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintVaults(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x12
	{
		size := m.Nav.Size()
		i -= size
		if _, err := m.Nav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AccountingCursor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountingCursor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountingCursor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.AccumulatedResidual.Size()
		i -= size
		if _, err := m.AccumulatedResidual.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.StartedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.StartedAt):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintVaults(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x3a
	if m.InProgress {
		i--
		if m.InProgress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TotalPositions != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.TotalPositions))
		i--
		dAtA[i] = 0x28
	}
	if m.PositionsProcessed != 0 {
		i = encodeVarintVaults(dAtA, i, uint64(m.PositionsProcessed))
		i--
		dAtA[i] = 0x20
	}
	n11, err11 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.AccountingNavTimestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.AccountingNavTimestamp):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintVaults(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x1a
	{
		size := m.AccountingNav.Size()
		i -= size
		if _, err := m.AccountingNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintVaults(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.LastProcessedUser) > 0 {
		i -= len(m.LastProcessedUser)
		copy(dAtA[i:], m.LastProcessedUser)
		i = encodeVarintVaults(dAtA, i, uint64(len(m.LastProcessedUser)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintVaults(dAtA []byte, offset int, v uint64) int {
	offset -= sovVaults(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovVaults(uint64(m.PositionId))
	}
	l = m.DepositAmount.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.AccruedYield.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.FirstDepositTime)
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastActivityTime)
	n += 1 + l + sovVaults(uint64(l))
	if m.ReceiveYield {
		n += 2
	}
	l = m.AmountPendingWithdrawal.Size()
	n += 1 + l + sovVaults(uint64(l))
	if m.ActiveWithdrawalRequests != 0 {
		n += 1 + sovVaults(uint64(m.ActiveWithdrawalRequests))
	}
	return n
}

func (m *AccountingSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovVaults(uint64(l))
	}
	if m.PositionId != 0 {
		n += 1 + sovVaults(uint64(m.PositionId))
	}
	l = m.DepositAmount.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.AccruedYield.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.AccountingNav.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovVaults(uint64(l))
	return n
}

func (m *WithdrawalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovVaults(uint64(l))
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovVaults(uint64(l))
	}
	if m.PositionId != 0 {
		n += 1 + sovVaults(uint64(m.PositionId))
	}
	l = m.WithdrawAmount.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RequestTime)
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UnlockTime)
	n += 1 + l + sovVaults(uint64(l))
	if m.Status != 0 {
		n += 1 + sovVaults(uint64(m.Status))
	}
	l = m.EstimatedAmount.Size()
	n += 1 + l + sovVaults(uint64(l))
	if m.RequestBlockHeight != 0 {
		n += 1 + sovVaults(uint64(m.RequestBlockHeight))
	}
	return n
}

func (m *VaultState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalDeposits.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.TotalAccruedYield.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.TotalNav.Size()
	n += 1 + l + sovVaults(uint64(l))
	if m.TotalUsers != 0 {
		n += 1 + sovVaults(uint64(m.TotalUsers))
	}
	if m.DepositsEnabled {
		n += 2
	}
	if m.WithdrawalsEnabled {
		n += 2
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastNavUpdate)
	n += 1 + l + sovVaults(uint64(l))
	l = m.TotalAmountPendingWithdrawal.Size()
	n += 1 + l + sovVaults(uint64(l))
	if m.PendingWithdrawalRequests != 0 {
		n += 1 + sovVaults(uint64(m.PendingWithdrawalRequests))
	}
	if m.TotalPositions != 0 {
		n += 1 + sovVaults(uint64(m.TotalPositions))
	}
	return n
}

func (m *YieldCalculation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalDeposits.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.TotalYield.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.YieldRate.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CalculationTime)
	n += 1 + l + sovVaults(uint64(l))
	return n
}

func (m *DepositResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountDeposited.Size()
	n += 1 + l + sovVaults(uint64(l))
	return n
}

func (m *WithdrawalResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PrincipalWithdrawn.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.YieldWithdrawn.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.FeesPaid.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.TotalAmountReceived.Size()
	n += 1 + l + sovVaults(uint64(l))
	return n
}

func (m *YieldDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalYield.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.YieldRate.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.DistributionTime)
	n += 1 + l + sovVaults(uint64(l))
	if m.EligibleDepositors != 0 {
		n += 1 + sovVaults(uint64(m.EligibleDepositors))
	}
	return n
}

func (m *DepositLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MaxUserDepositPerWindow.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.MaxBlockDepositVolume.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = m.GlobalDepositCap.Size()
	n += 1 + l + sovVaults(uint64(l))
	if m.DepositCooldownBlocks != 0 {
		n += 1 + sovVaults(uint64(m.DepositCooldownBlocks))
	}
	if m.VelocityWindowBlocks != 0 {
		n += 1 + sovVaults(uint64(m.VelocityWindowBlocks))
	}
	if m.MaxDepositsPerWindow != 0 {
		n += 1 + sovVaults(uint64(m.MaxDepositsPerWindow))
	}
	return n
}

func (m *DepositVelocity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastDepositBlock != 0 {
		n += 1 + sovVaults(uint64(m.LastDepositBlock))
	}
	if m.RecentDepositCount != 0 {
		n += 1 + sovVaults(uint64(m.RecentDepositCount))
	}
	l = m.RecentDepositVolume.Size()
	n += 1 + l + sovVaults(uint64(l))
	if m.TimeWindowBlocks != 0 {
		n += 1 + sovVaults(uint64(m.TimeWindowBlocks))
	}
	return n
}

func (m *TWAPConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.WindowSize != 0 {
		n += 1 + sovVaults(uint64(m.WindowSize))
	}
	if m.MinSnapshotInterval != 0 {
		n += 1 + sovVaults(uint64(m.MinSnapshotInterval))
	}
	if m.MaxSnapshotAge != 0 {
		n += 1 + sovVaults(uint64(m.MaxSnapshotAge))
	}
	return n
}

func (m *NAVSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Nav.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovVaults(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovVaults(uint64(m.BlockHeight))
	}
	l = m.TotalShares.Size()
	n += 1 + l + sovVaults(uint64(l))
	return n
}

func (m *AccountingCursor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LastProcessedUser)
	if l > 0 {
		n += 1 + l + sovVaults(uint64(l))
	}
	l = m.AccountingNav.Size()
	n += 1 + l + sovVaults(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.AccountingNavTimestamp)
	n += 1 + l + sovVaults(uint64(l))
	if m.PositionsProcessed != 0 {
		n += 1 + sovVaults(uint64(m.PositionsProcessed))
	}
	if m.TotalPositions != 0 {
		n += 1 + sovVaults(uint64(m.TotalPositions))
	}
	if m.InProgress {
		n += 2
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.StartedAt)
	n += 1 + l + sovVaults(uint64(l))
	l = m.AccumulatedResidual.Size()
	n += 1 + l + sovVaults(uint64(l))
	return n
}

func sovVaults(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVaults(x uint64) (n int) {
	return sovVaults(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccruedYield", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccruedYield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstDepositTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.FirstDepositTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActivityTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastActivityTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveYield", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiveYield = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountPendingWithdrawal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountPendingWithdrawal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveWithdrawalRequests", wireType)
			}
			m.ActiveWithdrawalRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveWithdrawalRequests |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountingSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountingSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountingSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccruedYield", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccruedYield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountingNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccountingNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WithdrawAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UnlockTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= WithdrawalRequestStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EstimatedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestBlockHeight", wireType)
			}
			m.RequestBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalDeposits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAccruedYield", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAccruedYield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsers", wireType)
			}
			m.TotalUsers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsers |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DepositsEnabled = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithdrawalsEnabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastNavUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastNavUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmountPendingWithdrawal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmountPendingWithdrawal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingWithdrawalRequests", wireType)
			}
			m.PendingWithdrawalRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingWithdrawalRequests |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPositions", wireType)
			}
			m.TotalPositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPositions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *YieldCalculation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: YieldCalculation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: YieldCalculation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDeposits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalDeposits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalYield", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalYield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YieldRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalculationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CalculationTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountDeposited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountDeposited.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawalResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawalResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawalResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrincipalWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrincipalWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldWithdrawn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YieldWithdrawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesPaid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeesPaid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmountReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmountReceived.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *YieldDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: YieldDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: YieldDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalYield", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalYield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YieldRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.DistributionTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EligibleDepositors", wireType)
			}
			m.EligibleDepositors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EligibleDepositors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUserDepositPerWindow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxUserDepositPerWindow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBlockDepositVolume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxBlockDepositVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalDepositCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GlobalDepositCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositCooldownBlocks", wireType)
			}
			m.DepositCooldownBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositCooldownBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VelocityWindowBlocks", wireType)
			}
			m.VelocityWindowBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VelocityWindowBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDepositsPerWindow", wireType)
			}
			m.MaxDepositsPerWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDepositsPerWindow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositVelocity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositVelocity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositVelocity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDepositBlock", wireType)
			}
			m.LastDepositBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastDepositBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentDepositCount", wireType)
			}
			m.RecentDepositCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecentDepositCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentDepositVolume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecentDepositVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeWindowBlocks", wireType)
			}
			m.TimeWindowBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeWindowBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TWAPConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TWAPConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TWAPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowSize", wireType)
			}
			m.WindowSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSnapshotInterval", wireType)
			}
			m.MinSnapshotInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSnapshotInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSnapshotAge", wireType)
			}
			m.MaxSnapshotAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSnapshotAge |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NAVSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NAVSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NAVSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Nav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountingCursor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountingCursor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountingCursor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProcessedUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastProcessedUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountingNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccountingNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountingNavTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.AccountingNavTimestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionsProcessed", wireType)
			}
			m.PositionsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionsProcessed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPositions", wireType)
			}
			m.TotalPositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPositions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InProgress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InProgress = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.StartedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccumulatedResidual", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVaults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVaults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccumulatedResidual.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVaults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVaults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVaults(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVaults
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVaults
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVaults
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVaults
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVaults
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVaults        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVaults          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVaults = fmt.Errorf("proto: unexpected end of group")
)
