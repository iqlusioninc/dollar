// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/fees.proto

package v2

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// FeeType defines the different types of fees that can be collected
type FeeType int32

const (
	// Management fee charged periodically
	FEE_TYPE_MANAGEMENT FeeType = 0
	// Performance fee on positive returns
	FEE_TYPE_PERFORMANCE FeeType = 1
)

var FeeType_name = map[int32]string{
	0: "FEE_TYPE_MANAGEMENT",
	1: "FEE_TYPE_PERFORMANCE",
}

var FeeType_value = map[string]int32{
	"FEE_TYPE_MANAGEMENT":  0,
	"FEE_TYPE_PERFORMANCE": 1,
}

func (x FeeType) String() string {
	return proto.EnumName(FeeType_name, int32(x))
}

func (FeeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_679151218fb83e25, []int{0}
}

// FeeConfig defines the configuration for various fees
type FeeConfig struct {
	// Management fee rate (annual basis points)
	ManagementFeeRate int32 `protobuf:"varint,1,opt,name=management_fee_rate,json=managementFeeRate,proto3" json:"management_fee_rate,omitempty"`
	// Performance fee rate (basis points)
	PerformanceFeeRate int32 `protobuf:"varint,2,opt,name=performance_fee_rate,json=performanceFeeRate,proto3" json:"performance_fee_rate,omitempty"`
	// Fee recipient address
	FeeRecipient string `protobuf:"bytes,3,opt,name=fee_recipient,json=feeRecipient,proto3" json:"fee_recipient,omitempty"`
	// Whether fees are enabled
	FeesEnabled bool `protobuf:"varint,4,opt,name=fees_enabled,json=feesEnabled,proto3" json:"fees_enabled,omitempty"`
	// High water mark for performance fees
	HighWaterMark cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=high_water_mark,json=highWaterMark,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"high_water_mark"`
}

func (m *FeeConfig) Reset()         { *m = FeeConfig{} }
func (m *FeeConfig) String() string { return proto.CompactTextString(m) }
func (*FeeConfig) ProtoMessage()    {}
func (*FeeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_679151218fb83e25, []int{0}
}
func (m *FeeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeConfig.Merge(m, src)
}
func (m *FeeConfig) XXX_Size() int {
	return m.Size()
}
func (m *FeeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_FeeConfig proto.InternalMessageInfo

func (m *FeeConfig) GetManagementFeeRate() int32 {
	if m != nil {
		return m.ManagementFeeRate
	}
	return 0
}

func (m *FeeConfig) GetPerformanceFeeRate() int32 {
	if m != nil {
		return m.PerformanceFeeRate
	}
	return 0
}

func (m *FeeConfig) GetFeeRecipient() string {
	if m != nil {
		return m.FeeRecipient
	}
	return ""
}

func (m *FeeConfig) GetFeesEnabled() bool {
	if m != nil {
		return m.FeesEnabled
	}
	return false
}

// YieldDeductionParams defines parameters for fee collection from yield
type YieldDeductionParams struct {
	// Target fee rate on yield (basis points)
	YieldFeeRate int32 `protobuf:"varint,1,opt,name=yield_fee_rate,json=yieldFeeRate,proto3" json:"yield_fee_rate,omitempty"`
	// Minimum fee amount per period
	MinFeeAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=min_fee_amount,json=minFeeAmount,proto3,customtype=cosmossdk.io/math.Int" json:"min_fee_amount"`
	// Maximum fee amount per period
	MaxFeeAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=max_fee_amount,json=maxFeeAmount,proto3,customtype=cosmossdk.io/math.Int" json:"max_fee_amount"`
	// Fee collection frequency (seconds)
	CollectionFrequency int64 `protobuf:"varint,4,opt,name=collection_frequency,json=collectionFrequency,proto3" json:"collection_frequency,omitempty"`
	// Last collection timestamp
	LastCollection time.Time `protobuf:"bytes,5,opt,name=last_collection,json=lastCollection,proto3,stdtime" json:"last_collection"`
}

func (m *YieldDeductionParams) Reset()         { *m = YieldDeductionParams{} }
func (m *YieldDeductionParams) String() string { return proto.CompactTextString(m) }
func (*YieldDeductionParams) ProtoMessage()    {}
func (*YieldDeductionParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_679151218fb83e25, []int{1}
}
func (m *YieldDeductionParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *YieldDeductionParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_YieldDeductionParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *YieldDeductionParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YieldDeductionParams.Merge(m, src)
}
func (m *YieldDeductionParams) XXX_Size() int {
	return m.Size()
}
func (m *YieldDeductionParams) XXX_DiscardUnknown() {
	xxx_messageInfo_YieldDeductionParams.DiscardUnknown(m)
}

var xxx_messageInfo_YieldDeductionParams proto.InternalMessageInfo

func (m *YieldDeductionParams) GetYieldFeeRate() int32 {
	if m != nil {
		return m.YieldFeeRate
	}
	return 0
}

func (m *YieldDeductionParams) GetCollectionFrequency() int64 {
	if m != nil {
		return m.CollectionFrequency
	}
	return 0
}

func (m *YieldDeductionParams) GetLastCollection() time.Time {
	if m != nil {
		return m.LastCollection
	}
	return time.Time{}
}

// FeeAccrual represents accrued fees for a specific period
type FeeAccrual struct {
	// Fee type
	FeeType FeeType `protobuf:"varint,1,opt,name=fee_type,json=feeType,proto3,enum=noble.dollar.vaults.v2.FeeType" json:"fee_type,omitempty"`
	// Accrued amount
	AccruedAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=accrued_amount,json=accruedAmount,proto3,customtype=cosmossdk.io/math.Int" json:"accrued_amount"`
	// Yield to be deducted for this fee
	YieldToDeduct cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=yield_to_deduct,json=yieldToDeduct,proto3,customtype=cosmossdk.io/math.Int" json:"yield_to_deduct"`
	// Accrual period start
	PeriodStart time.Time `protobuf:"bytes,4,opt,name=period_start,json=periodStart,proto3,stdtime" json:"period_start"`
	// Accrual period end
	PeriodEnd time.Time `protobuf:"bytes,5,opt,name=period_end,json=periodEnd,proto3,stdtime" json:"period_end"`
	// Whether this accrual has been collected
	Collected bool `protobuf:"varint,6,opt,name=collected,proto3" json:"collected,omitempty"`
}

func (m *FeeAccrual) Reset()         { *m = FeeAccrual{} }
func (m *FeeAccrual) String() string { return proto.CompactTextString(m) }
func (*FeeAccrual) ProtoMessage()    {}
func (*FeeAccrual) Descriptor() ([]byte, []int) {
	return fileDescriptor_679151218fb83e25, []int{2}
}
func (m *FeeAccrual) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeAccrual) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeAccrual.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeAccrual) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeAccrual.Merge(m, src)
}
func (m *FeeAccrual) XXX_Size() int {
	return m.Size()
}
func (m *FeeAccrual) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeAccrual.DiscardUnknown(m)
}

var xxx_messageInfo_FeeAccrual proto.InternalMessageInfo

func (m *FeeAccrual) GetFeeType() FeeType {
	if m != nil {
		return m.FeeType
	}
	return FEE_TYPE_MANAGEMENT
}

func (m *FeeAccrual) GetPeriodStart() time.Time {
	if m != nil {
		return m.PeriodStart
	}
	return time.Time{}
}

func (m *FeeAccrual) GetPeriodEnd() time.Time {
	if m != nil {
		return m.PeriodEnd
	}
	return time.Time{}
}

func (m *FeeAccrual) GetCollected() bool {
	if m != nil {
		return m.Collected
	}
	return false
}

// FeeCollection represents a completed fee collection event
type FeeCollection struct {
	// Collection timestamp
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Total fee amount collected
	TotalAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_amount,json=totalAmount,proto3,customtype=cosmossdk.io/math.Int" json:"total_amount"`
	// Yield deducted for collection
	YieldDeducted cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=yield_deducted,json=yieldDeducted,proto3,customtype=cosmossdk.io/math.Int" json:"yield_deducted"`
	// Breakdown by fee type
	Breakdown []*FeeTypeBreakdown `protobuf:"bytes,4,rep,name=breakdown,proto3" json:"breakdown,omitempty"`
	// Block height when collected
	BlockHeight int64 `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
}

func (m *FeeCollection) Reset()         { *m = FeeCollection{} }
func (m *FeeCollection) String() string { return proto.CompactTextString(m) }
func (*FeeCollection) ProtoMessage()    {}
func (*FeeCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_679151218fb83e25, []int{3}
}
func (m *FeeCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeCollection.Merge(m, src)
}
func (m *FeeCollection) XXX_Size() int {
	return m.Size()
}
func (m *FeeCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeCollection.DiscardUnknown(m)
}

var xxx_messageInfo_FeeCollection proto.InternalMessageInfo

func (m *FeeCollection) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *FeeCollection) GetBreakdown() []*FeeTypeBreakdown {
	if m != nil {
		return m.Breakdown
	}
	return nil
}

func (m *FeeCollection) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// FeeTypeBreakdown provides details for each fee type in a collection
type FeeTypeBreakdown struct {
	// Fee type
	FeeType FeeType `protobuf:"varint,1,opt,name=fee_type,json=feeType,proto3,enum=noble.dollar.vaults.v2.FeeType" json:"fee_type,omitempty"`
	// Amount for this fee type
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Yield deducted for this fee type
	YieldDeducted cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=yield_deducted,json=yieldDeducted,proto3,customtype=cosmossdk.io/math.Int" json:"yield_deducted"`
	// Fee rate applied (basis points)
	RateApplied int32 `protobuf:"varint,4,opt,name=rate_applied,json=rateApplied,proto3" json:"rate_applied,omitempty"`
}

func (m *FeeTypeBreakdown) Reset()         { *m = FeeTypeBreakdown{} }
func (m *FeeTypeBreakdown) String() string { return proto.CompactTextString(m) }
func (*FeeTypeBreakdown) ProtoMessage()    {}
func (*FeeTypeBreakdown) Descriptor() ([]byte, []int) {
	return fileDescriptor_679151218fb83e25, []int{4}
}
func (m *FeeTypeBreakdown) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeTypeBreakdown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeTypeBreakdown.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeTypeBreakdown) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeTypeBreakdown.Merge(m, src)
}
func (m *FeeTypeBreakdown) XXX_Size() int {
	return m.Size()
}
func (m *FeeTypeBreakdown) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeTypeBreakdown.DiscardUnknown(m)
}

var xxx_messageInfo_FeeTypeBreakdown proto.InternalMessageInfo

func (m *FeeTypeBreakdown) GetFeeType() FeeType {
	if m != nil {
		return m.FeeType
	}
	return FEE_TYPE_MANAGEMENT
}

func (m *FeeTypeBreakdown) GetRateApplied() int32 {
	if m != nil {
		return m.RateApplied
	}
	return 0
}

// FeeStats provides statistics about fee collection
type FeeStats struct {
	// Total fees collected (all time)
	TotalFeesCollected cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_fees_collected,json=totalFeesCollected,proto3,customtype=cosmossdk.io/math.Int" json:"total_fees_collected"`
	// Total yield collected for fees
	TotalYieldCollected cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_yield_collected,json=totalYieldCollected,proto3,customtype=cosmossdk.io/math.Int" json:"total_yield_collected"`
	// Current annualized fee rate (basis points)
	CurrentAnnualRate int32 `protobuf:"varint,3,opt,name=current_annual_rate,json=currentAnnualRate,proto3" json:"current_annual_rate,omitempty"`
	// Last fee collection timestamp
	LastCollection time.Time `protobuf:"bytes,4,opt,name=last_collection,json=lastCollection,proto3,stdtime" json:"last_collection"`
	// Average daily fee collection
	AvgDailyCollection cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=avg_daily_collection,json=avgDailyCollection,proto3,customtype=cosmossdk.io/math.Int" json:"avg_daily_collection"`
	// Fee collection frequency (seconds)
	CollectionFrequency int64 `protobuf:"varint,6,opt,name=collection_frequency,json=collectionFrequency,proto3" json:"collection_frequency,omitempty"`
}

func (m *FeeStats) Reset()         { *m = FeeStats{} }
func (m *FeeStats) String() string { return proto.CompactTextString(m) }
func (*FeeStats) ProtoMessage()    {}
func (*FeeStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_679151218fb83e25, []int{5}
}
func (m *FeeStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeStats.Merge(m, src)
}
func (m *FeeStats) XXX_Size() int {
	return m.Size()
}
func (m *FeeStats) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeStats.DiscardUnknown(m)
}

var xxx_messageInfo_FeeStats proto.InternalMessageInfo

func (m *FeeStats) GetCurrentAnnualRate() int32 {
	if m != nil {
		return m.CurrentAnnualRate
	}
	return 0
}

func (m *FeeStats) GetLastCollection() time.Time {
	if m != nil {
		return m.LastCollection
	}
	return time.Time{}
}

func (m *FeeStats) GetCollectionFrequency() int64 {
	if m != nil {
		return m.CollectionFrequency
	}
	return 0
}

// PerformanceFeeState tracks performance fee calculations
type PerformanceFeeState struct {
	// Current high water mark (total NAV)
	HighWaterMark cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=high_water_mark,json=highWaterMark,proto3,customtype=cosmossdk.io/math.Int" json:"high_water_mark"`
	// Last performance fee calculation
	LastCalculation time.Time `protobuf:"bytes,2,opt,name=last_calculation,json=lastCalculation,proto3,stdtime" json:"last_calculation"`
	// Current period start (for performance measurement)
	PeriodStart time.Time `protobuf:"bytes,3,opt,name=period_start,json=periodStart,proto3,stdtime" json:"period_start"`
	// Accrued performance fees (not yet collected)
	AccruedPerformanceFees cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=accrued_performance_fees,json=accruedPerformanceFees,proto3,customtype=cosmossdk.io/math.Int" json:"accrued_performance_fees"`
	// Whether performance fees are currently active
	Active bool `protobuf:"varint,5,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *PerformanceFeeState) Reset()         { *m = PerformanceFeeState{} }
func (m *PerformanceFeeState) String() string { return proto.CompactTextString(m) }
func (*PerformanceFeeState) ProtoMessage()    {}
func (*PerformanceFeeState) Descriptor() ([]byte, []int) {
	return fileDescriptor_679151218fb83e25, []int{6}
}
func (m *PerformanceFeeState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerformanceFeeState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerformanceFeeState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerformanceFeeState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerformanceFeeState.Merge(m, src)
}
func (m *PerformanceFeeState) XXX_Size() int {
	return m.Size()
}
func (m *PerformanceFeeState) XXX_DiscardUnknown() {
	xxx_messageInfo_PerformanceFeeState.DiscardUnknown(m)
}

var xxx_messageInfo_PerformanceFeeState proto.InternalMessageInfo

func (m *PerformanceFeeState) GetLastCalculation() time.Time {
	if m != nil {
		return m.LastCalculation
	}
	return time.Time{}
}

func (m *PerformanceFeeState) GetPeriodStart() time.Time {
	if m != nil {
		return m.PeriodStart
	}
	return time.Time{}
}

func (m *PerformanceFeeState) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// FeeExemption represents an exemption from certain fees for specific addresses
type FeeExemption struct {
	// Exempt address
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Exempted fee types
	ExemptedTypes []FeeType `protobuf:"varint,2,rep,packed,name=exempted_types,json=exemptedTypes,proto3,enum=noble.dollar.vaults.v2.FeeType" json:"exempted_types,omitempty"`
	// Exemption expiry (if applicable)
	Expiry *time.Time `protobuf:"bytes,3,opt,name=expiry,proto3,stdtime" json:"expiry,omitempty"`
	// Exemption reason
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// Whether exemption is active
	Active bool `protobuf:"varint,5,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *FeeExemption) Reset()         { *m = FeeExemption{} }
func (m *FeeExemption) String() string { return proto.CompactTextString(m) }
func (*FeeExemption) ProtoMessage()    {}
func (*FeeExemption) Descriptor() ([]byte, []int) {
	return fileDescriptor_679151218fb83e25, []int{7}
}
func (m *FeeExemption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeExemption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeExemption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeExemption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeExemption.Merge(m, src)
}
func (m *FeeExemption) XXX_Size() int {
	return m.Size()
}
func (m *FeeExemption) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeExemption.DiscardUnknown(m)
}

var xxx_messageInfo_FeeExemption proto.InternalMessageInfo

func (m *FeeExemption) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *FeeExemption) GetExemptedTypes() []FeeType {
	if m != nil {
		return m.ExemptedTypes
	}
	return nil
}

func (m *FeeExemption) GetExpiry() *time.Time {
	if m != nil {
		return m.Expiry
	}
	return nil
}

func (m *FeeExemption) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *FeeExemption) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// FeeSchedule defines time-based fee rate changes
type FeeSchedule struct {
	// Effective date for the fee rates
	EffectiveDate time.Time `protobuf:"bytes,1,opt,name=effective_date,json=effectiveDate,proto3,stdtime" json:"effective_date"`
	// Fee configuration for this schedule
	FeeConfig *FeeConfig `protobuf:"bytes,2,opt,name=fee_config,json=feeConfig,proto3" json:"fee_config,omitempty"`
	// Whether this schedule is active
	Active bool `protobuf:"varint,3,opt,name=active,proto3" json:"active,omitempty"`
	// Description of the schedule change
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *FeeSchedule) Reset()         { *m = FeeSchedule{} }
func (m *FeeSchedule) String() string { return proto.CompactTextString(m) }
func (*FeeSchedule) ProtoMessage()    {}
func (*FeeSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_679151218fb83e25, []int{8}
}
func (m *FeeSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeSchedule.Merge(m, src)
}
func (m *FeeSchedule) XXX_Size() int {
	return m.Size()
}
func (m *FeeSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_FeeSchedule proto.InternalMessageInfo

func (m *FeeSchedule) GetEffectiveDate() time.Time {
	if m != nil {
		return m.EffectiveDate
	}
	return time.Time{}
}

func (m *FeeSchedule) GetFeeConfig() *FeeConfig {
	if m != nil {
		return m.FeeConfig
	}
	return nil
}

func (m *FeeSchedule) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *FeeSchedule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v2.FeeType", FeeType_name, FeeType_value)
	proto.RegisterType((*FeeConfig)(nil), "noble.dollar.vaults.v2.FeeConfig")
	proto.RegisterType((*YieldDeductionParams)(nil), "noble.dollar.vaults.v2.YieldDeductionParams")
	proto.RegisterType((*FeeAccrual)(nil), "noble.dollar.vaults.v2.FeeAccrual")
	proto.RegisterType((*FeeCollection)(nil), "noble.dollar.vaults.v2.FeeCollection")
	proto.RegisterType((*FeeTypeBreakdown)(nil), "noble.dollar.vaults.v2.FeeTypeBreakdown")
	proto.RegisterType((*FeeStats)(nil), "noble.dollar.vaults.v2.FeeStats")
	proto.RegisterType((*PerformanceFeeState)(nil), "noble.dollar.vaults.v2.PerformanceFeeState")
	proto.RegisterType((*FeeExemption)(nil), "noble.dollar.vaults.v2.FeeExemption")
	proto.RegisterType((*FeeSchedule)(nil), "noble.dollar.vaults.v2.FeeSchedule")
}

func init() { proto.RegisterFile("noble/dollar/vaults/v2/fees.proto", fileDescriptor_679151218fb83e25) }

var fileDescriptor_679151218fb83e25 = []byte{
	// 1219 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcd, 0x6e, 0x1b, 0xd5,
	0x17, 0xcf, 0x78, 0xd2, 0x34, 0x3e, 0xfe, 0x68, 0x7a, 0xe3, 0xf6, 0xef, 0x7f, 0x40, 0x4e, 0x62,
	0x58, 0x44, 0x95, 0x3a, 0x2e, 0xa9, 0xc4, 0x02, 0x51, 0x09, 0x3b, 0xf6, 0xb4, 0x15, 0xa4, 0x8d,
	0x26, 0x11, 0xa5, 0x2c, 0x18, 0x5d, 0xcf, 0x1c, 0x8f, 0x87, 0xcc, 0x17, 0x33, 0xd7, 0x6e, 0xcc,
	0x13, 0xb0, 0x41, 0xea, 0x82, 0x37, 0x60, 0x01, 0x3b, 0x58, 0xf4, 0x21, 0xba, 0xac, 0xba, 0x40,
	0x88, 0x45, 0x41, 0xed, 0x02, 0x09, 0x21, 0x9e, 0x01, 0xdd, 0x7b, 0x67, 0x3c, 0x6e, 0xda, 0x42,
	0xea, 0x88, 0x4d, 0xe4, 0x7b, 0x3e, 0x7e, 0xf7, 0x9c, 0xdf, 0x39, 0x73, 0xce, 0x0d, 0x6c, 0x06,
	0x61, 0xdf, 0xc3, 0x96, 0x1d, 0x7a, 0x1e, 0x8d, 0x5b, 0x63, 0x3a, 0xf2, 0x58, 0xd2, 0x1a, 0x6f,
	0xb7, 0x06, 0x88, 0x89, 0x16, 0xc5, 0x21, 0x0b, 0xc9, 0x45, 0x61, 0xa2, 0x49, 0x13, 0x4d, 0x9a,
	0x68, 0xe3, 0xed, 0xb5, 0xf3, 0xd4, 0x77, 0x83, 0xb0, 0x25, 0xfe, 0x4a, 0xd3, 0xb5, 0xff, 0x5b,
	0x61, 0xe2, 0x87, 0x89, 0x29, 0x4e, 0x2d, 0x79, 0x48, 0x55, 0x35, 0x27, 0x74, 0x42, 0x29, 0xe7,
	0xbf, 0x52, 0xe9, 0xba, 0x13, 0x86, 0x8e, 0x87, 0x2d, 0x71, 0xea, 0x8f, 0x06, 0x2d, 0xe6, 0xfa,
	0x98, 0x30, 0xea, 0x47, 0xd2, 0xa0, 0xf9, 0x43, 0x01, 0x8a, 0x3a, 0xe2, 0x4e, 0x18, 0x0c, 0x5c,
	0x87, 0x68, 0xb0, 0xea, 0xd3, 0x80, 0x3a, 0xe8, 0x63, 0xc0, 0xcc, 0x01, 0xa2, 0x19, 0x53, 0x86,
	0x75, 0x65, 0x43, 0xd9, 0x3a, 0x63, 0x9c, 0xcf, 0x55, 0x3a, 0xa2, 0x41, 0x19, 0x92, 0x2b, 0x50,
	0x8b, 0x30, 0x1e, 0x84, 0xb1, 0x4f, 0x03, 0x0b, 0x73, 0x87, 0x82, 0x70, 0x20, 0x33, 0xba, 0xcc,
	0xe3, 0x1a, 0x54, 0x84, 0x15, 0x5a, 0x6e, 0xe4, 0x62, 0xc0, 0xea, 0xea, 0x86, 0xb2, 0x55, 0xec,
	0xd4, 0x1f, 0x3f, 0xb8, 0x5c, 0x4b, 0xf3, 0x69, 0xdb, 0x76, 0x8c, 0x49, 0xb2, 0xcf, 0x62, 0x37,
	0x70, 0x8c, 0xf2, 0x00, 0xd1, 0xc8, 0xac, 0xc9, 0x26, 0xf0, 0x73, 0x62, 0x62, 0x40, 0xfb, 0x1e,
	0xda, 0xf5, 0xc5, 0x0d, 0x65, 0x6b, 0xd9, 0x28, 0x71, 0x59, 0x4f, 0x8a, 0xc8, 0x67, 0x70, 0x6e,
	0xe8, 0x3a, 0x43, 0xf3, 0x1e, 0x65, 0x18, 0x9b, 0x3e, 0x8d, 0x0f, 0xeb, 0x67, 0xc4, 0x1d, 0xef,
	0x3e, 0x7c, 0xb2, 0xbe, 0xf0, 0xcb, 0x93, 0xf5, 0x37, 0xe4, 0x3d, 0x89, 0x7d, 0xa8, 0xb9, 0x61,
	0xcb, 0xa7, 0x6c, 0xa8, 0x7d, 0x84, 0x0e, 0xb5, 0x26, 0x5d, 0xb4, 0x1e, 0x3f, 0xb8, 0x0c, 0x69,
	0x18, 0x5d, 0xb4, 0xbe, 0xff, 0xfd, 0xc7, 0x4b, 0x8a, 0x51, 0xe1, 0x70, 0x77, 0x38, 0xda, 0x2e,
	0x8d, 0x0f, 0x9b, 0x7f, 0x15, 0xa0, 0x76, 0xd7, 0x45, 0xcf, 0xee, 0xa2, 0x3d, 0xb2, 0x98, 0x1b,
	0x06, 0x7b, 0x34, 0xa6, 0x7e, 0x42, 0xde, 0x86, 0xea, 0x84, 0xcb, 0x8f, 0xf3, 0x56, 0x16, 0xd2,
	0x8c, 0x80, 0x8f, 0xa1, 0xea, 0xbb, 0x81, 0xb0, 0xa1, 0x7e, 0x38, 0x0a, 0x98, 0x20, 0xab, 0xd8,
	0xb9, 0x92, 0x46, 0x77, 0xe1, 0xc5, 0xe8, 0x6e, 0x06, 0x6c, 0x26, 0xae, 0x9b, 0x01, 0x93, 0x71,
	0x95, 0x7d, 0x37, 0xd0, 0x11, 0xdb, 0x02, 0x45, 0xe0, 0xd2, 0xa3, 0x59, 0x5c, 0x75, 0x6e, 0x5c,
	0x7a, 0x94, 0xe3, 0xbe, 0x03, 0x35, 0x2b, 0xf4, 0x3c, 0x14, 0x99, 0x9a, 0x83, 0x18, 0xbf, 0x18,
	0x61, 0x60, 0x4d, 0x04, 0xf3, 0xaa, 0xb1, 0x9a, 0xeb, 0xf4, 0x4c, 0x45, 0x76, 0xe1, 0x9c, 0x47,
	0x13, 0x66, 0xe6, 0x3a, 0x51, 0x81, 0xd2, 0xf6, 0x9a, 0x26, 0xdb, 0x51, 0xcb, 0xda, 0x51, 0x3b,
	0xc8, 0xda, 0xb1, 0xb3, 0xcc, 0xe3, 0xbc, 0xff, 0xeb, 0xba, 0x62, 0x54, 0xb9, 0xf3, 0xce, 0xd4,
	0xb7, 0xf9, 0x9d, 0x0a, 0xc0, 0xe3, 0xb1, 0xac, 0x78, 0x44, 0x3d, 0xf2, 0x1e, 0x2c, 0xf3, 0x24,
	0xd9, 0x24, 0x92, 0x04, 0x57, 0xb7, 0xd7, 0xb5, 0x97, 0x7f, 0x41, 0x9a, 0x8e, 0x78, 0x30, 0x89,
	0xd0, 0x38, 0x3b, 0x90, 0x3f, 0xc8, 0x1d, 0xa8, 0x52, 0x0e, 0x83, 0xf6, 0x69, 0xc9, 0xaf, 0xa4,
	0x38, 0x29, 0x4b, 0x9f, 0xc0, 0x39, 0x59, 0x7b, 0x16, 0x9a, 0xb6, 0xe8, 0x8b, 0xb9, 0xe9, 0xaf,
	0x08, 0xa0, 0x83, 0x50, 0xb6, 0x17, 0xb9, 0x0e, 0xe5, 0x08, 0x63, 0x37, 0xb4, 0xcd, 0x84, 0xd1,
	0x98, 0x09, 0xde, 0x4f, 0xca, 0x64, 0x49, 0x7a, 0xee, 0x73, 0x47, 0xb2, 0x03, 0x90, 0x02, 0x61,
	0x60, 0xbf, 0x56, 0x41, 0x8a, 0xd2, 0xaf, 0x17, 0xd8, 0xe4, 0x4d, 0x28, 0xa6, 0x55, 0x45, 0xbb,
	0xbe, 0x24, 0x3e, 0xbe, 0x5c, 0xd0, 0xfc, 0xb3, 0x00, 0x15, 0x31, 0x4c, 0xb2, 0xda, 0x91, 0x0e,
	0x14, 0xa7, 0x13, 0x47, 0x54, 0xeb, 0xc4, 0x77, 0x4e, 0xdd, 0xc8, 0x3e, 0x94, 0x59, 0xc8, 0xa8,
	0x77, 0xda, 0x92, 0x95, 0x04, 0x4a, 0x5a, 0xb0, 0x3b, 0xd9, 0xc7, 0x2a, 0xab, 0x85, 0xf6, 0x29,
	0xeb, 0xd5, 0x4d, 0x61, 0x88, 0x0e, 0xc5, 0x7e, 0x8c, 0xf4, 0xd0, 0x0e, 0xef, 0x05, 0xf5, 0xc5,
	0x0d, 0x75, 0xab, 0xb4, 0xbd, 0xf5, 0x2f, 0xfd, 0xd9, 0xc9, 0xec, 0x8d, 0xdc, 0x95, 0x4f, 0xba,
	0xbe, 0x17, 0x5a, 0x87, 0xe6, 0x10, 0x5d, 0x67, 0xc8, 0x44, 0xc1, 0x54, 0xa3, 0x24, 0x64, 0x37,
	0x84, 0xa8, 0xf9, 0x4d, 0x01, 0x56, 0x8e, 0x43, 0x9c, 0xea, 0xf3, 0xb8, 0x01, 0x4b, 0xa7, 0xe4,
	0x38, 0xf5, 0xff, 0xef, 0xe8, 0xdd, 0x84, 0x32, 0x1f, 0xad, 0x26, 0x8d, 0x22, 0xcf, 0x4d, 0x17,
	0xc0, 0x19, 0xa3, 0xc4, 0x65, 0x6d, 0x29, 0x6a, 0xfe, 0xa1, 0xc2, 0xb2, 0x8e, 0xb8, 0xcf, 0x28,
	0x4b, 0x48, 0x1f, 0x6a, 0xb2, 0x79, 0xc4, 0xda, 0xc8, 0x7b, 0x57, 0x99, 0x33, 0x1c, 0x22, 0xd0,
	0x74, 0xc4, 0x64, 0x27, 0xc3, 0x22, 0x36, 0x5c, 0x90, 0x77, 0xc8, 0x94, 0xf3, 0x4b, 0xe6, 0x65,
	0x71, 0x55, 0xc0, 0x89, 0x25, 0x93, 0xdf, 0xa2, 0xc1, 0xaa, 0x35, 0x8a, 0x63, 0xbe, 0x98, 0x69,
	0x10, 0x8c, 0xa8, 0x27, 0x77, 0x8c, 0x2a, 0x77, 0x73, 0xaa, 0x6a, 0x0b, 0x8d, 0x58, 0x34, 0x2f,
	0x99, 0xc2, 0x8b, 0xf3, 0x4f, 0x61, 0x4e, 0x24, 0x1d, 0x3b, 0xa6, 0x4d, 0x5d, 0x6f, 0x72, 0x7c,
	0xb2, 0xcf, 0x45, 0x24, 0x1d, 0x3b, 0x5d, 0x0e, 0x36, 0x73, 0xc7, 0xab, 0x76, 0xcd, 0xd2, 0x2b,
	0x77, 0x4d, 0xf3, 0x6b, 0x15, 0x56, 0xf7, 0x9e, 0x7b, 0x66, 0xf0, 0xba, 0x23, 0x1f, 0xc8, 0xc7,
	0x5f, 0x01, 0xf3, 0x96, 0xfc, 0xf9, 0xfd, 0x4f, 0x6e, 0xc3, 0x8a, 0xe4, 0x95, 0x7a, 0xd6, 0xc8,
	0xa3, 0x82, 0x84, 0xc2, 0x6b, 0x10, 0x2b, 0xaa, 0xb2, 0x93, 0x3b, 0xbf, 0x30, 0xe1, 0xd5, 0x79,
	0x27, 0xfc, 0xe7, 0x50, 0xcf, 0xb6, 0xdb, 0xb1, 0x57, 0x59, 0x22, 0x4a, 0x3f, 0x4f, 0xf2, 0x17,
	0x53, 0xc4, 0xe7, 0x39, 0x4e, 0xc8, 0x45, 0x58, 0xa2, 0x16, 0x73, 0xc7, 0x28, 0x1a, 0x60, 0xd9,
	0x48, 0x4f, 0xcd, 0x27, 0x0a, 0x94, 0x75, 0xc4, 0xde, 0x11, 0xfa, 0x91, 0xc8, 0xae, 0x0e, 0x67,
	0xa9, 0x7c, 0xd0, 0x89, 0x02, 0x94, 0x8d, 0xec, 0x48, 0x74, 0xa8, 0xa2, 0x30, 0x43, 0x5b, 0x8c,
	0xab, 0xa4, 0x5e, 0xd8, 0x50, 0x4f, 0x32, 0xaf, 0x2a, 0x99, 0x1b, 0x3f, 0x25, 0xe4, 0x7d, 0x58,
	0xc2, 0xa3, 0xc8, 0x8d, 0x27, 0x27, 0x64, 0x4e, 0x11, 0xcc, 0xa5, 0x3e, 0x3c, 0x91, 0x18, 0x69,
	0x92, 0x7e, 0x1d, 0x45, 0x23, 0x3d, 0xbd, 0x32, 0xc1, 0x9f, 0x14, 0x28, 0xf1, 0x2e, 0xb3, 0x86,
	0x68, 0x8f, 0x3c, 0x24, 0x1f, 0x42, 0x15, 0x07, 0x03, 0x14, 0x4a, 0xd3, 0xce, 0x5e, 0x7d, 0x27,
	0xad, 0x5f, 0x65, 0xea, 0xdb, 0xe5, 0x5d, 0xfb, 0x01, 0x00, 0x1f, 0xde, 0x96, 0x78, 0x8d, 0xa7,
	0x5d, 0xb5, 0xf9, 0x0f, 0x74, 0xc8, 0x67, 0xbb, 0x51, 0x1c, 0x4c, 0x5f, 0xf0, 0x79, 0xd8, 0xea,
	0x6c, 0xd8, 0x64, 0x03, 0x4a, 0x36, 0x26, 0x56, 0xec, 0x46, 0xd3, 0x49, 0x50, 0x34, 0x66, 0x45,
	0x97, 0x3a, 0x70, 0x36, 0x25, 0x98, 0xfc, 0x0f, 0x56, 0xf5, 0x5e, 0xcf, 0x3c, 0xb8, 0xbb, 0xd7,
	0x33, 0x77, 0xdb, 0xb7, 0xda, 0xd7, 0x7b, 0xbb, 0xbd, 0x5b, 0x07, 0x2b, 0x0b, 0xa4, 0x0e, 0xb5,
	0xa9, 0x62, 0xaf, 0x67, 0xe8, 0xb7, 0x8d, 0xdd, 0xf6, 0xad, 0x9d, 0xde, 0x8a, 0xb2, 0xb6, 0xf8,
	0xd5, 0xb7, 0x8d, 0x85, 0xce, 0xb5, 0x87, 0x4f, 0x1b, 0xca, 0xa3, 0xa7, 0x0d, 0xe5, 0xb7, 0xa7,
	0x0d, 0xe5, 0xfe, 0xb3, 0xc6, 0xc2, 0xa3, 0x67, 0x8d, 0x85, 0x9f, 0x9f, 0x35, 0x16, 0x3e, 0x7d,
	0x2b, 0x0d, 0x5f, 0xe6, 0x72, 0x34, 0xf9, 0xb2, 0x35, 0xbe, 0xda, 0x12, 0x55, 0xcf, 0xff, 0x29,
	0xea, 0x2f, 0x09, 0xae, 0xae, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xc2, 0xb7, 0x32, 0x5a, 0x35,
	0x0d, 0x00, 0x00,
}

func (m *FeeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.HighWaterMark.Size()
		i -= size
		if _, err := m.HighWaterMark.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.FeesEnabled {
		i--
		if m.FeesEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.FeeRecipient) > 0 {
		i -= len(m.FeeRecipient)
		copy(dAtA[i:], m.FeeRecipient)
		i = encodeVarintFees(dAtA, i, uint64(len(m.FeeRecipient)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PerformanceFeeRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.PerformanceFeeRate))
		i--
		dAtA[i] = 0x10
	}
	if m.ManagementFeeRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.ManagementFeeRate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *YieldDeductionParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *YieldDeductionParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *YieldDeductionParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastCollection, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastCollection):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintFees(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x2a
	if m.CollectionFrequency != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.CollectionFrequency))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.MaxFeeAmount.Size()
		i -= size
		if _, err := m.MaxFeeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MinFeeAmount.Size()
		i -= size
		if _, err := m.MinFeeAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.YieldFeeRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.YieldFeeRate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeAccrual) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeAccrual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeAccrual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Collected {
		i--
		if m.Collected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.PeriodEnd, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.PeriodEnd):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintFees(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x2a
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.PeriodStart, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.PeriodStart):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintFees(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x22
	{
		size := m.YieldToDeduct.Size()
		i -= size
		if _, err := m.YieldToDeduct.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.AccruedAmount.Size()
		i -= size
		if _, err := m.AccruedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.FeeType != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.FeeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Breakdown) > 0 {
		for iNdEx := len(m.Breakdown) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Breakdown[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFees(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size := m.YieldDeducted.Size()
		i -= size
		if _, err := m.YieldDeducted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalAmount.Size()
		i -= size
		if _, err := m.TotalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintFees(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeeTypeBreakdown) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeTypeBreakdown) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeTypeBreakdown) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RateApplied != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.RateApplied))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.YieldDeducted.Size()
		i -= size
		if _, err := m.YieldDeducted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.FeeType != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.FeeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CollectionFrequency != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.CollectionFrequency))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.AvgDailyCollection.Size()
		i -= size
		if _, err := m.AvgDailyCollection.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastCollection, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastCollection):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintFees(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x22
	if m.CurrentAnnualRate != 0 {
		i = encodeVarintFees(dAtA, i, uint64(m.CurrentAnnualRate))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalYieldCollected.Size()
		i -= size
		if _, err := m.TotalYieldCollected.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalFeesCollected.Size()
		i -= size
		if _, err := m.TotalFeesCollected.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PerformanceFeeState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerformanceFeeState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerformanceFeeState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.AccruedPerformanceFees.Size()
		i -= size
		if _, err := m.AccruedPerformanceFees.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.PeriodStart, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.PeriodStart):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintFees(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x1a
	n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastCalculation, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastCalculation):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintFees(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x12
	{
		size := m.HighWaterMark.Size()
		i -= size
		if _, err := m.HighWaterMark.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFees(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FeeExemption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeExemption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeExemption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintFees(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if m.Expiry != nil {
		n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expiry, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expiry):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintFees(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExemptedTypes) > 0 {
		dAtA10 := make([]byte, len(m.ExemptedTypes)*10)
		var j9 int
		for _, num := range m.ExemptedTypes {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintFees(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFees(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeeSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFees(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.FeeConfig != nil {
		{
			size, err := m.FeeConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFees(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	n12, err12 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.EffectiveDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.EffectiveDate):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintFees(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintFees(dAtA []byte, offset int, v uint64) int {
	offset -= sovFees(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FeeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManagementFeeRate != 0 {
		n += 1 + sovFees(uint64(m.ManagementFeeRate))
	}
	if m.PerformanceFeeRate != 0 {
		n += 1 + sovFees(uint64(m.PerformanceFeeRate))
	}
	l = len(m.FeeRecipient)
	if l > 0 {
		n += 1 + l + sovFees(uint64(l))
	}
	if m.FeesEnabled {
		n += 2
	}
	l = m.HighWaterMark.Size()
	n += 1 + l + sovFees(uint64(l))
	return n
}

func (m *YieldDeductionParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.YieldFeeRate != 0 {
		n += 1 + sovFees(uint64(m.YieldFeeRate))
	}
	l = m.MinFeeAmount.Size()
	n += 1 + l + sovFees(uint64(l))
	l = m.MaxFeeAmount.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.CollectionFrequency != 0 {
		n += 1 + sovFees(uint64(m.CollectionFrequency))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastCollection)
	n += 1 + l + sovFees(uint64(l))
	return n
}

func (m *FeeAccrual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FeeType != 0 {
		n += 1 + sovFees(uint64(m.FeeType))
	}
	l = m.AccruedAmount.Size()
	n += 1 + l + sovFees(uint64(l))
	l = m.YieldToDeduct.Size()
	n += 1 + l + sovFees(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.PeriodStart)
	n += 1 + l + sovFees(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.PeriodEnd)
	n += 1 + l + sovFees(uint64(l))
	if m.Collected {
		n += 2
	}
	return n
}

func (m *FeeCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovFees(uint64(l))
	l = m.TotalAmount.Size()
	n += 1 + l + sovFees(uint64(l))
	l = m.YieldDeducted.Size()
	n += 1 + l + sovFees(uint64(l))
	if len(m.Breakdown) > 0 {
		for _, e := range m.Breakdown {
			l = e.Size()
			n += 1 + l + sovFees(uint64(l))
		}
	}
	if m.BlockHeight != 0 {
		n += 1 + sovFees(uint64(m.BlockHeight))
	}
	return n
}

func (m *FeeTypeBreakdown) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FeeType != 0 {
		n += 1 + sovFees(uint64(m.FeeType))
	}
	l = m.Amount.Size()
	n += 1 + l + sovFees(uint64(l))
	l = m.YieldDeducted.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.RateApplied != 0 {
		n += 1 + sovFees(uint64(m.RateApplied))
	}
	return n
}

func (m *FeeStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalFeesCollected.Size()
	n += 1 + l + sovFees(uint64(l))
	l = m.TotalYieldCollected.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.CurrentAnnualRate != 0 {
		n += 1 + sovFees(uint64(m.CurrentAnnualRate))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastCollection)
	n += 1 + l + sovFees(uint64(l))
	l = m.AvgDailyCollection.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.CollectionFrequency != 0 {
		n += 1 + sovFees(uint64(m.CollectionFrequency))
	}
	return n
}

func (m *PerformanceFeeState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.HighWaterMark.Size()
	n += 1 + l + sovFees(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastCalculation)
	n += 1 + l + sovFees(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.PeriodStart)
	n += 1 + l + sovFees(uint64(l))
	l = m.AccruedPerformanceFees.Size()
	n += 1 + l + sovFees(uint64(l))
	if m.Active {
		n += 2
	}
	return n
}

func (m *FeeExemption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFees(uint64(l))
	}
	if len(m.ExemptedTypes) > 0 {
		l = 0
		for _, e := range m.ExemptedTypes {
			l += sovFees(uint64(e))
		}
		n += 1 + sovFees(uint64(l)) + l
	}
	if m.Expiry != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expiry)
		n += 1 + l + sovFees(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovFees(uint64(l))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *FeeSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.EffectiveDate)
	n += 1 + l + sovFees(uint64(l))
	if m.FeeConfig != nil {
		l = m.FeeConfig.Size()
		n += 1 + l + sovFees(uint64(l))
	}
	if m.Active {
		n += 2
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFees(uint64(l))
	}
	return n
}

func sovFees(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFees(x uint64) (n int) {
	return sovFees(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FeeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagementFeeRate", wireType)
			}
			m.ManagementFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ManagementFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerformanceFeeRate", wireType)
			}
			m.PerformanceFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerformanceFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FeesEnabled = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWaterMark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HighWaterMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *YieldDeductionParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: YieldDeductionParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: YieldDeductionParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldFeeRate", wireType)
			}
			m.YieldFeeRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.YieldFeeRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinFeeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinFeeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFeeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxFeeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionFrequency", wireType)
			}
			m.CollectionFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionFrequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastCollection, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeAccrual) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeAccrual: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeAccrual: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeType", wireType)
			}
			m.FeeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeType |= FeeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccruedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccruedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldToDeduct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YieldToDeduct.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.PeriodStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.PeriodEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Collected = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldDeducted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YieldDeducted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Breakdown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Breakdown = append(m.Breakdown, &FeeTypeBreakdown{})
			if err := m.Breakdown[len(m.Breakdown)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeTypeBreakdown) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeTypeBreakdown: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeTypeBreakdown: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeType", wireType)
			}
			m.FeeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeeType |= FeeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldDeducted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YieldDeducted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateApplied", wireType)
			}
			m.RateApplied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateApplied |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFeesCollected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFeesCollected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalYieldCollected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalYieldCollected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentAnnualRate", wireType)
			}
			m.CurrentAnnualRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentAnnualRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastCollection, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgDailyCollection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvgDailyCollection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionFrequency", wireType)
			}
			m.CollectionFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionFrequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerformanceFeeState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerformanceFeeState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerformanceFeeState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWaterMark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HighWaterMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCalculation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastCalculation, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.PeriodStart, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccruedPerformanceFees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AccruedPerformanceFees.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeExemption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeExemption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeExemption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v FeeType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFees
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FeeType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExemptedTypes = append(m.ExemptedTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFees
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFees
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFees
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.ExemptedTypes) == 0 {
					m.ExemptedTypes = make([]FeeType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FeeType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFees
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FeeType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExemptedTypes = append(m.ExemptedTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExemptedTypes", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiry == nil {
				m.Expiry = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expiry, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFees
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.EffectiveDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeConfig == nil {
				m.FeeConfig = &FeeConfig{}
			}
			if err := m.FeeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFees
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFees
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFees
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFees(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFees
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFees(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFees
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFees
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFees
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFees
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFees
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFees
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFees        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFees          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFees = fmt.Errorf("proto: unexpected end of group")
)
