// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/tx.proto

package v2

import (
	context "context"
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgDeposit allows users to deposit into a V2 vault
// Each deposit creates a new independent position with its own yield tracking
type MsgDeposit struct {
	// User making the deposit
	Depositor string `protobuf:"bytes,1,opt,name=depositor,proto3" json:"depositor,omitempty"`
	// Amount to deposit
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Whether user wants to receive yield for this position
	ReceiveYield bool `protobuf:"varint,3,opt,name=receive_yield,json=receiveYield,proto3" json:"receive_yield,omitempty"`
}

func (m *MsgDeposit) Reset()         { *m = MsgDeposit{} }
func (m *MsgDeposit) String() string { return proto.CompactTextString(m) }
func (*MsgDeposit) ProtoMessage()    {}
func (*MsgDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{0}
}
func (m *MsgDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeposit.Merge(m, src)
}
func (m *MsgDeposit) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeposit proto.InternalMessageInfo

// MsgDepositResponse returns the results of a deposit
type MsgDepositResponse struct {
	// Amount deposited
	AmountDeposited cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_deposited,json=amountDeposited,proto3,customtype=cosmossdk.io/math.Int" json:"amount_deposited"`
	// Position ID for the newly created position
	PositionId uint64 `protobuf:"varint,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *MsgDepositResponse) Reset()         { *m = MsgDepositResponse{} }
func (m *MsgDepositResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositResponse) ProtoMessage()    {}
func (*MsgDepositResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{1}
}
func (m *MsgDepositResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositResponse.Merge(m, src)
}
func (m *MsgDepositResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositResponse proto.InternalMessageInfo

func (m *MsgDepositResponse) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

// MsgSetYieldPreference allows users to set their yield preference for a specific position
type MsgSetYieldPreference struct {
	// User setting the preference
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// Whether to receive yield
	ReceiveYield bool `protobuf:"varint,2,opt,name=receive_yield,json=receiveYield,proto3" json:"receive_yield,omitempty"`
	// Position ID to update preference for
	PositionId uint64 `protobuf:"varint,3,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *MsgSetYieldPreference) Reset()         { *m = MsgSetYieldPreference{} }
func (m *MsgSetYieldPreference) String() string { return proto.CompactTextString(m) }
func (*MsgSetYieldPreference) ProtoMessage()    {}
func (*MsgSetYieldPreference) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{2}
}
func (m *MsgSetYieldPreference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetYieldPreference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetYieldPreference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetYieldPreference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetYieldPreference.Merge(m, src)
}
func (m *MsgSetYieldPreference) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetYieldPreference) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetYieldPreference.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetYieldPreference proto.InternalMessageInfo

// MsgSetYieldPreferenceResponse confirms yield preference update
type MsgSetYieldPreferenceResponse struct {
	// Previous yield preference
	PreviousPreference bool `protobuf:"varint,1,opt,name=previous_preference,json=previousPreference,proto3" json:"previous_preference,omitempty"`
	// New yield preference
	NewPreference bool `protobuf:"varint,2,opt,name=new_preference,json=newPreference,proto3" json:"new_preference,omitempty"`
	// Position ID that was updated
	PositionId uint64 `protobuf:"varint,3,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *MsgSetYieldPreferenceResponse) Reset()         { *m = MsgSetYieldPreferenceResponse{} }
func (m *MsgSetYieldPreferenceResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetYieldPreferenceResponse) ProtoMessage()    {}
func (*MsgSetYieldPreferenceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{3}
}
func (m *MsgSetYieldPreferenceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetYieldPreferenceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetYieldPreferenceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetYieldPreferenceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetYieldPreferenceResponse.Merge(m, src)
}
func (m *MsgSetYieldPreferenceResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetYieldPreferenceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetYieldPreferenceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetYieldPreferenceResponse proto.InternalMessageInfo

func (m *MsgSetYieldPreferenceResponse) GetPreviousPreference() bool {
	if m != nil {
		return m.PreviousPreference
	}
	return false
}

func (m *MsgSetYieldPreferenceResponse) GetNewPreference() bool {
	if m != nil {
		return m.NewPreference
	}
	return false
}

func (m *MsgSetYieldPreferenceResponse) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

// MsgUpdateVaultConfig allows authority to update vault configuration
type MsgUpdateVaultConfig struct {
	// Authority updating the config
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// New vault configuration
	Config VaultConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config"`
	// Reason for config update
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgUpdateVaultConfig) Reset()         { *m = MsgUpdateVaultConfig{} }
func (m *MsgUpdateVaultConfig) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateVaultConfig) ProtoMessage()    {}
func (*MsgUpdateVaultConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{4}
}
func (m *MsgUpdateVaultConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateVaultConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateVaultConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateVaultConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateVaultConfig.Merge(m, src)
}
func (m *MsgUpdateVaultConfig) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateVaultConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateVaultConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateVaultConfig proto.InternalMessageInfo

// MsgUpdateVaultConfigResponse confirms config update
type MsgUpdateVaultConfigResponse struct {
	// Previous configuration (JSON)
	PreviousConfig string `protobuf:"bytes,1,opt,name=previous_config,json=previousConfig,proto3" json:"previous_config,omitempty"`
	// New configuration (JSON)
	NewConfig string `protobuf:"bytes,2,opt,name=new_config,json=newConfig,proto3" json:"new_config,omitempty"`
}

func (m *MsgUpdateVaultConfigResponse) Reset()         { *m = MsgUpdateVaultConfigResponse{} }
func (m *MsgUpdateVaultConfigResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateVaultConfigResponse) ProtoMessage()    {}
func (*MsgUpdateVaultConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{5}
}
func (m *MsgUpdateVaultConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateVaultConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateVaultConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateVaultConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateVaultConfigResponse.Merge(m, src)
}
func (m *MsgUpdateVaultConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateVaultConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateVaultConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateVaultConfigResponse proto.InternalMessageInfo

func (m *MsgUpdateVaultConfigResponse) GetPreviousConfig() string {
	if m != nil {
		return m.PreviousConfig
	}
	return ""
}

func (m *MsgUpdateVaultConfigResponse) GetNewConfig() string {
	if m != nil {
		return m.NewConfig
	}
	return ""
}

// MsgUpdateParams allows authority to update module parameters
type MsgUpdateParams struct {
	// Authority updating the parameters
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// New parameters
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{6}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

// MsgUpdateParamsResponse confirms parameter update
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{7}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgCreateCrossChainRoute creates a new cross-chain route
type MsgCreateCrossChainRoute struct {
	// Authority creating the route
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Route configuration
	Route CrossChainRoute `protobuf:"bytes,2,opt,name=route,proto3" json:"route"`
}

func (m *MsgCreateCrossChainRoute) Reset()         { *m = MsgCreateCrossChainRoute{} }
func (m *MsgCreateCrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCrossChainRoute) ProtoMessage()    {}
func (*MsgCreateCrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{8}
}
func (m *MsgCreateCrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCrossChainRoute.Merge(m, src)
}
func (m *MsgCreateCrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCrossChainRoute proto.InternalMessageInfo

// MsgCreateCrossChainRouteResponse confirms route creation
type MsgCreateCrossChainRouteResponse struct {
	// Created route ID
	RouteId uint32 `protobuf:"varint,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
}

func (m *MsgCreateCrossChainRouteResponse) Reset()         { *m = MsgCreateCrossChainRouteResponse{} }
func (m *MsgCreateCrossChainRouteResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCrossChainRouteResponse) ProtoMessage()    {}
func (*MsgCreateCrossChainRouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{9}
}
func (m *MsgCreateCrossChainRouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCrossChainRouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCrossChainRouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCrossChainRouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCrossChainRouteResponse.Merge(m, src)
}
func (m *MsgCreateCrossChainRouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCrossChainRouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCrossChainRouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCrossChainRouteResponse proto.InternalMessageInfo

func (m *MsgCreateCrossChainRouteResponse) GetRouteId() uint32 {
	if m != nil {
		return m.RouteId
	}
	return 0
}

// MsgUpdateCrossChainRoute updates an existing cross-chain route
type MsgUpdateCrossChainRoute struct {
	// Authority updating the route
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Route ID to update
	RouteId uint32 `protobuf:"varint,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Updated route configuration
	Route CrossChainRoute `protobuf:"bytes,3,opt,name=route,proto3" json:"route"`
}

func (m *MsgUpdateCrossChainRoute) Reset()         { *m = MsgUpdateCrossChainRoute{} }
func (m *MsgUpdateCrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCrossChainRoute) ProtoMessage()    {}
func (*MsgUpdateCrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{10}
}
func (m *MsgUpdateCrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCrossChainRoute.Merge(m, src)
}
func (m *MsgUpdateCrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCrossChainRoute proto.InternalMessageInfo

// MsgUpdateCrossChainRouteResponse confirms route update
type MsgUpdateCrossChainRouteResponse struct {
	// Updated route ID
	RouteId uint32 `protobuf:"varint,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Previous configuration
	PreviousConfig string `protobuf:"bytes,2,opt,name=previous_config,json=previousConfig,proto3" json:"previous_config,omitempty"`
	// New configuration
	NewConfig string `protobuf:"bytes,3,opt,name=new_config,json=newConfig,proto3" json:"new_config,omitempty"`
}

func (m *MsgUpdateCrossChainRouteResponse) Reset()         { *m = MsgUpdateCrossChainRouteResponse{} }
func (m *MsgUpdateCrossChainRouteResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCrossChainRouteResponse) ProtoMessage()    {}
func (*MsgUpdateCrossChainRouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{11}
}
func (m *MsgUpdateCrossChainRouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCrossChainRouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCrossChainRouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCrossChainRouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCrossChainRouteResponse.Merge(m, src)
}
func (m *MsgUpdateCrossChainRouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCrossChainRouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCrossChainRouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCrossChainRouteResponse proto.InternalMessageInfo

func (m *MsgUpdateCrossChainRouteResponse) GetRouteId() uint32 {
	if m != nil {
		return m.RouteId
	}
	return 0
}

func (m *MsgUpdateCrossChainRouteResponse) GetPreviousConfig() string {
	if m != nil {
		return m.PreviousConfig
	}
	return ""
}

func (m *MsgUpdateCrossChainRouteResponse) GetNewConfig() string {
	if m != nil {
		return m.NewConfig
	}
	return ""
}

// MsgDisableCrossChainRoute disables a cross-chain route
type MsgDisableCrossChainRoute struct {
	// Authority disabling the route
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Route ID to disable
	RouteId uint32 `protobuf:"varint,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Reason for disabling
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgDisableCrossChainRoute) Reset()         { *m = MsgDisableCrossChainRoute{} }
func (m *MsgDisableCrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*MsgDisableCrossChainRoute) ProtoMessage()    {}
func (*MsgDisableCrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{12}
}
func (m *MsgDisableCrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableCrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableCrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableCrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableCrossChainRoute.Merge(m, src)
}
func (m *MsgDisableCrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableCrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableCrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableCrossChainRoute proto.InternalMessageInfo

// MsgDisableCrossChainRouteResponse confirms route disabling
type MsgDisableCrossChainRouteResponse struct {
	// Disabled route ID
	RouteId uint32 `protobuf:"varint,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Number of affected positions
	AffectedPositions int64 `protobuf:"varint,2,opt,name=affected_positions,json=affectedPositions,proto3" json:"affected_positions,omitempty"`
}

func (m *MsgDisableCrossChainRouteResponse) Reset()         { *m = MsgDisableCrossChainRouteResponse{} }
func (m *MsgDisableCrossChainRouteResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDisableCrossChainRouteResponse) ProtoMessage()    {}
func (*MsgDisableCrossChainRouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{13}
}
func (m *MsgDisableCrossChainRouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisableCrossChainRouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisableCrossChainRouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisableCrossChainRouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisableCrossChainRouteResponse.Merge(m, src)
}
func (m *MsgDisableCrossChainRouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisableCrossChainRouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisableCrossChainRouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisableCrossChainRouteResponse proto.InternalMessageInfo

func (m *MsgDisableCrossChainRouteResponse) GetRouteId() uint32 {
	if m != nil {
		return m.RouteId
	}
	return 0
}

func (m *MsgDisableCrossChainRouteResponse) GetAffectedPositions() int64 {
	if m != nil {
		return m.AffectedPositions
	}
	return 0
}

// MsgProcessInFlightPosition processes an in-flight position
type MsgProcessInFlightPosition struct {
	// Authority processing the position
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Operation nonce
	Nonce uint64 `protobuf:"varint,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Operation result
	ResultStatus InflightStatus `protobuf:"varint,3,opt,name=result_status,json=resultStatus,proto3,enum=noble.dollar.vaults.v2.InflightStatus" json:"result_status,omitempty"`
	// Result amount (for successful operations)
	ResultAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=result_amount,json=resultAmount,proto3,customtype=cosmossdk.io/math.Int" json:"result_amount"`
	// Error message (for failed operations)
	ErrorMessage string `protobuf:"bytes,5,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Provider-specific tracking information
	ProviderTracking *ProviderTrackingInfo `protobuf:"bytes,6,opt,name=provider_tracking,json=providerTracking,proto3" json:"provider_tracking,omitempty"`
}

func (m *MsgProcessInFlightPosition) Reset()         { *m = MsgProcessInFlightPosition{} }
func (m *MsgProcessInFlightPosition) String() string { return proto.CompactTextString(m) }
func (*MsgProcessInFlightPosition) ProtoMessage()    {}
func (*MsgProcessInFlightPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{14}
}
func (m *MsgProcessInFlightPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessInFlightPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessInFlightPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessInFlightPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessInFlightPosition.Merge(m, src)
}
func (m *MsgProcessInFlightPosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessInFlightPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessInFlightPosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessInFlightPosition proto.InternalMessageInfo

// MsgProcessInFlightPositionResponse confirms processing
type MsgProcessInFlightPositionResponse struct {
	// Operation nonce
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Final status
	FinalStatus InflightStatus `protobuf:"varint,2,opt,name=final_status,json=finalStatus,proto3,enum=noble.dollar.vaults.v2.InflightStatus" json:"final_status,omitempty"`
	// Amount processed
	AmountProcessed cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount_processed,json=amountProcessed,proto3,customtype=cosmossdk.io/math.Int" json:"amount_processed"`
	// Shares affected
	SharesAffected cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=shares_affected,json=sharesAffected,proto3,customtype=cosmossdk.io/math.Int" json:"shares_affected"`
}

func (m *MsgProcessInFlightPositionResponse) Reset()         { *m = MsgProcessInFlightPositionResponse{} }
func (m *MsgProcessInFlightPositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProcessInFlightPositionResponse) ProtoMessage()    {}
func (*MsgProcessInFlightPositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{15}
}
func (m *MsgProcessInFlightPositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessInFlightPositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessInFlightPositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessInFlightPositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessInFlightPositionResponse.Merge(m, src)
}
func (m *MsgProcessInFlightPositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessInFlightPositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessInFlightPositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessInFlightPositionResponse proto.InternalMessageInfo

func (m *MsgProcessInFlightPositionResponse) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *MsgProcessInFlightPositionResponse) GetFinalStatus() InflightStatus {
	if m != nil {
		return m.FinalStatus
	}
	return INFLIGHT_PENDING
}

// MsgRequestWithdrawal allows users to enter the withdrawal queue
type MsgRequestWithdrawal struct {
	// User requesting withdrawal
	Requester string `protobuf:"bytes,1,opt,name=requester,proto3" json:"requester,omitempty"`
	// Amount to withdraw (locked immediately)
	Amount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Position ID to withdraw from
	PositionId uint64 `protobuf:"varint,3,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *MsgRequestWithdrawal) Reset()         { *m = MsgRequestWithdrawal{} }
func (m *MsgRequestWithdrawal) String() string { return proto.CompactTextString(m) }
func (*MsgRequestWithdrawal) ProtoMessage()    {}
func (*MsgRequestWithdrawal) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{16}
}
func (m *MsgRequestWithdrawal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestWithdrawal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestWithdrawal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestWithdrawal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestWithdrawal.Merge(m, src)
}
func (m *MsgRequestWithdrawal) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestWithdrawal) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestWithdrawal.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestWithdrawal proto.InternalMessageInfo

// MsgRequestWithdrawalResponse returns the created request details
type MsgRequestWithdrawalResponse struct {
	// Withdrawal request ID
	RequestId uint64 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Amount locked for withdrawal
	AmountLocked cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount_locked,json=amountLocked,proto3,customtype=cosmossdk.io/math.Int" json:"amount_locked"`
	// Yield portion of withdrawal
	YieldPortion cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=yield_portion,json=yieldPortion,proto3,customtype=cosmossdk.io/math.Int" json:"yield_portion"`
	// Estimated time the request becomes claimable
	ExpectedClaimableAt time.Time `protobuf:"bytes,4,opt,name=expected_claimable_at,json=expectedClaimableAt,proto3,stdtime" json:"expected_claimable_at"`
}

func (m *MsgRequestWithdrawalResponse) Reset()         { *m = MsgRequestWithdrawalResponse{} }
func (m *MsgRequestWithdrawalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRequestWithdrawalResponse) ProtoMessage()    {}
func (*MsgRequestWithdrawalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{17}
}
func (m *MsgRequestWithdrawalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestWithdrawalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestWithdrawalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestWithdrawalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestWithdrawalResponse.Merge(m, src)
}
func (m *MsgRequestWithdrawalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestWithdrawalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestWithdrawalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestWithdrawalResponse proto.InternalMessageInfo

func (m *MsgRequestWithdrawalResponse) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *MsgRequestWithdrawalResponse) GetExpectedClaimableAt() time.Time {
	if m != nil {
		return m.ExpectedClaimableAt
	}
	return time.Time{}
}

// MsgProcessWithdrawalQueue allows authority to process withdrawal queue
type MsgProcessWithdrawalQueue struct {
	// Authority processing the queue
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Maximum number of requests to process
	MaxRequests int32 `protobuf:"varint,2,opt,name=max_requests,json=maxRequests,proto3" json:"max_requests,omitempty"`
}

func (m *MsgProcessWithdrawalQueue) Reset()         { *m = MsgProcessWithdrawalQueue{} }
func (m *MsgProcessWithdrawalQueue) String() string { return proto.CompactTextString(m) }
func (*MsgProcessWithdrawalQueue) ProtoMessage()    {}
func (*MsgProcessWithdrawalQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{18}
}
func (m *MsgProcessWithdrawalQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessWithdrawalQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessWithdrawalQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessWithdrawalQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessWithdrawalQueue.Merge(m, src)
}
func (m *MsgProcessWithdrawalQueue) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessWithdrawalQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessWithdrawalQueue.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessWithdrawalQueue proto.InternalMessageInfo

// MsgProcessWithdrawalQueueResponse returns processing results
type MsgProcessWithdrawalQueueResponse struct {
	// Number of requests processed
	RequestsProcessed int32 `protobuf:"varint,1,opt,name=requests_processed,json=requestsProcessed,proto3" json:"requests_processed,omitempty"`
	// Total amount processed
	TotalAmountProcessed cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_amount_processed,json=totalAmountProcessed,proto3,customtype=cosmossdk.io/math.Int" json:"total_amount_processed"`
	// Total amount distributed
	TotalAmountDistributed cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=total_amount_distributed,json=totalAmountDistributed,proto3,customtype=cosmossdk.io/math.Int" json:"total_amount_distributed"`
	// Remaining requests in queue
	RemainingRequests int32 `protobuf:"varint,4,opt,name=remaining_requests,json=remainingRequests,proto3" json:"remaining_requests,omitempty"`
}

func (m *MsgProcessWithdrawalQueueResponse) Reset()         { *m = MsgProcessWithdrawalQueueResponse{} }
func (m *MsgProcessWithdrawalQueueResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProcessWithdrawalQueueResponse) ProtoMessage()    {}
func (*MsgProcessWithdrawalQueueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{19}
}
func (m *MsgProcessWithdrawalQueueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessWithdrawalQueueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessWithdrawalQueueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessWithdrawalQueueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessWithdrawalQueueResponse.Merge(m, src)
}
func (m *MsgProcessWithdrawalQueueResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessWithdrawalQueueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessWithdrawalQueueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessWithdrawalQueueResponse proto.InternalMessageInfo

func (m *MsgProcessWithdrawalQueueResponse) GetRequestsProcessed() int32 {
	if m != nil {
		return m.RequestsProcessed
	}
	return 0
}

func (m *MsgProcessWithdrawalQueueResponse) GetRemainingRequests() int32 {
	if m != nil {
		return m.RemainingRequests
	}
	return 0
}

// MsgCreateRemotePosition deploys capital to a remote ERC-4626 position
type MsgCreateRemotePosition struct {
	// Authorized manager address
	Manager string `protobuf:"bytes,1,opt,name=manager,proto3" json:"manager,omitempty"`
	// Target ERC-4626 vault address
	VaultAddress string `protobuf:"bytes,2,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// Hyperlane domain ID for destination chain
	ChainId uint32 `protobuf:"varint,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Amount of $USDN to deploy
	Amount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Minimum acceptable Noble vault shares to receive (slippage protection)
	MinSharesOut cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=min_shares_out,json=minSharesOut,proto3,customtype=cosmossdk.io/math.Int" json:"min_shares_out"`
}

func (m *MsgCreateRemotePosition) Reset()         { *m = MsgCreateRemotePosition{} }
func (m *MsgCreateRemotePosition) String() string { return proto.CompactTextString(m) }
func (*MsgCreateRemotePosition) ProtoMessage()    {}
func (*MsgCreateRemotePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{20}
}
func (m *MsgCreateRemotePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateRemotePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateRemotePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateRemotePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateRemotePosition.Merge(m, src)
}
func (m *MsgCreateRemotePosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateRemotePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateRemotePosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateRemotePosition proto.InternalMessageInfo

type MsgCreateRemotePositionResponse struct {
	// Assigned position ID
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Route ID used for cross-chain transfer
	RouteId uint32 `protobuf:"varint,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Expected completion time on remote chain
	ExpectedCompletion time.Time `protobuf:"bytes,3,opt,name=expected_completion,json=expectedCompletion,proto3,stdtime" json:"expected_completion"`
}

func (m *MsgCreateRemotePositionResponse) Reset()         { *m = MsgCreateRemotePositionResponse{} }
func (m *MsgCreateRemotePositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateRemotePositionResponse) ProtoMessage()    {}
func (*MsgCreateRemotePositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{21}
}
func (m *MsgCreateRemotePositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateRemotePositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateRemotePositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateRemotePositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateRemotePositionResponse.Merge(m, src)
}
func (m *MsgCreateRemotePositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateRemotePositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateRemotePositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateRemotePositionResponse proto.InternalMessageInfo

func (m *MsgCreateRemotePositionResponse) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *MsgCreateRemotePositionResponse) GetRouteId() uint32 {
	if m != nil {
		return m.RouteId
	}
	return 0
}

func (m *MsgCreateRemotePositionResponse) GetExpectedCompletion() time.Time {
	if m != nil {
		return m.ExpectedCompletion
	}
	return time.Time{}
}

// MsgCloseRemotePosition withdraws capital from a remote position
type MsgCloseRemotePosition struct {
	// Authorized manager address
	Manager string `protobuf:"bytes,1,opt,name=manager,proto3" json:"manager,omitempty"`
	// Remote position ID to close
	PositionId uint64 `protobuf:"varint,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Optional partial withdrawal amount ($USDN). If omitted or zero, close fully
	PartialAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=partial_amount,json=partialAmount,proto3,customtype=cosmossdk.io/math.Int" json:"partial_amount"`
}

func (m *MsgCloseRemotePosition) Reset()         { *m = MsgCloseRemotePosition{} }
func (m *MsgCloseRemotePosition) String() string { return proto.CompactTextString(m) }
func (*MsgCloseRemotePosition) ProtoMessage()    {}
func (*MsgCloseRemotePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{22}
}
func (m *MsgCloseRemotePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCloseRemotePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCloseRemotePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCloseRemotePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCloseRemotePosition.Merge(m, src)
}
func (m *MsgCloseRemotePosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgCloseRemotePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCloseRemotePosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCloseRemotePosition proto.InternalMessageInfo

type MsgCloseRemotePositionResponse struct {
	// Remote position ID
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Whether a withdrawal was initiated
	Initiated bool `protobuf:"varint,2,opt,name=initiated,proto3" json:"initiated,omitempty"`
	// Expected completion time
	ExpectedCompletion time.Time `protobuf:"bytes,3,opt,name=expected_completion,json=expectedCompletion,proto3,stdtime" json:"expected_completion"`
}

func (m *MsgCloseRemotePositionResponse) Reset()         { *m = MsgCloseRemotePositionResponse{} }
func (m *MsgCloseRemotePositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCloseRemotePositionResponse) ProtoMessage()    {}
func (*MsgCloseRemotePositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{23}
}
func (m *MsgCloseRemotePositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCloseRemotePositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCloseRemotePositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCloseRemotePositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCloseRemotePositionResponse.Merge(m, src)
}
func (m *MsgCloseRemotePositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCloseRemotePositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCloseRemotePositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCloseRemotePositionResponse proto.InternalMessageInfo

func (m *MsgCloseRemotePositionResponse) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *MsgCloseRemotePositionResponse) GetInitiated() bool {
	if m != nil {
		return m.Initiated
	}
	return false
}

func (m *MsgCloseRemotePositionResponse) GetExpectedCompletion() time.Time {
	if m != nil {
		return m.ExpectedCompletion
	}
	return time.Time{}
}

// TargetAllocation defines allocation target for a position
type TargetAllocation struct {
	// Remote position ID
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Target percentage (0-100)
	TargetPercentage uint32 `protobuf:"varint,2,opt,name=target_percentage,json=targetPercentage,proto3" json:"target_percentage,omitempty"`
}

func (m *TargetAllocation) Reset()         { *m = TargetAllocation{} }
func (m *TargetAllocation) String() string { return proto.CompactTextString(m) }
func (*TargetAllocation) ProtoMessage()    {}
func (*TargetAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{24}
}
func (m *TargetAllocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetAllocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetAllocation.Merge(m, src)
}
func (m *TargetAllocation) XXX_Size() int {
	return m.Size()
}
func (m *TargetAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_TargetAllocation proto.InternalMessageInfo

func (m *TargetAllocation) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *TargetAllocation) GetTargetPercentage() uint32 {
	if m != nil {
		return m.TargetPercentage
	}
	return 0
}

// MsgRebalance rebalances capital across remote positions
type MsgRebalance struct {
	// Authorized manager address
	Manager string `protobuf:"bytes,1,opt,name=manager,proto3" json:"manager,omitempty"`
	// Desired allocation targets
	TargetAllocations []*TargetAllocation `protobuf:"bytes,2,rep,name=target_allocations,json=targetAllocations,proto3" json:"target_allocations,omitempty"`
}

func (m *MsgRebalance) Reset()         { *m = MsgRebalance{} }
func (m *MsgRebalance) String() string { return proto.CompactTextString(m) }
func (*MsgRebalance) ProtoMessage()    {}
func (*MsgRebalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{25}
}
func (m *MsgRebalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRebalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRebalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRebalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRebalance.Merge(m, src)
}
func (m *MsgRebalance) XXX_Size() int {
	return m.Size()
}
func (m *MsgRebalance) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRebalance.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRebalance proto.InternalMessageInfo

type MsgRebalanceResponse struct {
	// Number of operations initiated
	OperationsInitiated int32 `protobuf:"varint,1,opt,name=operations_initiated,json=operationsInitiated,proto3" json:"operations_initiated,omitempty"`
	// Informational summary
	Summary string `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
}

func (m *MsgRebalanceResponse) Reset()         { *m = MsgRebalanceResponse{} }
func (m *MsgRebalanceResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRebalanceResponse) ProtoMessage()    {}
func (*MsgRebalanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{26}
}
func (m *MsgRebalanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRebalanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRebalanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRebalanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRebalanceResponse.Merge(m, src)
}
func (m *MsgRebalanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRebalanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRebalanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRebalanceResponse proto.InternalMessageInfo

func (m *MsgRebalanceResponse) GetOperationsInitiated() int32 {
	if m != nil {
		return m.OperationsInitiated
	}
	return 0
}

func (m *MsgRebalanceResponse) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

// MsgClaimWithdrawal allows a user to claim a completed withdrawal request
type MsgClaimWithdrawal struct {
	// User claiming the withdrawal
	Claimer string `protobuf:"bytes,1,opt,name=claimer,proto3" json:"claimer,omitempty"`
	// Withdrawal request ID
	RequestId uint64 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *MsgClaimWithdrawal) Reset()         { *m = MsgClaimWithdrawal{} }
func (m *MsgClaimWithdrawal) String() string { return proto.CompactTextString(m) }
func (*MsgClaimWithdrawal) ProtoMessage()    {}
func (*MsgClaimWithdrawal) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{27}
}
func (m *MsgClaimWithdrawal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimWithdrawal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimWithdrawal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimWithdrawal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimWithdrawal.Merge(m, src)
}
func (m *MsgClaimWithdrawal) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimWithdrawal) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimWithdrawal.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimWithdrawal proto.InternalMessageInfo

// MsgClaimWithdrawalResponse returns claim results
type MsgClaimWithdrawalResponse struct {
	// Amount claimed (principal + yield - fees)
	AmountClaimed cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_claimed,json=amountClaimed,proto3,customtype=cosmossdk.io/math.Int" json:"amount_claimed"`
	// Principal portion
	PrincipalAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=principal_amount,json=principalAmount,proto3,customtype=cosmossdk.io/math.Int" json:"principal_amount"`
	// Yield portion
	YieldAmount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=yield_amount,json=yieldAmount,proto3,customtype=cosmossdk.io/math.Int" json:"yield_amount"`
	// Fees deducted
	FeesDeducted cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=fees_deducted,json=feesDeducted,proto3,customtype=cosmossdk.io/math.Int" json:"fees_deducted"`
}

func (m *MsgClaimWithdrawalResponse) Reset()         { *m = MsgClaimWithdrawalResponse{} }
func (m *MsgClaimWithdrawalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimWithdrawalResponse) ProtoMessage()    {}
func (*MsgClaimWithdrawalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{28}
}
func (m *MsgClaimWithdrawalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimWithdrawalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimWithdrawalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimWithdrawalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimWithdrawalResponse.Merge(m, src)
}
func (m *MsgClaimWithdrawalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimWithdrawalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimWithdrawalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimWithdrawalResponse proto.InternalMessageInfo

// MsgCancelWithdrawal allows a user to cancel a pending withdrawal request
type MsgCancelWithdrawal struct {
	// User canceling the withdrawal
	Requester string `protobuf:"bytes,1,opt,name=requester,proto3" json:"requester,omitempty"`
	// Withdrawal request ID to cancel
	RequestId uint64 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *MsgCancelWithdrawal) Reset()         { *m = MsgCancelWithdrawal{} }
func (m *MsgCancelWithdrawal) String() string { return proto.CompactTextString(m) }
func (*MsgCancelWithdrawal) ProtoMessage()    {}
func (*MsgCancelWithdrawal) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{29}
}
func (m *MsgCancelWithdrawal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelWithdrawal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelWithdrawal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelWithdrawal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelWithdrawal.Merge(m, src)
}
func (m *MsgCancelWithdrawal) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelWithdrawal) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelWithdrawal.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelWithdrawal proto.InternalMessageInfo

// MsgCancelWithdrawalResponse returns cancel results
type MsgCancelWithdrawalResponse struct {
	// Amount unlocked back to the position
	AmountUnlocked cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=amount_unlocked,json=amountUnlocked,proto3,customtype=cosmossdk.io/math.Int" json:"amount_unlocked"`
	// Position ID the funds were returned to
	PositionId uint64 `protobuf:"varint,2,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *MsgCancelWithdrawalResponse) Reset()         { *m = MsgCancelWithdrawalResponse{} }
func (m *MsgCancelWithdrawalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelWithdrawalResponse) ProtoMessage()    {}
func (*MsgCancelWithdrawalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{30}
}
func (m *MsgCancelWithdrawalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelWithdrawalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelWithdrawalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelWithdrawalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelWithdrawalResponse.Merge(m, src)
}
func (m *MsgCancelWithdrawalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelWithdrawalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelWithdrawalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelWithdrawalResponse proto.InternalMessageInfo

func (m *MsgCancelWithdrawalResponse) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

// MsgUpdateNAV updates the NAV values (authority controlled)
type MsgUpdateNAV struct {
	// Authority performing the update
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// New NAV value
	NewNav cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=new_nav,json=newNav,proto3,customtype=cosmossdk.io/math.Int" json:"new_nav"`
	// Previous NAV value for validation (optional)
	PreviousNav cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=previous_nav,json=previousNav,proto3,customtype=cosmossdk.io/math.Int" json:"previous_nav"`
	// NAV change basis points (server may recalc)
	ChangeBps int32 `protobuf:"varint,4,opt,name=change_bps,json=changeBps,proto3" json:"change_bps,omitempty"`
	// Circuit breaker active
	CircuitBreakerActive bool `protobuf:"varint,5,opt,name=circuit_breaker_active,json=circuitBreakerActive,proto3" json:"circuit_breaker_active,omitempty"`
}

func (m *MsgUpdateNAV) Reset()         { *m = MsgUpdateNAV{} }
func (m *MsgUpdateNAV) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNAV) ProtoMessage()    {}
func (*MsgUpdateNAV) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{31}
}
func (m *MsgUpdateNAV) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNAV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNAV.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNAV) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNAV.Merge(m, src)
}
func (m *MsgUpdateNAV) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNAV) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNAV.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNAV proto.InternalMessageInfo

// MsgUpdateNAVResponse confirms NAV update
type MsgUpdateNAVResponse struct {
	// Applied NAV value
	AppliedNav cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=applied_nav,json=appliedNav,proto3,customtype=cosmossdk.io/math.Int" json:"applied_nav"`
	// Change basis points
	ChangeBps int32 `protobuf:"varint,2,opt,name=change_bps,json=changeBps,proto3" json:"change_bps,omitempty"`
	// Timestamp of update
	Timestamp time.Time `protobuf:"bytes,3,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Circuit breaker active
	CircuitBreakerActive bool `protobuf:"varint,4,opt,name=circuit_breaker_active,json=circuitBreakerActive,proto3" json:"circuit_breaker_active,omitempty"`
}

func (m *MsgUpdateNAVResponse) Reset()         { *m = MsgUpdateNAVResponse{} }
func (m *MsgUpdateNAVResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNAVResponse) ProtoMessage()    {}
func (*MsgUpdateNAVResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{32}
}
func (m *MsgUpdateNAVResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNAVResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNAVResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNAVResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNAVResponse.Merge(m, src)
}
func (m *MsgUpdateNAVResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNAVResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNAVResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNAVResponse proto.InternalMessageInfo

func (m *MsgUpdateNAVResponse) GetChangeBps() int32 {
	if m != nil {
		return m.ChangeBps
	}
	return 0
}

func (m *MsgUpdateNAVResponse) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *MsgUpdateNAVResponse) GetCircuitBreakerActive() bool {
	if m != nil {
		return m.CircuitBreakerActive
	}
	return false
}

// MsgHandleStaleInflight marks or updates a stale inflight fund record
type MsgHandleStaleInflight struct {
	// Authority performing the action
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Inflight fund ID
	InflightId uint64 `protobuf:"varint,2,opt,name=inflight_id,json=inflightId,proto3" json:"inflight_id,omitempty"`
	// New status to apply (e.g., TIMEOUT, FAILED)
	NewStatus InflightStatus `protobuf:"varint,3,opt,name=new_status,json=newStatus,proto3,enum=noble.dollar.vaults.v2.InflightStatus" json:"new_status,omitempty"`
	// Reason / notes
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgHandleStaleInflight) Reset()         { *m = MsgHandleStaleInflight{} }
func (m *MsgHandleStaleInflight) String() string { return proto.CompactTextString(m) }
func (*MsgHandleStaleInflight) ProtoMessage()    {}
func (*MsgHandleStaleInflight) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{33}
}
func (m *MsgHandleStaleInflight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgHandleStaleInflight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgHandleStaleInflight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgHandleStaleInflight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgHandleStaleInflight.Merge(m, src)
}
func (m *MsgHandleStaleInflight) XXX_Size() int {
	return m.Size()
}
func (m *MsgHandleStaleInflight) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgHandleStaleInflight.DiscardUnknown(m)
}

var xxx_messageInfo_MsgHandleStaleInflight proto.InternalMessageInfo

// MsgHandleStaleInflightResponse returns updated status info
type MsgHandleStaleInflightResponse struct {
	// Inflight fund ID
	InflightId uint64 `protobuf:"varint,1,opt,name=inflight_id,json=inflightId,proto3" json:"inflight_id,omitempty"`
	// Final status
	FinalStatus InflightStatus `protobuf:"varint,2,opt,name=final_status,json=finalStatus,proto3,enum=noble.dollar.vaults.v2.InflightStatus" json:"final_status,omitempty"`
	// Time handled
	HandledAt time.Time `protobuf:"bytes,3,opt,name=handled_at,json=handledAt,proto3,stdtime" json:"handled_at"`
}

func (m *MsgHandleStaleInflightResponse) Reset()         { *m = MsgHandleStaleInflightResponse{} }
func (m *MsgHandleStaleInflightResponse) String() string { return proto.CompactTextString(m) }
func (*MsgHandleStaleInflightResponse) ProtoMessage()    {}
func (*MsgHandleStaleInflightResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{34}
}
func (m *MsgHandleStaleInflightResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgHandleStaleInflightResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgHandleStaleInflightResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgHandleStaleInflightResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgHandleStaleInflightResponse.Merge(m, src)
}
func (m *MsgHandleStaleInflightResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgHandleStaleInflightResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgHandleStaleInflightResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgHandleStaleInflightResponse proto.InternalMessageInfo

func (m *MsgHandleStaleInflightResponse) GetInflightId() uint64 {
	if m != nil {
		return m.InflightId
	}
	return 0
}

func (m *MsgHandleStaleInflightResponse) GetFinalStatus() InflightStatus {
	if m != nil {
		return m.FinalStatus
	}
	return INFLIGHT_PENDING
}

func (m *MsgHandleStaleInflightResponse) GetHandledAt() time.Time {
	if m != nil {
		return m.HandledAt
	}
	return time.Time{}
}

// MsgUpdateDepositLimits updates deposit limits and risk controls
type MsgUpdateDepositLimits struct {
	// Authority performing the update
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// New deposit limits configuration
	Limits DepositLimit `protobuf:"bytes,2,opt,name=limits,proto3" json:"limits"`
	// Reason for the update
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgUpdateDepositLimits) Reset()         { *m = MsgUpdateDepositLimits{} }
func (m *MsgUpdateDepositLimits) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDepositLimits) ProtoMessage()    {}
func (*MsgUpdateDepositLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{35}
}
func (m *MsgUpdateDepositLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDepositLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDepositLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDepositLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDepositLimits.Merge(m, src)
}
func (m *MsgUpdateDepositLimits) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDepositLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDepositLimits.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDepositLimits proto.InternalMessageInfo

// MsgUpdateDepositLimitsResponse confirms the deposit limits update
type MsgUpdateDepositLimitsResponse struct {
	// Previous limits configuration (JSON)
	PreviousLimits string `protobuf:"bytes,1,opt,name=previous_limits,json=previousLimits,proto3" json:"previous_limits,omitempty"`
	// New limits configuration (JSON)
	NewLimits string `protobuf:"bytes,2,opt,name=new_limits,json=newLimits,proto3" json:"new_limits,omitempty"`
}

func (m *MsgUpdateDepositLimitsResponse) Reset()         { *m = MsgUpdateDepositLimitsResponse{} }
func (m *MsgUpdateDepositLimitsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDepositLimitsResponse) ProtoMessage()    {}
func (*MsgUpdateDepositLimitsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{36}
}
func (m *MsgUpdateDepositLimitsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDepositLimitsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDepositLimitsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDepositLimitsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDepositLimitsResponse.Merge(m, src)
}
func (m *MsgUpdateDepositLimitsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDepositLimitsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDepositLimitsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDepositLimitsResponse proto.InternalMessageInfo

func (m *MsgUpdateDepositLimitsResponse) GetPreviousLimits() string {
	if m != nil {
		return m.PreviousLimits
	}
	return ""
}

func (m *MsgUpdateDepositLimitsResponse) GetNewLimits() string {
	if m != nil {
		return m.NewLimits
	}
	return ""
}

// MsgCleanupStaleInflight removes a stale inflight fund and returns value to vault
type MsgCleanupStaleInflight struct {
	// Authority address (must match module authority)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Inflight fund ID
	InflightId uint64 `protobuf:"varint,2,opt,name=inflight_id,json=inflightId,proto3" json:"inflight_id,omitempty"`
	// Transaction ID of the stale inflight fund
	TransactionId string `protobuf:"bytes,3,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	// Reason for cleanup (for audit trail)
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgCleanupStaleInflight) Reset()         { *m = MsgCleanupStaleInflight{} }
func (m *MsgCleanupStaleInflight) String() string { return proto.CompactTextString(m) }
func (*MsgCleanupStaleInflight) ProtoMessage()    {}
func (*MsgCleanupStaleInflight) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{37}
}
func (m *MsgCleanupStaleInflight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCleanupStaleInflight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCleanupStaleInflight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCleanupStaleInflight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCleanupStaleInflight.Merge(m, src)
}
func (m *MsgCleanupStaleInflight) XXX_Size() int {
	return m.Size()
}
func (m *MsgCleanupStaleInflight) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCleanupStaleInflight.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCleanupStaleInflight proto.InternalMessageInfo

func (m *MsgCleanupStaleInflight) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgCleanupStaleInflight) GetInflightId() uint64 {
	if m != nil {
		return m.InflightId
	}
	return 0
}

func (m *MsgCleanupStaleInflight) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *MsgCleanupStaleInflight) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgCleanupStaleInflightResponse returns details of the cleanup
type MsgCleanupStaleInflightResponse struct {
	// Inflight fund ID that was cleaned up
	InflightId uint64 `protobuf:"varint,1,opt,name=inflight_id,json=inflightId,proto3" json:"inflight_id,omitempty"`
	// Transaction ID that was cleaned up
	TransactionId string `protobuf:"bytes,2,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	// Amount returned to vault
	AmountReturned cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount_returned,json=amountReturned,proto3,customtype=cosmossdk.io/math.Int" json:"amount_returned"`
	// Route ID
	RouteId uint32 `protobuf:"varint,4,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Timestamp of cleanup
	CleanedAt time.Time `protobuf:"bytes,5,opt,name=cleaned_at,json=cleanedAt,proto3,stdtime" json:"cleaned_at"`
}

func (m *MsgCleanupStaleInflightResponse) Reset()         { *m = MsgCleanupStaleInflightResponse{} }
func (m *MsgCleanupStaleInflightResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCleanupStaleInflightResponse) ProtoMessage()    {}
func (*MsgCleanupStaleInflightResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{38}
}
func (m *MsgCleanupStaleInflightResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCleanupStaleInflightResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCleanupStaleInflightResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCleanupStaleInflightResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCleanupStaleInflightResponse.Merge(m, src)
}
func (m *MsgCleanupStaleInflightResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCleanupStaleInflightResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCleanupStaleInflightResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCleanupStaleInflightResponse proto.InternalMessageInfo

func (m *MsgCleanupStaleInflightResponse) GetInflightId() uint64 {
	if m != nil {
		return m.InflightId
	}
	return 0
}

func (m *MsgCleanupStaleInflightResponse) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *MsgCleanupStaleInflightResponse) GetRouteId() uint32 {
	if m != nil {
		return m.RouteId
	}
	return 0
}

func (m *MsgCleanupStaleInflightResponse) GetCleanedAt() time.Time {
	if m != nil {
		return m.CleanedAt
	}
	return time.Time{}
}

// MsgUpdateVaultAccounting triggers vault accounting for yield distribution
type MsgUpdateVaultAccounting struct {
	// Vault manager address (authorized to trigger accounting)
	Manager string `protobuf:"bytes,1,opt,name=manager,proto3" json:"manager,omitempty"`
	// Maximum number of positions to process in this call
	// If 0, will process all remaining positions
	MaxPositions uint32 `protobuf:"varint,2,opt,name=max_positions,json=maxPositions,proto3" json:"max_positions,omitempty"`
}

func (m *MsgUpdateVaultAccounting) Reset()         { *m = MsgUpdateVaultAccounting{} }
func (m *MsgUpdateVaultAccounting) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateVaultAccounting) ProtoMessage()    {}
func (*MsgUpdateVaultAccounting) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{39}
}
func (m *MsgUpdateVaultAccounting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateVaultAccounting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateVaultAccounting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateVaultAccounting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateVaultAccounting.Merge(m, src)
}
func (m *MsgUpdateVaultAccounting) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateVaultAccounting) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateVaultAccounting.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateVaultAccounting proto.InternalMessageInfo

// MsgUpdateVaultAccountingResponse returns the results of the accounting update
type MsgUpdateVaultAccountingResponse struct {
	// Number of positions processed in this call
	PositionsProcessed uint64 `protobuf:"varint,1,opt,name=positions_processed,json=positionsProcessed,proto3" json:"positions_processed,omitempty"`
	// Total positions processed in this accounting session
	TotalPositionsProcessed uint64 `protobuf:"varint,2,opt,name=total_positions_processed,json=totalPositionsProcessed,proto3" json:"total_positions_processed,omitempty"`
	// Total positions in the system
	TotalPositions uint64 `protobuf:"varint,3,opt,name=total_positions,json=totalPositions,proto3" json:"total_positions,omitempty"`
	// Whether accounting is complete for this session
	AccountingComplete bool `protobuf:"varint,4,opt,name=accounting_complete,json=accountingComplete,proto3" json:"accounting_complete,omitempty"`
	// NAV value applied in this accounting update
	AppliedNav cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=applied_nav,json=appliedNav,proto3,customtype=cosmossdk.io/math.Int" json:"applied_nav"`
	// Total yield distributed in this call
	YieldDistributed cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=yield_distributed,json=yieldDistributed,proto3,customtype=cosmossdk.io/math.Int" json:"yield_distributed"`
	// Next user to process (empty if complete)
	NextUser string `protobuf:"bytes,7,opt,name=next_user,json=nextUser,proto3" json:"next_user,omitempty"`
	// Warning message if negative yield was detected
	// When negative yield is detected, no yield is distributed (yield_distributed = 0)
	// This indicates NAV decreased below (TotalDeposits + TotalAccruedYield)
	// Manager should investigate vault losses or accounting discrepancies
	NegativeYieldWarning string `protobuf:"bytes,8,opt,name=negative_yield_warning,json=negativeYieldWarning,proto3" json:"negative_yield_warning,omitempty"`
}

func (m *MsgUpdateVaultAccountingResponse) Reset()         { *m = MsgUpdateVaultAccountingResponse{} }
func (m *MsgUpdateVaultAccountingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateVaultAccountingResponse) ProtoMessage()    {}
func (*MsgUpdateVaultAccountingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{40}
}
func (m *MsgUpdateVaultAccountingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateVaultAccountingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateVaultAccountingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateVaultAccountingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateVaultAccountingResponse.Merge(m, src)
}
func (m *MsgUpdateVaultAccountingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateVaultAccountingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateVaultAccountingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateVaultAccountingResponse proto.InternalMessageInfo

func (m *MsgUpdateVaultAccountingResponse) GetPositionsProcessed() uint64 {
	if m != nil {
		return m.PositionsProcessed
	}
	return 0
}

func (m *MsgUpdateVaultAccountingResponse) GetTotalPositionsProcessed() uint64 {
	if m != nil {
		return m.TotalPositionsProcessed
	}
	return 0
}

func (m *MsgUpdateVaultAccountingResponse) GetTotalPositions() uint64 {
	if m != nil {
		return m.TotalPositions
	}
	return 0
}

func (m *MsgUpdateVaultAccountingResponse) GetAccountingComplete() bool {
	if m != nil {
		return m.AccountingComplete
	}
	return false
}

func (m *MsgUpdateVaultAccountingResponse) GetNextUser() string {
	if m != nil {
		return m.NextUser
	}
	return ""
}

func (m *MsgUpdateVaultAccountingResponse) GetNegativeYieldWarning() string {
	if m != nil {
		return m.NegativeYieldWarning
	}
	return ""
}

// MsgProcessIncomingWarpFunds processes funds received via warp route and marks inflight funds as completed
// This message should be called when USDN is received from remote positions via warp route
type MsgProcessIncomingWarpFunds struct {
	// Processor address (authorized system account or hook)
	Processor string `protobuf:"bytes,1,opt,name=processor,proto3" json:"processor,omitempty"`
	// Transaction ID of the inflight fund to complete
	TransactionId string `protobuf:"bytes,2,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	// Amount actually received (may differ from original amount due to fees, slippage, etc.)
	AmountReceived cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount_received,json=amountReceived,proto3,customtype=cosmossdk.io/math.Int" json:"amount_received"`
	// Route ID the funds came from
	RouteId uint32 `protobuf:"varint,4,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Hyperlane message ID for cross-referencing
	HyperlaneMessageId string `protobuf:"bytes,5,opt,name=hyperlane_message_id,json=hyperlaneMessageId,proto3" json:"hyperlane_message_id,omitempty"`
	// Origin chain domain for validation
	OriginDomain uint32 `protobuf:"varint,6,opt,name=origin_domain,json=originDomain,proto3" json:"origin_domain,omitempty"`
	// Timestamp when funds were received
	ReceivedAt time.Time `protobuf:"bytes,7,opt,name=received_at,json=receivedAt,proto3,stdtime" json:"received_at"`
	// ID of the inflight funds to process
	InflightId uint64 `protobuf:"varint,8,opt,name=inflight_id,json=inflightId,proto3" json:"inflight_id,omitempty"`
}

func (m *MsgProcessIncomingWarpFunds) Reset()         { *m = MsgProcessIncomingWarpFunds{} }
func (m *MsgProcessIncomingWarpFunds) String() string { return proto.CompactTextString(m) }
func (*MsgProcessIncomingWarpFunds) ProtoMessage()    {}
func (*MsgProcessIncomingWarpFunds) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{41}
}
func (m *MsgProcessIncomingWarpFunds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessIncomingWarpFunds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessIncomingWarpFunds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessIncomingWarpFunds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessIncomingWarpFunds.Merge(m, src)
}
func (m *MsgProcessIncomingWarpFunds) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessIncomingWarpFunds) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessIncomingWarpFunds.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessIncomingWarpFunds proto.InternalMessageInfo

// MsgProcessIncomingWarpFundsResponse returns details of the processed funds
type MsgProcessIncomingWarpFundsResponse struct {
	// Transaction ID that was completed
	TransactionId string `protobuf:"bytes,1,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	// Route ID
	RouteId uint32 `protobuf:"varint,2,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Amount marked as completed
	AmountCompleted cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount_completed,json=amountCompleted,proto3,customtype=cosmossdk.io/math.Int" json:"amount_completed"`
	// Original inflight amount for comparison
	OriginalAmount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=original_amount,json=originalAmount,proto3,customtype=cosmossdk.io/math.Int" json:"original_amount"`
	// Whether there was a difference between received and expected
	AmountMatched bool `protobuf:"varint,5,opt,name=amount_matched,json=amountMatched,proto3" json:"amount_matched,omitempty"`
	// Updated pending withdrawal distribution (if applicable)
	UpdatedPendingDistribution cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=updated_pending_distribution,json=updatedPendingDistribution,proto3,customtype=cosmossdk.io/math.Int" json:"updated_pending_distribution"`
	// ID of the inflight funds to process
	InflightId uint64 `protobuf:"varint,7,opt,name=inflight_id,json=inflightId,proto3" json:"inflight_id,omitempty"`
}

func (m *MsgProcessIncomingWarpFundsResponse) Reset()         { *m = MsgProcessIncomingWarpFundsResponse{} }
func (m *MsgProcessIncomingWarpFundsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProcessIncomingWarpFundsResponse) ProtoMessage()    {}
func (*MsgProcessIncomingWarpFundsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c482f72d5d8ce397, []int{42}
}
func (m *MsgProcessIncomingWarpFundsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProcessIncomingWarpFundsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProcessIncomingWarpFundsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProcessIncomingWarpFundsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProcessIncomingWarpFundsResponse.Merge(m, src)
}
func (m *MsgProcessIncomingWarpFundsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProcessIncomingWarpFundsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProcessIncomingWarpFundsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProcessIncomingWarpFundsResponse proto.InternalMessageInfo

func (m *MsgProcessIncomingWarpFundsResponse) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *MsgProcessIncomingWarpFundsResponse) GetRouteId() uint32 {
	if m != nil {
		return m.RouteId
	}
	return 0
}

func (m *MsgProcessIncomingWarpFundsResponse) GetAmountMatched() bool {
	if m != nil {
		return m.AmountMatched
	}
	return false
}

func (m *MsgProcessIncomingWarpFundsResponse) GetInflightId() uint64 {
	if m != nil {
		return m.InflightId
	}
	return 0
}

func init() {
	proto.RegisterType((*MsgDeposit)(nil), "noble.dollar.vaults.v2.MsgDeposit")
	proto.RegisterType((*MsgDepositResponse)(nil), "noble.dollar.vaults.v2.MsgDepositResponse")
	proto.RegisterType((*MsgSetYieldPreference)(nil), "noble.dollar.vaults.v2.MsgSetYieldPreference")
	proto.RegisterType((*MsgSetYieldPreferenceResponse)(nil), "noble.dollar.vaults.v2.MsgSetYieldPreferenceResponse")
	proto.RegisterType((*MsgUpdateVaultConfig)(nil), "noble.dollar.vaults.v2.MsgUpdateVaultConfig")
	proto.RegisterType((*MsgUpdateVaultConfigResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateVaultConfigResponse")
	proto.RegisterType((*MsgUpdateParams)(nil), "noble.dollar.vaults.v2.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgCreateCrossChainRoute)(nil), "noble.dollar.vaults.v2.MsgCreateCrossChainRoute")
	proto.RegisterType((*MsgCreateCrossChainRouteResponse)(nil), "noble.dollar.vaults.v2.MsgCreateCrossChainRouteResponse")
	proto.RegisterType((*MsgUpdateCrossChainRoute)(nil), "noble.dollar.vaults.v2.MsgUpdateCrossChainRoute")
	proto.RegisterType((*MsgUpdateCrossChainRouteResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateCrossChainRouteResponse")
	proto.RegisterType((*MsgDisableCrossChainRoute)(nil), "noble.dollar.vaults.v2.MsgDisableCrossChainRoute")
	proto.RegisterType((*MsgDisableCrossChainRouteResponse)(nil), "noble.dollar.vaults.v2.MsgDisableCrossChainRouteResponse")
	proto.RegisterType((*MsgProcessInFlightPosition)(nil), "noble.dollar.vaults.v2.MsgProcessInFlightPosition")
	proto.RegisterType((*MsgProcessInFlightPositionResponse)(nil), "noble.dollar.vaults.v2.MsgProcessInFlightPositionResponse")
	proto.RegisterType((*MsgRequestWithdrawal)(nil), "noble.dollar.vaults.v2.MsgRequestWithdrawal")
	proto.RegisterType((*MsgRequestWithdrawalResponse)(nil), "noble.dollar.vaults.v2.MsgRequestWithdrawalResponse")
	proto.RegisterType((*MsgProcessWithdrawalQueue)(nil), "noble.dollar.vaults.v2.MsgProcessWithdrawalQueue")
	proto.RegisterType((*MsgProcessWithdrawalQueueResponse)(nil), "noble.dollar.vaults.v2.MsgProcessWithdrawalQueueResponse")
	proto.RegisterType((*MsgCreateRemotePosition)(nil), "noble.dollar.vaults.v2.MsgCreateRemotePosition")
	proto.RegisterType((*MsgCreateRemotePositionResponse)(nil), "noble.dollar.vaults.v2.MsgCreateRemotePositionResponse")
	proto.RegisterType((*MsgCloseRemotePosition)(nil), "noble.dollar.vaults.v2.MsgCloseRemotePosition")
	proto.RegisterType((*MsgCloseRemotePositionResponse)(nil), "noble.dollar.vaults.v2.MsgCloseRemotePositionResponse")
	proto.RegisterType((*TargetAllocation)(nil), "noble.dollar.vaults.v2.TargetAllocation")
	proto.RegisterType((*MsgRebalance)(nil), "noble.dollar.vaults.v2.MsgRebalance")
	proto.RegisterType((*MsgRebalanceResponse)(nil), "noble.dollar.vaults.v2.MsgRebalanceResponse")
	proto.RegisterType((*MsgClaimWithdrawal)(nil), "noble.dollar.vaults.v2.MsgClaimWithdrawal")
	proto.RegisterType((*MsgClaimWithdrawalResponse)(nil), "noble.dollar.vaults.v2.MsgClaimWithdrawalResponse")
	proto.RegisterType((*MsgCancelWithdrawal)(nil), "noble.dollar.vaults.v2.MsgCancelWithdrawal")
	proto.RegisterType((*MsgCancelWithdrawalResponse)(nil), "noble.dollar.vaults.v2.MsgCancelWithdrawalResponse")
	proto.RegisterType((*MsgUpdateNAV)(nil), "noble.dollar.vaults.v2.MsgUpdateNAV")
	proto.RegisterType((*MsgUpdateNAVResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateNAVResponse")
	proto.RegisterType((*MsgHandleStaleInflight)(nil), "noble.dollar.vaults.v2.MsgHandleStaleInflight")
	proto.RegisterType((*MsgHandleStaleInflightResponse)(nil), "noble.dollar.vaults.v2.MsgHandleStaleInflightResponse")
	proto.RegisterType((*MsgUpdateDepositLimits)(nil), "noble.dollar.vaults.v2.MsgUpdateDepositLimits")
	proto.RegisterType((*MsgUpdateDepositLimitsResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateDepositLimitsResponse")
	proto.RegisterType((*MsgCleanupStaleInflight)(nil), "noble.dollar.vaults.v2.MsgCleanupStaleInflight")
	proto.RegisterType((*MsgCleanupStaleInflightResponse)(nil), "noble.dollar.vaults.v2.MsgCleanupStaleInflightResponse")
	proto.RegisterType((*MsgUpdateVaultAccounting)(nil), "noble.dollar.vaults.v2.MsgUpdateVaultAccounting")
	proto.RegisterType((*MsgUpdateVaultAccountingResponse)(nil), "noble.dollar.vaults.v2.MsgUpdateVaultAccountingResponse")
	proto.RegisterType((*MsgProcessIncomingWarpFunds)(nil), "noble.dollar.vaults.v2.MsgProcessIncomingWarpFunds")
	proto.RegisterType((*MsgProcessIncomingWarpFundsResponse)(nil), "noble.dollar.vaults.v2.MsgProcessIncomingWarpFundsResponse")
}

func init() { proto.RegisterFile("noble/dollar/vaults/v2/tx.proto", fileDescriptor_c482f72d5d8ce397) }

var fileDescriptor_c482f72d5d8ce397 = []byte{
	// 3149 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x3b, 0x4b, 0x8c, 0x1c, 0x47,
	0xd9, 0xee, 0xd9, 0xf5, 0x3e, 0x6a, 0x5f, 0xde, 0xde, 0xf5, 0x7a, 0x3c, 0x7f, 0xbc, 0xeb, 0xb4,
	0xed, 0xd8, 0x71, 0xec, 0x19, 0x7b, 0x1d, 0xe7, 0x4f, 0x96, 0x24, 0x68, 0x76, 0x37, 0x51, 0x46,
	0x64, 0x9d, 0x4d, 0x3b, 0xb6, 0x31, 0x08, 0x35, 0xb5, 0xd3, 0xb5, 0xbd, 0x8d, 0xbb, 0xab, 0x3b,
	0xdd, 0x35, 0xbb, 0xeb, 0x48, 0x91, 0xa2, 0xa0, 0xa0, 0x80, 0x38, 0x04, 0x4e, 0x70, 0x8b, 0x10,
	0x07, 0xc4, 0x29, 0x87, 0x88, 0x03, 0x12, 0x07, 0x0e, 0xa0, 0x88, 0x53, 0x08, 0x42, 0x42, 0x41,
	0x0a, 0x28, 0x39, 0x24, 0x17, 0x84, 0x40, 0x42, 0x70, 0x8a, 0x50, 0x3d, 0xfa, 0x31, 0xfd, 0x9a,
	0x99, 0xde, 0x25, 0x17, 0x7b, 0xba, 0xea, 0xfb, 0xbe, 0xfa, 0xde, 0xf5, 0xd5, 0x57, 0xb5, 0x60,
	0x09, 0x3b, 0x5b, 0x16, 0x6a, 0xe8, 0x8e, 0x65, 0x41, 0xaf, 0xb1, 0x0b, 0x3b, 0x16, 0xf1, 0x1b,
	0xbb, 0xcb, 0x0d, 0xb2, 0x5f, 0x77, 0x3d, 0x87, 0x38, 0xf2, 0x02, 0x03, 0xa8, 0x73, 0x80, 0x3a,
	0x07, 0xa8, 0xef, 0x2e, 0xd7, 0x66, 0xa1, 0x6d, 0x62, 0xa7, 0xc1, 0xfe, 0xe5, 0xa0, 0xb5, 0x13,
	0x6d, 0xc7, 0xb7, 0x1d, 0xbf, 0x61, 0xfb, 0x46, 0x63, 0xf7, 0x2a, 0xfd, 0x4f, 0x4c, 0x9c, 0xe4,
	0x13, 0x1a, 0xfb, 0x6a, 0xf0, 0x0f, 0x31, 0x35, 0x6f, 0x38, 0x86, 0xc3, 0xc7, 0xe9, 0x2f, 0x31,
	0xba, 0x64, 0x38, 0x8e, 0x61, 0xa1, 0x06, 0xfb, 0xda, 0xea, 0x6c, 0x37, 0x88, 0x69, 0x23, 0x9f,
	0x40, 0xdb, 0x15, 0x00, 0x17, 0x72, 0xd8, 0x6e, 0x7b, 0x8e, 0xef, 0x6b, 0xed, 0x1d, 0x68, 0x62,
	0x01, 0x79, 0x36, 0x07, 0xd2, 0x40, 0x18, 0xf9, 0x66, 0xc0, 0xc6, 0x99, 0x1c, 0x28, 0xc7, 0x83,
	0x6d, 0x0b, 0xf5, 0x00, 0x12, 0x4a, 0x61, 0x40, 0xca, 0x67, 0x12, 0x00, 0x1b, 0xbe, 0xb1, 0x8e,
	0x5c, 0xc7, 0x37, 0x89, 0xfc, 0x18, 0x18, 0xd7, 0xf9, 0x4f, 0xc7, 0xab, 0x4a, 0xa7, 0xa5, 0x0b,
	0xe3, 0xab, 0xd5, 0x0f, 0xde, 0xbd, 0x3c, 0x2f, 0x94, 0xd0, 0xd4, 0x75, 0x0f, 0xf9, 0xfe, 0x4d,
	0xe2, 0x99, 0xd8, 0x50, 0x23, 0x50, 0xf9, 0x39, 0x30, 0x02, 0x6d, 0xa7, 0x83, 0x49, 0xb5, 0xc2,
	0x90, 0xae, 0xbc, 0xf7, 0xd1, 0xd2, 0x91, 0x0f, 0x3f, 0x5a, 0x3a, 0xce, 0x11, 0x7d, 0xfd, 0x5e,
	0xdd, 0x74, 0x1a, 0x36, 0x24, 0x3b, 0xf5, 0x16, 0x26, 0x1f, 0xbc, 0x7b, 0x19, 0x08, 0x8a, 0x2d,
	0x4c, 0x7e, 0xf6, 0xe9, 0x3b, 0x17, 0x25, 0x55, 0xe0, 0xcb, 0x67, 0xc0, 0x94, 0x87, 0xda, 0xc8,
	0xdc, 0x45, 0xda, 0x7d, 0x13, 0x59, 0x7a, 0x75, 0xe8, 0xb4, 0x74, 0x61, 0x4c, 0x9d, 0x14, 0x83,
	0x77, 0xe9, 0xd8, 0xca, 0xb5, 0x37, 0xdf, 0x5e, 0x3a, 0xf2, 0xd9, 0xdb, 0x4b, 0x47, 0x5e, 0xff,
	0xf4, 0x9d, 0x8b, 0x11, 0x1b, 0xdf, 0xfb, 0xf4, 0x9d, 0x8b, 0xd5, 0x94, 0xbc, 0x42, 0x36, 0xe5,
	0x87, 0x12, 0x90, 0x23, 0x51, 0x55, 0xe4, 0xbb, 0x0e, 0xf6, 0x91, 0xfc, 0x75, 0x70, 0x8c, 0x2f,
	0xad, 0x09, 0x3a, 0x48, 0x17, 0x92, 0x0f, 0x2e, 0xc4, 0x0c, 0xa7, 0xb4, 0x1e, 0x10, 0x92, 0x97,
	0xc0, 0x04, 0xfb, 0x69, 0x3a, 0x58, 0x33, 0x75, 0xa6, 0x9c, 0x61, 0x15, 0x04, 0x43, 0x2d, 0x5d,
	0xf9, 0xad, 0x04, 0x8e, 0x6f, 0xf8, 0xc6, 0x4d, 0x44, 0x98, 0x64, 0x9b, 0x1e, 0xda, 0x46, 0x1e,
	0xc2, 0x6d, 0x24, 0x5f, 0x02, 0xc3, 0x1d, 0x1f, 0xf5, 0xb6, 0x02, 0x83, 0x4a, 0xab, 0xad, 0x92,
	0x56, 0x5b, 0x92, 0x9b, 0xa1, 0x24, 0x37, 0x2b, 0x4f, 0xc4, 0xf5, 0xca, 0x08, 0x53, 0x95, 0x9e,
	0x49, 0xa9, 0x34, 0xcd, 0xae, 0xf2, 0x23, 0x09, 0x9c, 0xca, 0x14, 0x24, 0x54, 0x74, 0x03, 0xcc,
	0xb9, 0x1e, 0xda, 0x35, 0x9d, 0x0e, 0x0d, 0xad, 0x60, 0x9a, 0xc9, 0x37, 0xa6, 0xca, 0xc1, 0x54,
	0x4c, 0x03, 0xe7, 0xc0, 0x34, 0x46, 0x7b, 0x71, 0x58, 0x2e, 0xd4, 0x14, 0x46, 0x7b, 0x31, 0xb0,
	0x5e, 0x52, 0x51, 0x1f, 0x9f, 0xdf, 0xf0, 0x8d, 0x5b, 0xae, 0x0e, 0x09, 0xba, 0x4d, 0x85, 0x58,
	0x73, 0xf0, 0xb6, 0x69, 0x50, 0x6f, 0x87, 0x1d, 0xb2, 0xe3, 0x78, 0x26, 0xb9, 0xdf, 0xdb, 0xdb,
	0x43, 0x50, 0xb9, 0x09, 0x46, 0xda, 0x8c, 0x02, 0x63, 0x68, 0x62, 0xf9, 0x4c, 0x3d, 0x3b, 0xeb,
	0xd4, 0x63, 0x8b, 0xad, 0x0e, 0x53, 0x6f, 0x52, 0x05, 0xa2, 0xbc, 0x00, 0x46, 0x3c, 0x04, 0x7d,
	0x07, 0x33, 0x7e, 0xc7, 0x55, 0xf1, 0xb5, 0xf2, 0x54, 0x97, 0x67, 0x87, 0x4b, 0x52, 0x33, 0x28,
	0x29, 0x33, 0xa4, 0x24, 0x52, 0xb6, 0xc1, 0x03, 0x59, 0x92, 0x86, 0x36, 0x38, 0x0f, 0x66, 0x42,
	0x1b, 0x08, 0x11, 0x98, 0xdc, 0xea, 0x74, 0x30, 0x2c, 0x54, 0x73, 0x0a, 0x00, 0xaa, 0xfb, 0x98,
	0x98, 0xe3, 0xea, 0x38, 0x46, 0x7b, 0x62, 0x9d, 0x5f, 0x4b, 0x60, 0x26, 0x5c, 0x68, 0x13, 0x7a,
	0xd0, 0xf6, 0x4b, 0x6b, 0xf3, 0x49, 0x30, 0xe2, 0x32, 0x0a, 0x42, 0x9b, 0x8b, 0x79, 0xda, 0xe4,
	0xeb, 0x04, 0x8a, 0xe4, 0x38, 0x2b, 0x8f, 0xe7, 0x2b, 0xec, 0x54, 0x8e, 0xc2, 0x38, 0x1d, 0xe5,
	0x24, 0x38, 0x91, 0x10, 0x21, 0x50, 0x93, 0xf2, 0xa1, 0x04, 0xaa, 0x1b, 0xbe, 0xb1, 0xe6, 0x21,
	0x48, 0xd0, 0x1a, 0x4d, 0xd2, 0x6b, 0x34, 0x47, 0xab, 0x4e, 0x87, 0xa0, 0xd2, 0x72, 0xae, 0x81,
	0xa3, 0x1e, 0x25, 0x20, 0xc4, 0x3c, 0x9f, 0x27, 0x66, 0x62, 0x3d, 0x21, 0x2f, 0xc7, 0x5d, 0x69,
	0xe6, 0x8b, 0xfb, 0x50, 0x4a, 0xdc, 0x4c, 0xfe, 0x95, 0xa7, 0xc0, 0xe9, 0x3c, 0xd9, 0x42, 0x3f,
	0x39, 0x09, 0xc6, 0xd8, 0x7a, 0x34, 0xa0, 0xa8, 0x88, 0x53, 0xea, 0x28, 0xfb, 0x6e, 0xe9, 0xca,
	0xbf, 0xb8, 0x6e, 0xb8, 0xde, 0x0e, 0x4b, 0x37, 0xf1, 0xf5, 0x2a, 0x5d, 0xeb, 0x45, 0x6a, 0x1b,
	0xfa, 0xa2, 0xd4, 0x96, 0x29, 0x9a, 0xf2, 0x86, 0xc4, 0xf4, 0x96, 0x39, 0xd9, 0x87, 0xde, 0xb2,
	0x42, 0xaf, 0xd2, 0x47, 0xe8, 0x0d, 0x25, 0x43, 0xef, 0x77, 0x12, 0x38, 0x49, 0xb7, 0x31, 0xd3,
	0x87, 0x5b, 0xd6, 0x17, 0x61, 0x80, 0xbc, 0x54, 0xb5, 0x9a, 0xaf, 0xd3, 0xf3, 0xe9, 0x4d, 0x38,
	0x93, 0x5d, 0xc5, 0x06, 0x0f, 0xe6, 0xca, 0xd2, 0x8f, 0x52, 0x2f, 0x03, 0x19, 0x6e, 0x6f, 0xa3,
	0x36, 0x41, 0xba, 0x16, 0x64, 0x7c, 0x9e, 0x47, 0x86, 0xd4, 0xd9, 0x60, 0x66, 0x33, 0x98, 0x50,
	0xfe, 0x30, 0x04, 0x6a, 0x1b, 0xbe, 0xb1, 0xe9, 0x39, 0x6d, 0xe4, 0xfb, 0x2d, 0xfc, 0xac, 0x65,
	0x1a, 0x3b, 0x24, 0x98, 0x2f, 0xad, 0xbc, 0x79, 0x70, 0x14, 0x3b, 0xc1, 0xfe, 0x34, 0xac, 0xf2,
	0x0f, 0xf9, 0x2b, 0x74, 0x4b, 0xf6, 0x3b, 0x16, 0xd1, 0x7c, 0x02, 0x49, 0xc7, 0x67, 0xea, 0x9b,
	0x5e, 0x7e, 0x28, 0xcf, 0x81, 0x5b, 0x78, 0x9b, 0xb1, 0x73, 0x93, 0x41, 0xd3, 0xad, 0x9b, 0x22,
	0xf3, 0x2f, 0xf9, 0x56, 0x48, 0x4c, 0xd4, 0x59, 0xc3, 0x25, 0x4b, 0x14, 0x41, 0xb6, 0x19, 0x56,
	0x5b, 0xc8, 0xf3, 0x1c, 0x4f, 0xb3, 0x91, 0xef, 0x43, 0x03, 0x55, 0x8f, 0x32, 0x13, 0x4f, 0xb2,
	0xc1, 0x0d, 0x3e, 0x26, 0xdf, 0x05, 0xb3, 0xae, 0xe7, 0xec, 0x9a, 0x3a, 0xf2, 0x34, 0xe2, 0xc1,
	0xf6, 0x3d, 0x13, 0x1b, 0xd5, 0x11, 0x16, 0x8d, 0x97, 0x72, 0x73, 0xb5, 0x40, 0x78, 0x49, 0xc0,
	0xb7, 0xf0, 0xb6, 0xa3, 0x1e, 0x73, 0x13, 0xa3, 0x2b, 0x6b, 0xf9, 0x3e, 0x74, 0x21, 0xe5, 0x43,
	0x39, 0x66, 0x53, 0x7e, 0x55, 0x01, 0x4a, 0xbe, 0x55, 0x43, 0x37, 0x0a, 0xad, 0x24, 0xc5, 0xad,
	0xd4, 0x02, 0x93, 0xdb, 0x26, 0x86, 0x56, 0x60, 0xa4, 0xca, 0x40, 0x46, 0x9a, 0x60, 0xb8, 0xc2,
	0x46, 0x51, 0x25, 0xe9, 0x72, 0x56, 0x10, 0xaf, 0x46, 0x0e, 0x50, 0x49, 0x6e, 0x06, 0x84, 0xe4,
	0xbb, 0x60, 0xc6, 0xdf, 0x81, 0x1e, 0xf2, 0xb5, 0xc0, 0xad, 0x4b, 0xbb, 0xc0, 0x34, 0x27, 0xd4,
	0x14, 0x74, 0x94, 0xff, 0xf0, 0xfa, 0x48, 0x45, 0x2f, 0x77, 0x90, 0x4f, 0xee, 0x98, 0x64, 0x47,
	0xf7, 0xe0, 0x1e, 0xb4, 0x68, 0x3c, 0x78, 0x7c, 0xb0, 0x8f, 0x3a, 0x34, 0x02, 0x3d, 0xc4, 0xd3,
	0x40, 0xcf, 0x8a, 0xb5, 0xbb, 0x5e, 0x0a, 0x59, 0xc8, 0xae, 0x97, 0x52, 0x12, 0x2a, 0xbf, 0xa9,
	0xb0, 0x82, 0x29, 0x35, 0x11, 0x3a, 0xcd, 0x29, 0x00, 0x04, 0xd1, 0x20, 0xfb, 0x0c, 0x87, 0x92,
	0xb6, 0x74, 0x1a, 0x96, 0xc2, 0xe4, 0x96, 0xd3, 0xbe, 0x87, 0xf4, 0xd2, 0x02, 0x4f, 0x72, 0x32,
	0xcf, 0x33, 0x2a, 0x94, 0x2c, 0xab, 0xe2, 0x35, 0xd7, 0xf1, 0xa8, 0xa0, 0xa5, 0xdd, 0x68, 0x92,
	0x91, 0xd9, 0xe4, 0x54, 0xe4, 0xaf, 0x82, 0xe3, 0x68, 0xdf, 0xe5, 0xd9, 0xb2, 0x6d, 0x41, 0xd3,
	0xa6, 0x59, 0x57, 0x83, 0x3c, 0x99, 0x4c, 0x2c, 0xd7, 0xea, 0xfc, 0x1c, 0x5b, 0x0f, 0xce, 0xb1,
	0xf5, 0x97, 0x82, 0x73, 0xec, 0xea, 0x18, 0x5d, 0xfa, 0xad, 0xbf, 0x2c, 0x49, 0xea, 0x5c, 0x40,
	0x62, 0x2d, 0xa0, 0xd0, 0x24, 0xca, 0x2f, 0xf9, 0xa6, 0x24, 0xdc, 0x35, 0xd2, 0xe3, 0x8b, 0x1d,
	0xd4, 0x29, 0xbf, 0x29, 0x3d, 0x08, 0x26, 0x6d, 0xb8, 0xaf, 0x09, 0x75, 0xf3, 0xd8, 0x3c, 0xaa,
	0x4e, 0xd8, 0x70, 0x5f, 0x18, 0xcc, 0x1f, 0x6c, 0x13, 0xca, 0x66, 0x4f, 0xf9, 0x63, 0x85, 0xed,
	0x42, 0xd9, 0xb3, 0xa1, 0x27, 0x5c, 0x06, 0x72, 0xc0, 0x48, 0x2c, 0xbe, 0x25, 0xc6, 0xd2, 0x6c,
	0x30, 0x13, 0xc5, 0xeb, 0x36, 0x58, 0x20, 0x0e, 0x81, 0x96, 0x96, 0x4a, 0x09, 0x65, 0x5d, 0x64,
	0x9e, 0xd1, 0x6b, 0x26, 0xf2, 0xc2, 0xb7, 0x40, 0xb5, 0x6b, 0x1d, 0xdd, 0xf4, 0x89, 0x67, 0x6e,
	0x75, 0xc8, 0x01, 0x92, 0xcf, 0x42, 0x6c, 0xa5, 0xf5, 0x88, 0x1e, 0x57, 0x81, 0x0d, 0x4d, 0x6c,
	0x62, 0x23, 0xb2, 0xca, 0x70, 0xa0, 0x02, 0x31, 0x13, 0xd8, 0x46, 0xf9, 0x7b, 0x85, 0x55, 0xd8,
	0xbc, 0xd2, 0x54, 0x91, 0xed, 0x10, 0x14, 0x6e, 0xb5, 0xcb, 0x60, 0xd4, 0x86, 0x18, 0x1a, 0x7d,
	0x24, 0x96, 0x00, 0x90, 0x6e, 0x56, 0xcc, 0x96, 0x1a, 0xe4, 0xf3, 0xa2, 0x7e, 0x9a, 0x64, 0x83,
	0x02, 0x87, 0x16, 0x0b, 0xac, 0x9f, 0x12, 0xa4, 0x8b, 0x29, 0x75, 0x94, 0x7d, 0xb7, 0xf4, 0x58,
	0x5a, 0x1a, 0x3e, 0x60, 0x5a, 0xba, 0x0d, 0xa6, 0x6d, 0x13, 0x6b, 0x22, 0x21, 0x3b, 0x1d, 0xc2,
	0xf7, 0xcd, 0x32, 0x01, 0x6a, 0x9b, 0xf8, 0x26, 0x23, 0xf3, 0x42, 0x87, 0xac, 0x3c, 0x1d, 0xf7,
	0xe6, 0x40, 0x6e, 0xea, 0xcb, 0xe7, 0x72, 0x6a, 0xfb, 0x6e, 0xad, 0x2a, 0xef, 0x4a, 0x60, 0x29,
	0x47, 0xe3, 0xa1, 0x1f, 0x27, 0x52, 0xaa, 0x94, 0x4c, 0xa9, 0x45, 0xa5, 0xe0, 0x2d, 0x30, 0x17,
	0x25, 0x10, 0xc7, 0x76, 0x2d, 0x14, 0x66, 0xa7, 0x7e, 0xd3, 0x87, 0x1c, 0xa6, 0x8f, 0x10, 0x5f,
	0x79, 0xa3, 0x02, 0x16, 0x28, 0xdb, 0x96, 0xe3, 0x1f, 0x86, 0x9f, 0xf4, 0x6a, 0xba, 0xc8, 0x77,
	0xc0, 0xb4, 0x0b, 0x3d, 0x62, 0x86, 0x51, 0x53, 0x3a, 0x52, 0xa6, 0x04, 0x1d, 0x1e, 0x2b, 0xdd,
	0xbb, 0x51, 0xdc, 0x7e, 0x67, 0xd3, 0xf6, 0x4b, 0x0b, 0xab, 0xfc, 0x42, 0x02, 0x8b, 0xd9, 0x7a,
	0xe8, 0xdf, 0x7a, 0x0f, 0x80, 0x71, 0x13, 0x9b, 0xc4, 0x84, 0x04, 0x05, 0x4d, 0xa0, 0x68, 0xe0,
	0x7f, 0x65, 0xc0, 0x6f, 0x82, 0x63, 0x2f, 0x41, 0xcf, 0x40, 0xa4, 0x69, 0x59, 0x4e, 0x1b, 0x32,
	0xcb, 0xf5, 0xe4, 0xf4, 0x11, 0x30, 0x4b, 0x18, 0x92, 0xe6, 0x22, 0xaf, 0x8d, 0x30, 0xa1, 0xf5,
	0x27, 0x77, 0xb8, 0x63, 0x7c, 0x62, 0x33, 0x1c, 0x57, 0xde, 0x97, 0xc0, 0x24, 0xdb, 0xa8, 0xb7,
	0xa0, 0x05, 0x69, 0xdd, 0x56, 0xc6, 0x31, 0xee, 0x00, 0x59, 0xac, 0x08, 0x43, 0x3e, 0x69, 0x16,
	0x19, 0xba, 0x30, 0xb1, 0x7c, 0x21, 0xaf, 0xe2, 0x4b, 0x0a, 0xa6, 0x0a, 0xae, 0xa3, 0x11, 0xbf,
	0xbb, 0x1f, 0x19, 0xb7, 0x7b, 0x2d, 0xa3, 0x06, 0x11, 0x12, 0x28, 0x6d, 0x51, 0x75, 0x89, 0xef,
	0xd0, 0xc4, 0x57, 0xc1, 0xbc, 0xe3, 0x22, 0x8f, 0x93, 0xd6, 0x22, 0x63, 0xf2, 0xad, 0x66, 0x2e,
	0x9a, 0x6b, 0x85, 0x66, 0xad, 0x82, 0x51, 0xbf, 0x63, 0xdb, 0xd0, 0xbb, 0x2f, 0x72, 0x62, 0xf0,
	0xa9, 0xfc, 0x84, 0x37, 0x3d, 0xd9, 0x5e, 0x1d, 0xab, 0xec, 0x96, 0xc1, 0x28, 0x2b, 0x00, 0xfa,
	0xd1, 0x9e, 0x00, 0x4c, 0x94, 0x42, 0x95, 0x44, 0x29, 0xd4, 0xdd, 0x3b, 0x0c, 0x90, 0xa8, 0x0e,
	0x4e, 0x67, 0xf8, 0x7e, 0x17, 0x37, 0xca, 0xe7, 0x15, 0x76, 0x2c, 0x4b, 0x0c, 0x87, 0x0a, 0xb9,
	0x03, 0xa6, 0xc5, 0xe6, 0xc6, 0xa9, 0x96, 0xef, 0xcf, 0x8a, 0x62, 0x6d, 0x8d, 0x93, 0xa1, 0x05,
	0xbb, 0xeb, 0x99, 0xb8, 0x6d, 0xba, 0x51, 0x26, 0x28, 0xbb, 0x3b, 0xcf, 0x84, 0x94, 0xc4, 0xd1,
	0xea, 0x26, 0xe0, 0xc5, 0xd7, 0x41, 0x53, 0xcc, 0x04, 0xa3, 0x22, 0x88, 0xde, 0x02, 0x53, 0xdb,
	0x08, 0xf9, 0x9a, 0x8e, 0xf4, 0xce, 0x81, 0xce, 0x00, 0x93, 0x94, 0xcc, 0xba, 0xa0, 0xa2, 0xfc,
	0x5c, 0x02, 0x73, 0xd4, 0x00, 0xd4, 0x0f, 0xad, 0x43, 0x38, 0x00, 0xf4, 0x70, 0x95, 0x27, 0xf3,
	0x8b, 0xf6, 0x07, 0xd3, 0xce, 0x92, 0x60, 0x4a, 0xf9, 0xb1, 0x04, 0xfe, 0x2f, 0x83, 0xd9, 0xd0,
	0x5d, 0xee, 0x02, 0x71, 0x78, 0xd2, 0x3a, 0x58, 0x54, 0xe5, 0x65, 0xfd, 0x45, 0xf8, 0xdd, 0x2d,
	0x41, 0xa7, 0x77, 0x3b, 0xff, 0x9f, 0x15, 0x96, 0xa6, 0x78, 0x93, 0xe8, 0x46, 0xf3, 0x76, 0xe9,
	0xd2, 0xb7, 0x05, 0x46, 0x31, 0xda, 0xd3, 0x30, 0xdc, 0x2d, 0x7f, 0x86, 0xc2, 0x68, 0xef, 0x06,
	0xdc, 0xa5, 0x8e, 0x18, 0x36, 0x9e, 0x28, 0xbd, 0xd2, 0x8e, 0x18, 0x50, 0xa1, 0x44, 0x4f, 0x01,
	0xd0, 0xde, 0x81, 0xd8, 0x40, 0xda, 0x96, 0x1b, 0x94, 0x80, 0xe3, 0x7c, 0x64, 0xd5, 0xf5, 0xe5,
	0x47, 0xc1, 0x42, 0xdb, 0xf4, 0xda, 0x1d, 0x93, 0x68, 0x5b, 0x1e, 0x82, 0xf7, 0x90, 0xa7, 0xc1,
	0x36, 0x31, 0x77, 0x79, 0x83, 0x61, 0x4c, 0x9d, 0x17, 0xb3, 0xab, 0x7c, 0xb2, 0xc9, 0xe6, 0x56,
	0xae, 0xe7, 0x17, 0xf3, 0xb5, 0x9c, 0x2e, 0xdd, 0x8d, 0xe6, 0x6d, 0xe5, 0xf5, 0x4a, 0xac, 0xbf,
	0x7f, 0xa3, 0x79, 0x3b, 0xf4, 0x84, 0x17, 0xc1, 0x04, 0x74, 0x5d, 0xcb, 0x44, 0x3a, 0x13, 0xbc,
	0xac, 0x17, 0x00, 0x41, 0x24, 0x2d, 0x77, 0x25, 0x29, 0xf7, 0x2a, 0x18, 0x0f, 0xef, 0xfe, 0x06,
	0xda, 0x55, 0x23, 0xb4, 0x02, 0xdd, 0x0d, 0xe7, 0xeb, 0x4e, 0xf9, 0x01, 0xaf, 0xa1, 0x9e, 0x83,
	0x58, 0xb7, 0xd0, 0x4d, 0x02, 0x2d, 0x14, 0xb4, 0x2a, 0x4a, 0xfb, 0xe0, 0x12, 0x98, 0x30, 0x05,
	0x8d, 0x98, 0xb7, 0x07, 0x43, 0x2d, 0x5d, 0x7e, 0x86, 0x77, 0x2a, 0x4b, 0xb5, 0xb7, 0xc6, 0x31,
	0xda, 0x13, 0x7d, 0x93, 0xa8, 0xc1, 0x38, 0xdc, 0xd5, 0x60, 0xfc, 0x72, 0xbe, 0x3b, 0xa4, 0xeb,
	0xa9, 0x0c, 0xc1, 0x95, 0xdf, 0xf3, 0x7a, 0x2a, 0x63, 0x2a, 0x5e, 0x4f, 0xc5, 0x65, 0x94, 0x52,
	0x32, 0x1e, 0x62, 0x7f, 0x68, 0x0d, 0x80, 0x1d, 0xc6, 0x8a, 0x4e, 0xcf, 0xdc, 0x03, 0x79, 0x87,
	0xc0, 0x6b, 0x12, 0xe5, 0x6f, 0x12, 0xb3, 0x33, 0x77, 0x76, 0x71, 0xd1, 0xf8, 0xbc, 0x69, 0x9b,
	0xa4, 0xfc, 0x05, 0xcc, 0x2a, 0x18, 0xb1, 0x18, 0x05, 0x71, 0x33, 0x71, 0x36, 0x4f, 0xb8, 0xf8,
	0x72, 0xc1, 0x35, 0x0c, 0xc7, 0xcc, 0x6d, 0x12, 0x0f, 0x64, 0xc3, 0x0c, 0xa1, 0x94, 0x1d, 0x66,
	0xc2, 0x8c, 0x99, 0xcc, 0x3b, 0x2d, 0x21, 0x47, 0xe2, 0x4e, 0x4b, 0xe8, 0x47, 0x34, 0xd6, 0x63,
	0xb2, 0xf2, 0xc6, 0xba, 0x58, 0xe9, 0x1f, 0x12, 0x3f, 0xae, 0x5a, 0x08, 0xe2, 0x8e, 0xfb, 0x05,
	0x85, 0xd0, 0x39, 0x30, 0x4d, 0x3c, 0x88, 0x7d, 0x1a, 0xe1, 0x51, 0x8f, 0x6b, 0x5c, 0x9d, 0x8a,
	0x8d, 0x76, 0xf5, 0xe0, 0xbb, 0x43, 0xe4, 0xe9, 0xb4, 0x5a, 0x1f, 0xc9, 0xb9, 0xf6, 0xcf, 0x92,
	0x4b, 0xf9, 0x69, 0x85, 0x1f, 0x18, 0x33, 0xe6, 0xfa, 0x0f, 0x91, 0xb4, 0x0c, 0x95, 0x2c, 0x19,
	0xa2, 0x7d, 0xd9, 0x43, 0xa4, 0xe3, 0xe1, 0x03, 0x34, 0x28, 0xc4, 0xbe, 0xac, 0x0a, 0x3a, 0x5d,
	0x47, 0xd6, 0xe1, 0xe4, 0xf5, 0x11, 0x68, 0x53, 0xe9, 0x78, 0xd0, 0x1d, 0x1d, 0x24, 0xe8, 0x04,
	0x5e, 0x93, 0xd0, 0x73, 0x75, 0xb5, 0xfb, 0x5e, 0xb5, 0xd9, 0x6e, 0x53, 0x0e, 0x4c, 0x6c, 0x94,
	0x6d, 0x65, 0xd8, 0x70, 0x3f, 0x71, 0x65, 0x31, 0xa5, 0x4e, 0xda, 0x70, 0x3f, 0xbc, 0xad, 0xe8,
	0x8e, 0x9d, 0xf8, 0xa9, 0xe2, 0xa1, 0xa2, 0x9b, 0xe0, 0x88, 0x33, 0xe5, 0xcd, 0xe1, 0xd8, 0x95,
	0x55, 0x62, 0xb2, 0xeb, 0x5a, 0x3e, 0x58, 0x32, 0xd1, 0xd8, 0x1a, 0x56, 0xe5, 0x70, 0x2a, 0xea,
	0x38, 0xad, 0x80, 0x93, 0xbc, 0xe3, 0x94, 0x85, 0xc6, 0x3d, 0xfc, 0x04, 0x03, 0xd8, 0x4c, 0xe3,
	0x9e, 0x07, 0x33, 0x09, 0x5c, 0xd1, 0xd3, 0x9d, 0xee, 0xc6, 0xa0, 0x5c, 0xc1, 0x90, 0xd7, 0xe0,
	0xa8, 0x1a, 0xec, 0x80, 0x72, 0x34, 0x25, 0x0e, 0xa1, 0xa9, 0xbd, 0xfe, 0xe8, 0x21, 0xec, 0xf5,
	0xdf, 0x00, 0xb3, 0xbc, 0x82, 0x8f, 0xf7, 0xd4, 0x46, 0x4a, 0x12, 0x3e, 0xc6, 0x48, 0xc5, 0xbb,
	0x69, 0xd7, 0xc1, 0x38, 0x46, 0xfb, 0x44, 0x63, 0xaf, 0x3c, 0x46, 0x7b, 0x78, 0xce, 0x18, 0x05,
	0xbd, 0xe5, 0x23, 0x8f, 0x96, 0x07, 0x18, 0x19, 0x90, 0x84, 0x4f, 0x3d, 0xb4, 0x3d, 0xe8, 0x61,
	0x13, 0x1b, 0xd5, 0x31, 0x16, 0x75, 0xf3, 0xc1, 0x2c, 0x7b, 0x87, 0x71, 0x87, 0xcf, 0x29, 0xff,
	0x1e, 0x62, 0x45, 0x73, 0x78, 0x47, 0xd2, 0x76, 0x6c, 0x13, 0x1b, 0x77, 0xa0, 0xe7, 0x3e, 0xdb,
	0xc1, 0x3a, 0xdb, 0x3b, 0x84, 0x11, 0xfb, 0x79, 0xf8, 0x13, 0x82, 0x96, 0x89, 0x7d, 0xf6, 0x20,
	0xe5, 0x10, 0x62, 0x9f, 0xd3, 0x29, 0x8a, 0xfd, 0x2b, 0x60, 0x7e, 0xe7, 0xbe, 0x8b, 0x3c, 0x0b,
	0x62, 0x14, 0xdc, 0x70, 0x51, 0x30, 0x7e, 0xc9, 0x25, 0x87, 0x73, 0xe2, 0xa2, 0xab, 0xa5, 0xd3,
	0xb8, 0x74, 0x3c, 0xd3, 0x30, 0xb1, 0xa6, 0x3b, 0x36, 0x34, 0x31, 0x33, 0xf7, 0x94, 0x3a, 0xc9,
	0x07, 0xd7, 0xd9, 0x98, 0xfc, 0x0c, 0x98, 0x08, 0xa4, 0xa0, 0x39, 0x65, 0x74, 0x80, 0x9c, 0x02,
	0x02, 0xc4, 0x26, 0x49, 0xe6, 0xd5, 0xb1, 0x64, 0x5e, 0x5d, 0x59, 0xef, 0xda, 0x3b, 0x43, 0x9d,
	0xd3, 0x0c, 0xf0, 0x70, 0xfe, 0xe5, 0x58, 0xc2, 0xb2, 0xca, 0x9f, 0x87, 0xc0, 0x99, 0x02, 0xcb,
	0x87, 0x79, 0x20, 0x6d, 0x49, 0x29, 0xcb, 0x92, 0x05, 0xdd, 0xc1, 0xe8, 0xfe, 0x2b, 0x88, 0xd7,
	0x03, 0xdf, 0x7f, 0x05, 0xe1, 0xcd, 0x3c, 0x88, 0x1b, 0x21, 0x3a, 0xaa, 0x97, 0xbe, 0xff, 0x0a,
	0x08, 0x89, 0x43, 0xf5, 0xb9, 0xb0, 0xbf, 0x60, 0x43, 0xd2, 0xde, 0x41, 0xba, 0x38, 0xa4, 0x88,
	0x6e, 0xc1, 0x06, 0x1f, 0x94, 0x3d, 0xf0, 0x40, 0x87, 0x65, 0x52, 0x5d, 0x73, 0x11, 0xd6, 0x69,
	0x5e, 0x0a, 0x13, 0x83, 0xe9, 0xe0, 0xd2, 0x99, 0xa1, 0x26, 0xa8, 0x6e, 0x72, 0xa2, 0xeb, 0x31,
	0x9a, 0x49, 0x1f, 0x19, 0x4d, 0xfa, 0xc8, 0xf2, 0xe7, 0x27, 0xc0, 0xd0, 0x86, 0x6f, 0xc8, 0x77,
	0xc1, 0x68, 0xf0, 0x86, 0x4f, 0xc9, 0x2b, 0xdf, 0xa2, 0xc7, 0x6f, 0xb5, 0x8b, 0xbd, 0x61, 0x42,
	0xc7, 0xd8, 0x03, 0xb3, 0xe9, 0xab, 0xc1, 0x4b, 0x05, 0x04, 0x52, 0xd0, 0xb5, 0x47, 0x07, 0x81,
	0x0e, 0x17, 0x7e, 0x05, 0xc8, 0x19, 0xef, 0xe2, 0x2e, 0x17, 0xd0, 0x4a, 0x83, 0xd7, 0xae, 0x0f,
	0x04, 0x1e, 0xae, 0xfd, 0x1d, 0x09, 0x2c, 0xe4, 0xdc, 0x66, 0x5d, 0x2d, 0xa0, 0x98, 0x8d, 0x52,
	0x7b, 0x62, 0x60, 0x94, 0xb8, 0xf6, 0xd3, 0x0f, 0xd7, 0x8a, 0xb4, 0x9f, 0x82, 0x2e, 0xd4, 0x7e,
	0xfe, 0x53, 0xb1, 0x1d, 0x30, 0xd9, 0xf5, 0xbc, 0xeb, 0x7c, 0x4f, 0x2a, 0x1c, 0xb0, 0xd6, 0xe8,
	0x13, 0x30, 0x5c, 0xe9, 0xdb, 0x12, 0x38, 0x9e, 0xfd, 0xd4, 0xea, 0x4a, 0x01, 0xa9, 0x4c, 0x8c,
	0xda, 0xe3, 0x83, 0x62, 0x74, 0x71, 0x91, 0xfd, 0xa8, 0xe9, 0x4a, 0x4f, 0x81, 0x06, 0xe1, 0xa2,
	0xf8, 0x01, 0x11, 0xf5, 0xbb, 0x9c, 0xa7, 0x3d, 0x45, 0x7e, 0x97, 0x8d, 0x52, 0xe8, 0x77, 0x3d,
	0x1e, 0xdd, 0xbc, 0x26, 0x81, 0xf9, 0xcc, 0x9b, 0xbb, 0x46, 0x4f, 0x0d, 0x77, 0x23, 0xd4, 0xfe,
	0x7f, 0x40, 0x84, 0x90, 0x85, 0x57, 0xc1, 0x5c, 0xd6, 0x95, 0x50, 0xbd, 0x88, 0x5e, 0x1a, 0xbe,
	0xf6, 0xd8, 0x60, 0xf0, 0xe1, 0xf2, 0x1a, 0x18, 0x8f, 0xae, 0x1b, 0xce, 0x16, 0x66, 0x30, 0x01,
	0x55, 0xbb, 0xd4, 0x0f, 0x54, 0xb8, 0xc0, 0x77, 0x25, 0x70, 0x22, 0xef, 0x29, 0xd2, 0x72, 0xef,
	0x8c, 0x91, 0xc4, 0xa9, 0xad, 0x0c, 0x8e, 0x13, 0xf2, 0x82, 0xc1, 0xb4, 0x8a, 0x0c, 0xd3, 0x27,
	0xc8, 0x7b, 0x81, 0x3d, 0x22, 0x97, 0x1f, 0x2e, 0x94, 0x25, 0x0e, 0x5a, 0xbb, 0xda, 0x37, 0x68,
	0x3c, 0xb7, 0xf3, 0x40, 0xe0, 0xe3, 0x22, 0xaf, 0x5d, 0xee, 0x19, 0x37, 0x71, 0xf0, 0xc2, 0xdc,
	0x9e, 0x06, 0x8f, 0x67, 0x36, 0x6a, 0xf2, 0x5d, 0x31, 0x5b, 0x98, 0xd9, 0xe2, 0x80, 0x85, 0x99,
	0x2d, 0x0e, 0x98, 0x27, 0xa5, 0xc8, 0xa4, 0xfd, 0x4a, 0x29, 0xf2, 0xe9, 0xf5, 0x81, 0xc0, 0xc3,
	0xb5, 0x5f, 0x06, 0x33, 0xc9, 0x5b, 0x9f, 0x8b, 0x85, 0x91, 0xd0, 0x05, 0x5b, 0x5b, 0xee, 0x1f,
	0x36, 0x5c, 0x92, 0x80, 0x63, 0xa9, 0x2b, 0x84, 0x47, 0x8a, 0xe8, 0x24, 0x80, 0x6b, 0xd7, 0x06,
	0x00, 0x8e, 0xc7, 0x69, 0xd4, 0x6f, 0x3f, 0xdb, 0x53, 0x59, 0x37, 0x9a, 0xb7, 0x6b, 0x97, 0xfa,
	0x81, 0x8a, 0xe7, 0xa1, 0xac, 0xb6, 0x6a, 0x51, 0x1e, 0xca, 0x80, 0x2f, 0xcc, 0x43, 0x45, 0x2d,
	0xca, 0x57, 0xc1, 0x5c, 0x56, 0xb7, 0xaf, 0xde, 0x53, 0x86, 0x2e, 0xf8, 0xc2, 0xe5, 0x8b, 0xda,
	0x6b, 0x6c, 0x23, 0xc8, 0xea, 0x89, 0x15, 0x6e, 0x04, 0x19, 0x08, 0xc5, 0x1b, 0x41, 0x51, 0x07,
	0xea, 0xfb, 0x12, 0xa8, 0xe6, 0x9e, 0x5c, 0xaf, 0xf5, 0x93, 0xf5, 0x12, 0x48, 0xb5, 0x2f, 0x95,
	0x40, 0xca, 0xa8, 0x14, 0x92, 0xad, 0xa0, 0x2b, 0xfd, 0x55, 0x5a, 0x11, 0x46, 0x1f, 0x95, 0x42,
	0x4e, 0xdf, 0xa6, 0x76, 0xf4, 0x35, 0x7a, 0x7a, 0x58, 0x7d, 0xea, 0xbd, 0x8f, 0x17, 0xa5, 0xf7,
	0x3f, 0x5e, 0x94, 0xfe, 0xfa, 0xf1, 0xa2, 0xf4, 0xd6, 0x27, 0x8b, 0x47, 0xde, 0xff, 0x64, 0xf1,
	0xc8, 0x9f, 0x3e, 0x59, 0x3c, 0xf2, 0x35, 0xf1, 0x67, 0x1b, 0x62, 0x81, 0xfd, 0xfb, 0xaf, 0x34,
	0x76, 0xaf, 0x35, 0xc8, 0x7d, 0x17, 0xf9, 0xd1, 0xb1, 0x71, 0x6b, 0x84, 0x1d, 0x57, 0xaf, 0xfd,
	0x37, 0x00, 0x00, 0xff, 0xff, 0xa6, 0x1b, 0xe3, 0xc1, 0x59, 0x35, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Deposit into a V2 vault
	Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error)
	// Request withdrawal (queue-based)
	RequestWithdrawal(ctx context.Context, in *MsgRequestWithdrawal, opts ...grpc.CallOption) (*MsgRequestWithdrawalResponse, error)
	// Set yield preference for a user's position
	SetYieldPreference(ctx context.Context, in *MsgSetYieldPreference, opts ...grpc.CallOption) (*MsgSetYieldPreferenceResponse, error)
	// Process withdrawal queue (admin only)
	ProcessWithdrawalQueue(ctx context.Context, in *MsgProcessWithdrawalQueue, opts ...grpc.CallOption) (*MsgProcessWithdrawalQueueResponse, error)
	// Update vault configuration (authority only)
	UpdateVaultConfig(ctx context.Context, in *MsgUpdateVaultConfig, opts ...grpc.CallOption) (*MsgUpdateVaultConfigResponse, error)
	// Update module parameters (authority only)
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// Create a new cross-chain route (authority only)
	CreateCrossChainRoute(ctx context.Context, in *MsgCreateCrossChainRoute, opts ...grpc.CallOption) (*MsgCreateCrossChainRouteResponse, error)
	// Update an existing cross-chain route (authority only)
	UpdateCrossChainRoute(ctx context.Context, in *MsgUpdateCrossChainRoute, opts ...grpc.CallOption) (*MsgUpdateCrossChainRouteResponse, error)
	// Disable a cross-chain route (authority only)
	DisableCrossChainRoute(ctx context.Context, in *MsgDisableCrossChainRoute, opts ...grpc.CallOption) (*MsgDisableCrossChainRouteResponse, error)
	// Create a remote position (spec-aligned)
	CreateRemotePosition(ctx context.Context, in *MsgCreateRemotePosition, opts ...grpc.CallOption) (*MsgCreateRemotePositionResponse, error)
	// Close a remote position (spec-aligned)
	CloseRemotePosition(ctx context.Context, in *MsgCloseRemotePosition, opts ...grpc.CallOption) (*MsgCloseRemotePositionResponse, error)
	// Rebalance across remote positions (spec-aligned)
	Rebalance(ctx context.Context, in *MsgRebalance, opts ...grpc.CallOption) (*MsgRebalanceResponse, error)
	// Process in-flight position (system operation)
	ProcessInFlightPosition(ctx context.Context, in *MsgProcessInFlightPosition, opts ...grpc.CallOption) (*MsgProcessInFlightPositionResponse, error)
	// Register a new oracle for a position (authority only)
	RegisterOracle(ctx context.Context, in *MsgRegisterOracle, opts ...grpc.CallOption) (*MsgRegisterOracleResponse, error)
	// Update oracle configuration (authority only)
	UpdateOracleConfig(ctx context.Context, in *MsgUpdateOracleConfig, opts ...grpc.CallOption) (*MsgUpdateOracleConfigResponse, error)
	// Remove an oracle from the system (authority only)
	RemoveOracle(ctx context.Context, in *MsgRemoveOracle, opts ...grpc.CallOption) (*MsgRemoveOracleResponse, error)
	// Update global oracle parameters (authority only)
	UpdateOracleParams(ctx context.Context, in *MsgUpdateOracleParams, opts ...grpc.CallOption) (*MsgUpdateOracleParamsResponse, error)
	// Claim a processed/claimable withdrawal
	ClaimWithdrawal(ctx context.Context, in *MsgClaimWithdrawal, opts ...grpc.CallOption) (*MsgClaimWithdrawalResponse, error)
	// Cancel a pending withdrawal request
	CancelWithdrawal(ctx context.Context, in *MsgCancelWithdrawal, opts ...grpc.CallOption) (*MsgCancelWithdrawalResponse, error)
	// Update NAV (authority or authorized updater)
	UpdateNAV(ctx context.Context, in *MsgUpdateNAV, opts ...grpc.CallOption) (*MsgUpdateNAVResponse, error)
	// Handle stale inflight fund record (authority only)
	HandleStaleInflight(ctx context.Context, in *MsgHandleStaleInflight, opts ...grpc.CallOption) (*MsgHandleStaleInflightResponse, error)
	// Update deposit limits (authority only)
	UpdateDepositLimits(ctx context.Context, in *MsgUpdateDepositLimits, opts ...grpc.CallOption) (*MsgUpdateDepositLimitsResponse, error)
	// Cleanup stale inflight fund (authority only)
	CleanupStaleInflight(ctx context.Context, in *MsgCleanupStaleInflight, opts ...grpc.CallOption) (*MsgCleanupStaleInflightResponse, error)
	// Process incoming warp route funds (system/hook only)
	ProcessIncomingWarpFunds(ctx context.Context, in *MsgProcessIncomingWarpFunds, opts ...grpc.CallOption) (*MsgProcessIncomingWarpFundsResponse, error)
	// Update vault accounting for yield distribution (vault manager only)
	UpdateVaultAccounting(ctx context.Context, in *MsgUpdateVaultAccounting, opts ...grpc.CallOption) (*MsgUpdateVaultAccountingResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error) {
	out := new(MsgDepositResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/Deposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RequestWithdrawal(ctx context.Context, in *MsgRequestWithdrawal, opts ...grpc.CallOption) (*MsgRequestWithdrawalResponse, error) {
	out := new(MsgRequestWithdrawalResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/RequestWithdrawal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetYieldPreference(ctx context.Context, in *MsgSetYieldPreference, opts ...grpc.CallOption) (*MsgSetYieldPreferenceResponse, error) {
	out := new(MsgSetYieldPreferenceResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/SetYieldPreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProcessWithdrawalQueue(ctx context.Context, in *MsgProcessWithdrawalQueue, opts ...grpc.CallOption) (*MsgProcessWithdrawalQueueResponse, error) {
	out := new(MsgProcessWithdrawalQueueResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/ProcessWithdrawalQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateVaultConfig(ctx context.Context, in *MsgUpdateVaultConfig, opts ...grpc.CallOption) (*MsgUpdateVaultConfigResponse, error) {
	out := new(MsgUpdateVaultConfigResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateVaultConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateCrossChainRoute(ctx context.Context, in *MsgCreateCrossChainRoute, opts ...grpc.CallOption) (*MsgCreateCrossChainRouteResponse, error) {
	out := new(MsgCreateCrossChainRouteResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/CreateCrossChainRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCrossChainRoute(ctx context.Context, in *MsgUpdateCrossChainRoute, opts ...grpc.CallOption) (*MsgUpdateCrossChainRouteResponse, error) {
	out := new(MsgUpdateCrossChainRouteResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateCrossChainRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DisableCrossChainRoute(ctx context.Context, in *MsgDisableCrossChainRoute, opts ...grpc.CallOption) (*MsgDisableCrossChainRouteResponse, error) {
	out := new(MsgDisableCrossChainRouteResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/DisableCrossChainRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateRemotePosition(ctx context.Context, in *MsgCreateRemotePosition, opts ...grpc.CallOption) (*MsgCreateRemotePositionResponse, error) {
	out := new(MsgCreateRemotePositionResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/CreateRemotePosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CloseRemotePosition(ctx context.Context, in *MsgCloseRemotePosition, opts ...grpc.CallOption) (*MsgCloseRemotePositionResponse, error) {
	out := new(MsgCloseRemotePositionResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/CloseRemotePosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Rebalance(ctx context.Context, in *MsgRebalance, opts ...grpc.CallOption) (*MsgRebalanceResponse, error) {
	out := new(MsgRebalanceResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/Rebalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProcessInFlightPosition(ctx context.Context, in *MsgProcessInFlightPosition, opts ...grpc.CallOption) (*MsgProcessInFlightPositionResponse, error) {
	out := new(MsgProcessInFlightPositionResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/ProcessInFlightPosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterOracle(ctx context.Context, in *MsgRegisterOracle, opts ...grpc.CallOption) (*MsgRegisterOracleResponse, error) {
	out := new(MsgRegisterOracleResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/RegisterOracle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateOracleConfig(ctx context.Context, in *MsgUpdateOracleConfig, opts ...grpc.CallOption) (*MsgUpdateOracleConfigResponse, error) {
	out := new(MsgUpdateOracleConfigResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateOracleConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveOracle(ctx context.Context, in *MsgRemoveOracle, opts ...grpc.CallOption) (*MsgRemoveOracleResponse, error) {
	out := new(MsgRemoveOracleResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/RemoveOracle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateOracleParams(ctx context.Context, in *MsgUpdateOracleParams, opts ...grpc.CallOption) (*MsgUpdateOracleParamsResponse, error) {
	out := new(MsgUpdateOracleParamsResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateOracleParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimWithdrawal(ctx context.Context, in *MsgClaimWithdrawal, opts ...grpc.CallOption) (*MsgClaimWithdrawalResponse, error) {
	out := new(MsgClaimWithdrawalResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/ClaimWithdrawal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelWithdrawal(ctx context.Context, in *MsgCancelWithdrawal, opts ...grpc.CallOption) (*MsgCancelWithdrawalResponse, error) {
	out := new(MsgCancelWithdrawalResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/CancelWithdrawal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateNAV(ctx context.Context, in *MsgUpdateNAV, opts ...grpc.CallOption) (*MsgUpdateNAVResponse, error) {
	out := new(MsgUpdateNAVResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateNAV", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) HandleStaleInflight(ctx context.Context, in *MsgHandleStaleInflight, opts ...grpc.CallOption) (*MsgHandleStaleInflightResponse, error) {
	out := new(MsgHandleStaleInflightResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/HandleStaleInflight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDepositLimits(ctx context.Context, in *MsgUpdateDepositLimits, opts ...grpc.CallOption) (*MsgUpdateDepositLimitsResponse, error) {
	out := new(MsgUpdateDepositLimitsResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateDepositLimits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CleanupStaleInflight(ctx context.Context, in *MsgCleanupStaleInflight, opts ...grpc.CallOption) (*MsgCleanupStaleInflightResponse, error) {
	out := new(MsgCleanupStaleInflightResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/CleanupStaleInflight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProcessIncomingWarpFunds(ctx context.Context, in *MsgProcessIncomingWarpFunds, opts ...grpc.CallOption) (*MsgProcessIncomingWarpFundsResponse, error) {
	out := new(MsgProcessIncomingWarpFundsResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/ProcessIncomingWarpFunds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateVaultAccounting(ctx context.Context, in *MsgUpdateVaultAccounting, opts ...grpc.CallOption) (*MsgUpdateVaultAccountingResponse, error) {
	out := new(MsgUpdateVaultAccountingResponse)
	err := c.cc.Invoke(ctx, "/noble.dollar.vaults.v2.Msg/UpdateVaultAccounting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Deposit into a V2 vault
	Deposit(context.Context, *MsgDeposit) (*MsgDepositResponse, error)
	// Request withdrawal (queue-based)
	RequestWithdrawal(context.Context, *MsgRequestWithdrawal) (*MsgRequestWithdrawalResponse, error)
	// Set yield preference for a user's position
	SetYieldPreference(context.Context, *MsgSetYieldPreference) (*MsgSetYieldPreferenceResponse, error)
	// Process withdrawal queue (admin only)
	ProcessWithdrawalQueue(context.Context, *MsgProcessWithdrawalQueue) (*MsgProcessWithdrawalQueueResponse, error)
	// Update vault configuration (authority only)
	UpdateVaultConfig(context.Context, *MsgUpdateVaultConfig) (*MsgUpdateVaultConfigResponse, error)
	// Update module parameters (authority only)
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// Create a new cross-chain route (authority only)
	CreateCrossChainRoute(context.Context, *MsgCreateCrossChainRoute) (*MsgCreateCrossChainRouteResponse, error)
	// Update an existing cross-chain route (authority only)
	UpdateCrossChainRoute(context.Context, *MsgUpdateCrossChainRoute) (*MsgUpdateCrossChainRouteResponse, error)
	// Disable a cross-chain route (authority only)
	DisableCrossChainRoute(context.Context, *MsgDisableCrossChainRoute) (*MsgDisableCrossChainRouteResponse, error)
	// Create a remote position (spec-aligned)
	CreateRemotePosition(context.Context, *MsgCreateRemotePosition) (*MsgCreateRemotePositionResponse, error)
	// Close a remote position (spec-aligned)
	CloseRemotePosition(context.Context, *MsgCloseRemotePosition) (*MsgCloseRemotePositionResponse, error)
	// Rebalance across remote positions (spec-aligned)
	Rebalance(context.Context, *MsgRebalance) (*MsgRebalanceResponse, error)
	// Process in-flight position (system operation)
	ProcessInFlightPosition(context.Context, *MsgProcessInFlightPosition) (*MsgProcessInFlightPositionResponse, error)
	// Register a new oracle for a position (authority only)
	RegisterOracle(context.Context, *MsgRegisterOracle) (*MsgRegisterOracleResponse, error)
	// Update oracle configuration (authority only)
	UpdateOracleConfig(context.Context, *MsgUpdateOracleConfig) (*MsgUpdateOracleConfigResponse, error)
	// Remove an oracle from the system (authority only)
	RemoveOracle(context.Context, *MsgRemoveOracle) (*MsgRemoveOracleResponse, error)
	// Update global oracle parameters (authority only)
	UpdateOracleParams(context.Context, *MsgUpdateOracleParams) (*MsgUpdateOracleParamsResponse, error)
	// Claim a processed/claimable withdrawal
	ClaimWithdrawal(context.Context, *MsgClaimWithdrawal) (*MsgClaimWithdrawalResponse, error)
	// Cancel a pending withdrawal request
	CancelWithdrawal(context.Context, *MsgCancelWithdrawal) (*MsgCancelWithdrawalResponse, error)
	// Update NAV (authority or authorized updater)
	UpdateNAV(context.Context, *MsgUpdateNAV) (*MsgUpdateNAVResponse, error)
	// Handle stale inflight fund record (authority only)
	HandleStaleInflight(context.Context, *MsgHandleStaleInflight) (*MsgHandleStaleInflightResponse, error)
	// Update deposit limits (authority only)
	UpdateDepositLimits(context.Context, *MsgUpdateDepositLimits) (*MsgUpdateDepositLimitsResponse, error)
	// Cleanup stale inflight fund (authority only)
	CleanupStaleInflight(context.Context, *MsgCleanupStaleInflight) (*MsgCleanupStaleInflightResponse, error)
	// Process incoming warp route funds (system/hook only)
	ProcessIncomingWarpFunds(context.Context, *MsgProcessIncomingWarpFunds) (*MsgProcessIncomingWarpFundsResponse, error)
	// Update vault accounting for yield distribution (vault manager only)
	UpdateVaultAccounting(context.Context, *MsgUpdateVaultAccounting) (*MsgUpdateVaultAccountingResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Deposit(ctx context.Context, req *MsgDeposit) (*MsgDepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (*UnimplementedMsgServer) RequestWithdrawal(ctx context.Context, req *MsgRequestWithdrawal) (*MsgRequestWithdrawalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestWithdrawal not implemented")
}
func (*UnimplementedMsgServer) SetYieldPreference(ctx context.Context, req *MsgSetYieldPreference) (*MsgSetYieldPreferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetYieldPreference not implemented")
}
func (*UnimplementedMsgServer) ProcessWithdrawalQueue(ctx context.Context, req *MsgProcessWithdrawalQueue) (*MsgProcessWithdrawalQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessWithdrawalQueue not implemented")
}
func (*UnimplementedMsgServer) UpdateVaultConfig(ctx context.Context, req *MsgUpdateVaultConfig) (*MsgUpdateVaultConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVaultConfig not implemented")
}
func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) CreateCrossChainRoute(ctx context.Context, req *MsgCreateCrossChainRoute) (*MsgCreateCrossChainRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCrossChainRoute not implemented")
}
func (*UnimplementedMsgServer) UpdateCrossChainRoute(ctx context.Context, req *MsgUpdateCrossChainRoute) (*MsgUpdateCrossChainRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCrossChainRoute not implemented")
}
func (*UnimplementedMsgServer) DisableCrossChainRoute(ctx context.Context, req *MsgDisableCrossChainRoute) (*MsgDisableCrossChainRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableCrossChainRoute not implemented")
}
func (*UnimplementedMsgServer) CreateRemotePosition(ctx context.Context, req *MsgCreateRemotePosition) (*MsgCreateRemotePositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRemotePosition not implemented")
}
func (*UnimplementedMsgServer) CloseRemotePosition(ctx context.Context, req *MsgCloseRemotePosition) (*MsgCloseRemotePositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseRemotePosition not implemented")
}
func (*UnimplementedMsgServer) Rebalance(ctx context.Context, req *MsgRebalance) (*MsgRebalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rebalance not implemented")
}
func (*UnimplementedMsgServer) ProcessInFlightPosition(ctx context.Context, req *MsgProcessInFlightPosition) (*MsgProcessInFlightPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessInFlightPosition not implemented")
}
func (*UnimplementedMsgServer) RegisterOracle(ctx context.Context, req *MsgRegisterOracle) (*MsgRegisterOracleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterOracle not implemented")
}
func (*UnimplementedMsgServer) UpdateOracleConfig(ctx context.Context, req *MsgUpdateOracleConfig) (*MsgUpdateOracleConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOracleConfig not implemented")
}
func (*UnimplementedMsgServer) RemoveOracle(ctx context.Context, req *MsgRemoveOracle) (*MsgRemoveOracleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveOracle not implemented")
}
func (*UnimplementedMsgServer) UpdateOracleParams(ctx context.Context, req *MsgUpdateOracleParams) (*MsgUpdateOracleParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOracleParams not implemented")
}
func (*UnimplementedMsgServer) ClaimWithdrawal(ctx context.Context, req *MsgClaimWithdrawal) (*MsgClaimWithdrawalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimWithdrawal not implemented")
}
func (*UnimplementedMsgServer) CancelWithdrawal(ctx context.Context, req *MsgCancelWithdrawal) (*MsgCancelWithdrawalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelWithdrawal not implemented")
}
func (*UnimplementedMsgServer) UpdateNAV(ctx context.Context, req *MsgUpdateNAV) (*MsgUpdateNAVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNAV not implemented")
}
func (*UnimplementedMsgServer) HandleStaleInflight(ctx context.Context, req *MsgHandleStaleInflight) (*MsgHandleStaleInflightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleStaleInflight not implemented")
}
func (*UnimplementedMsgServer) UpdateDepositLimits(ctx context.Context, req *MsgUpdateDepositLimits) (*MsgUpdateDepositLimitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDepositLimits not implemented")
}
func (*UnimplementedMsgServer) CleanupStaleInflight(ctx context.Context, req *MsgCleanupStaleInflight) (*MsgCleanupStaleInflightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanupStaleInflight not implemented")
}
func (*UnimplementedMsgServer) ProcessIncomingWarpFunds(ctx context.Context, req *MsgProcessIncomingWarpFunds) (*MsgProcessIncomingWarpFundsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessIncomingWarpFunds not implemented")
}
func (*UnimplementedMsgServer) UpdateVaultAccounting(ctx context.Context, req *MsgUpdateVaultAccounting) (*MsgUpdateVaultAccountingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVaultAccounting not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/Deposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Deposit(ctx, req.(*MsgDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RequestWithdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRequestWithdrawal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RequestWithdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/RequestWithdrawal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RequestWithdrawal(ctx, req.(*MsgRequestWithdrawal))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetYieldPreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetYieldPreference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetYieldPreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/SetYieldPreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetYieldPreference(ctx, req.(*MsgSetYieldPreference))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProcessWithdrawalQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProcessWithdrawalQueue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProcessWithdrawalQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/ProcessWithdrawalQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProcessWithdrawalQueue(ctx, req.(*MsgProcessWithdrawalQueue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateVaultConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateVaultConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateVaultConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateVaultConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateVaultConfig(ctx, req.(*MsgUpdateVaultConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateCrossChainRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateCrossChainRoute)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateCrossChainRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/CreateCrossChainRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateCrossChainRoute(ctx, req.(*MsgCreateCrossChainRoute))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCrossChainRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCrossChainRoute)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCrossChainRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateCrossChainRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCrossChainRoute(ctx, req.(*MsgUpdateCrossChainRoute))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DisableCrossChainRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDisableCrossChainRoute)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DisableCrossChainRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/DisableCrossChainRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DisableCrossChainRoute(ctx, req.(*MsgDisableCrossChainRoute))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateRemotePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateRemotePosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateRemotePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/CreateRemotePosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateRemotePosition(ctx, req.(*MsgCreateRemotePosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CloseRemotePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCloseRemotePosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CloseRemotePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/CloseRemotePosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CloseRemotePosition(ctx, req.(*MsgCloseRemotePosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Rebalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRebalance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Rebalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/Rebalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Rebalance(ctx, req.(*MsgRebalance))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProcessInFlightPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProcessInFlightPosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProcessInFlightPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/ProcessInFlightPosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProcessInFlightPosition(ctx, req.(*MsgProcessInFlightPosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterOracle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterOracle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterOracle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/RegisterOracle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterOracle(ctx, req.(*MsgRegisterOracle))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateOracleConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateOracleConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateOracleConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateOracleConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateOracleConfig(ctx, req.(*MsgUpdateOracleConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveOracle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveOracle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveOracle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/RemoveOracle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveOracle(ctx, req.(*MsgRemoveOracle))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateOracleParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateOracleParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateOracleParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateOracleParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateOracleParams(ctx, req.(*MsgUpdateOracleParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimWithdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimWithdrawal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimWithdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/ClaimWithdrawal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimWithdrawal(ctx, req.(*MsgClaimWithdrawal))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelWithdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelWithdrawal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelWithdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/CancelWithdrawal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelWithdrawal(ctx, req.(*MsgCancelWithdrawal))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateNAV_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateNAV)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateNAV(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateNAV",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateNAV(ctx, req.(*MsgUpdateNAV))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_HandleStaleInflight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgHandleStaleInflight)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).HandleStaleInflight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/HandleStaleInflight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).HandleStaleInflight(ctx, req.(*MsgHandleStaleInflight))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDepositLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDepositLimits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDepositLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateDepositLimits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDepositLimits(ctx, req.(*MsgUpdateDepositLimits))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CleanupStaleInflight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCleanupStaleInflight)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CleanupStaleInflight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/CleanupStaleInflight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CleanupStaleInflight(ctx, req.(*MsgCleanupStaleInflight))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProcessIncomingWarpFunds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProcessIncomingWarpFunds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProcessIncomingWarpFunds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/ProcessIncomingWarpFunds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProcessIncomingWarpFunds(ctx, req.(*MsgProcessIncomingWarpFunds))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateVaultAccounting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateVaultAccounting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateVaultAccounting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/noble.dollar.vaults.v2.Msg/UpdateVaultAccounting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateVaultAccounting(ctx, req.(*MsgUpdateVaultAccounting))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "noble.dollar.vaults.v2.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deposit",
			Handler:    _Msg_Deposit_Handler,
		},
		{
			MethodName: "RequestWithdrawal",
			Handler:    _Msg_RequestWithdrawal_Handler,
		},
		{
			MethodName: "SetYieldPreference",
			Handler:    _Msg_SetYieldPreference_Handler,
		},
		{
			MethodName: "ProcessWithdrawalQueue",
			Handler:    _Msg_ProcessWithdrawalQueue_Handler,
		},
		{
			MethodName: "UpdateVaultConfig",
			Handler:    _Msg_UpdateVaultConfig_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "CreateCrossChainRoute",
			Handler:    _Msg_CreateCrossChainRoute_Handler,
		},
		{
			MethodName: "UpdateCrossChainRoute",
			Handler:    _Msg_UpdateCrossChainRoute_Handler,
		},
		{
			MethodName: "DisableCrossChainRoute",
			Handler:    _Msg_DisableCrossChainRoute_Handler,
		},
		{
			MethodName: "CreateRemotePosition",
			Handler:    _Msg_CreateRemotePosition_Handler,
		},
		{
			MethodName: "CloseRemotePosition",
			Handler:    _Msg_CloseRemotePosition_Handler,
		},
		{
			MethodName: "Rebalance",
			Handler:    _Msg_Rebalance_Handler,
		},
		{
			MethodName: "ProcessInFlightPosition",
			Handler:    _Msg_ProcessInFlightPosition_Handler,
		},
		{
			MethodName: "RegisterOracle",
			Handler:    _Msg_RegisterOracle_Handler,
		},
		{
			MethodName: "UpdateOracleConfig",
			Handler:    _Msg_UpdateOracleConfig_Handler,
		},
		{
			MethodName: "RemoveOracle",
			Handler:    _Msg_RemoveOracle_Handler,
		},
		{
			MethodName: "UpdateOracleParams",
			Handler:    _Msg_UpdateOracleParams_Handler,
		},
		{
			MethodName: "ClaimWithdrawal",
			Handler:    _Msg_ClaimWithdrawal_Handler,
		},
		{
			MethodName: "CancelWithdrawal",
			Handler:    _Msg_CancelWithdrawal_Handler,
		},
		{
			MethodName: "UpdateNAV",
			Handler:    _Msg_UpdateNAV_Handler,
		},
		{
			MethodName: "HandleStaleInflight",
			Handler:    _Msg_HandleStaleInflight_Handler,
		},
		{
			MethodName: "UpdateDepositLimits",
			Handler:    _Msg_UpdateDepositLimits_Handler,
		},
		{
			MethodName: "CleanupStaleInflight",
			Handler:    _Msg_CleanupStaleInflight_Handler,
		},
		{
			MethodName: "ProcessIncomingWarpFunds",
			Handler:    _Msg_ProcessIncomingWarpFunds_Handler,
		},
		{
			MethodName: "UpdateVaultAccounting",
			Handler:    _Msg_UpdateVaultAccounting_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "noble/dollar/vaults/v2/tx.proto",
}

func (m *MsgDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReceiveYield {
		i--
		if m.ReceiveYield {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.AmountDeposited.Size()
		i -= size
		if _, err := m.AmountDeposited.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetYieldPreference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetYieldPreference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetYieldPreference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x18
	}
	if m.ReceiveYield {
		i--
		if m.ReceiveYield {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTx(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetYieldPreferenceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetYieldPreferenceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetYieldPreferenceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x18
	}
	if m.NewPreference {
		i--
		if m.NewPreference {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PreviousPreference {
		i--
		if m.PreviousPreference {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateVaultConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateVaultConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateVaultConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateVaultConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateVaultConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateVaultConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewConfig) > 0 {
		i -= len(m.NewConfig)
		copy(dAtA[i:], m.NewConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewConfig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousConfig) > 0 {
		i -= len(m.PreviousConfig)
		copy(dAtA[i:], m.PreviousConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PreviousConfig)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateCrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateCrossChainRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCrossChainRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCrossChainRouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RouteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RouteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCrossChainRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCrossChainRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCrossChainRouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewConfig) > 0 {
		i -= len(m.NewConfig)
		copy(dAtA[i:], m.NewConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewConfig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PreviousConfig) > 0 {
		i -= len(m.PreviousConfig)
		copy(dAtA[i:], m.PreviousConfig)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PreviousConfig)))
		i--
		dAtA[i] = 0x12
	}
	if m.RouteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableCrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableCrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableCrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RouteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisableCrossChainRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisableCrossChainRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisableCrossChainRouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AffectedPositions != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.AffectedPositions))
		i--
		dAtA[i] = 0x10
	}
	if m.RouteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessInFlightPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessInFlightPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessInFlightPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProviderTracking != nil {
		{
			size, err := m.ProviderTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.ResultAmount.Size()
		i -= size
		if _, err := m.ResultAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ResultStatus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ResultStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessInFlightPositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessInFlightPositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessInFlightPositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SharesAffected.Size()
		i -= size
		if _, err := m.SharesAffected.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AmountProcessed.Size()
		i -= size
		if _, err := m.AmountProcessed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.FinalStatus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.FinalStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestWithdrawal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestWithdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestWithdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestWithdrawalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestWithdrawalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestWithdrawalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedClaimableAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedClaimableAt):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintTx(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x22
	{
		size := m.YieldPortion.Size()
		i -= size
		if _, err := m.YieldPortion.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.AmountLocked.Size()
		i -= size
		if _, err := m.AmountLocked.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.RequestId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessWithdrawalQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessWithdrawalQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessWithdrawalQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxRequests != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MaxRequests))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessWithdrawalQueueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessWithdrawalQueueResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessWithdrawalQueueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemainingRequests != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RemainingRequests))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.TotalAmountDistributed.Size()
		i -= size
		if _, err := m.TotalAmountDistributed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalAmountProcessed.Size()
		i -= size
		if _, err := m.TotalAmountProcessed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.RequestsProcessed != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestsProcessed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateRemotePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateRemotePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateRemotePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinSharesOut.Size()
		i -= size
		if _, err := m.MinSharesOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ChainId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateRemotePositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateRemotePositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateRemotePositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedCompletion, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintTx(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x1a
	if m.RouteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x10
	}
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCloseRemotePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCloseRemotePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCloseRemotePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PartialAmount.Size()
		i -= size
		if _, err := m.PartialAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCloseRemotePositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCloseRemotePositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCloseRemotePositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedCompletion, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintTx(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x1a
	if m.Initiated {
		i--
		if m.Initiated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TargetAllocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetAllocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetAllocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetPercentage != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TargetPercentage))
		i--
		dAtA[i] = 0x10
	}
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRebalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRebalance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRebalance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TargetAllocations) > 0 {
		for iNdEx := len(m.TargetAllocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TargetAllocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRebalanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRebalanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRebalanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Summary) > 0 {
		i -= len(m.Summary)
		copy(dAtA[i:], m.Summary)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Summary)))
		i--
		dAtA[i] = 0x12
	}
	if m.OperationsInitiated != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OperationsInitiated))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimWithdrawal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimWithdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimWithdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Claimer) > 0 {
		i -= len(m.Claimer)
		copy(dAtA[i:], m.Claimer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Claimer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimWithdrawalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimWithdrawalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimWithdrawalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.FeesDeducted.Size()
		i -= size
		if _, err := m.FeesDeducted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.YieldAmount.Size()
		i -= size
		if _, err := m.YieldAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PrincipalAmount.Size()
		i -= size
		if _, err := m.PrincipalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.AmountClaimed.Size()
		i -= size
		if _, err := m.AmountClaimed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCancelWithdrawal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelWithdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelWithdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelWithdrawalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelWithdrawalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelWithdrawalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.AmountUnlocked.Size()
		i -= size
		if _, err := m.AmountUnlocked.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNAV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNAV) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNAV) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CircuitBreakerActive {
		i--
		if m.CircuitBreakerActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ChangeBps != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChangeBps))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.PreviousNav.Size()
		i -= size
		if _, err := m.PreviousNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.NewNav.Size()
		i -= size
		if _, err := m.NewNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNAVResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNAVResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNAVResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CircuitBreakerActive {
		i--
		if m.CircuitBreakerActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintTx(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x1a
	if m.ChangeBps != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChangeBps))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.AppliedNav.Size()
		i -= size
		if _, err := m.AppliedNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgHandleStaleInflight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgHandleStaleInflight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgHandleStaleInflight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if m.NewStatus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NewStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.InflightId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.InflightId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgHandleStaleInflightResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgHandleStaleInflightResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgHandleStaleInflightResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.HandledAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.HandledAt):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintTx(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x1a
	if m.FinalStatus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.FinalStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.InflightId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.InflightId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDepositLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDepositLimits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDepositLimits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Limits.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDepositLimitsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDepositLimitsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDepositLimitsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewLimits) > 0 {
		i -= len(m.NewLimits)
		copy(dAtA[i:], m.NewLimits)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewLimits)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousLimits) > 0 {
		i -= len(m.PreviousLimits)
		copy(dAtA[i:], m.PreviousLimits)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PreviousLimits)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCleanupStaleInflight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCleanupStaleInflight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCleanupStaleInflight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TransactionId) > 0 {
		i -= len(m.TransactionId)
		copy(dAtA[i:], m.TransactionId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TransactionId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.InflightId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.InflightId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCleanupStaleInflightResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCleanupStaleInflightResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCleanupStaleInflightResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n12, err12 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CleanedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CleanedAt):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintTx(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0x2a
	if m.RouteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.AmountReturned.Size()
		i -= size
		if _, err := m.AmountReturned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.TransactionId) > 0 {
		i -= len(m.TransactionId)
		copy(dAtA[i:], m.TransactionId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TransactionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.InflightId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.InflightId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateVaultAccounting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateVaultAccounting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateVaultAccounting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxPositions != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MaxPositions))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateVaultAccountingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateVaultAccountingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateVaultAccountingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NegativeYieldWarning) > 0 {
		i -= len(m.NegativeYieldWarning)
		copy(dAtA[i:], m.NegativeYieldWarning)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NegativeYieldWarning)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.NextUser) > 0 {
		i -= len(m.NextUser)
		copy(dAtA[i:], m.NextUser)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NextUser)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.YieldDistributed.Size()
		i -= size
		if _, err := m.YieldDistributed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.AppliedNav.Size()
		i -= size
		if _, err := m.AppliedNav.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.AccountingComplete {
		i--
		if m.AccountingComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.TotalPositions != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalPositions))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalPositionsProcessed != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalPositionsProcessed))
		i--
		dAtA[i] = 0x10
	}
	if m.PositionsProcessed != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionsProcessed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessIncomingWarpFunds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessIncomingWarpFunds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessIncomingWarpFunds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InflightId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.InflightId))
		i--
		dAtA[i] = 0x40
	}
	n13, err13 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ReceivedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ReceivedAt):])
	if err13 != nil {
		return 0, err13
	}
	i -= n13
	i = encodeVarintTx(dAtA, i, uint64(n13))
	i--
	dAtA[i] = 0x3a
	if m.OriginDomain != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OriginDomain))
		i--
		dAtA[i] = 0x30
	}
	if len(m.HyperlaneMessageId) > 0 {
		i -= len(m.HyperlaneMessageId)
		copy(dAtA[i:], m.HyperlaneMessageId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.HyperlaneMessageId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RouteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.AmountReceived.Size()
		i -= size
		if _, err := m.AmountReceived.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.TransactionId) > 0 {
		i -= len(m.TransactionId)
		copy(dAtA[i:], m.TransactionId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TransactionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Processor) > 0 {
		i -= len(m.Processor)
		copy(dAtA[i:], m.Processor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Processor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProcessIncomingWarpFundsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProcessIncomingWarpFundsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProcessIncomingWarpFundsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InflightId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.InflightId))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.UpdatedPendingDistribution.Size()
		i -= size
		if _, err := m.UpdatedPendingDistribution.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.AmountMatched {
		i--
		if m.AmountMatched {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.OriginalAmount.Size()
		i -= size
		if _, err := m.OriginalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.AmountCompleted.Size()
		i -= size
		if _, err := m.AmountCompleted.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RouteId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TransactionId) > 0 {
		i -= len(m.TransactionId)
		copy(dAtA[i:], m.TransactionId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TransactionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.ReceiveYield {
		n += 2
	}
	return n
}

func (m *MsgDepositResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountDeposited.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	return n
}

func (m *MsgSetYieldPreference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ReceiveYield {
		n += 2
	}
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	return n
}

func (m *MsgSetYieldPreferenceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreviousPreference {
		n += 2
	}
	if m.NewPreference {
		n += 2
	}
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	return n
}

func (m *MsgUpdateVaultConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Config.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateVaultConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateCrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Route.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateCrossChainRouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteId != 0 {
		n += 1 + sovTx(uint64(m.RouteId))
	}
	return n
}

func (m *MsgUpdateCrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RouteId != 0 {
		n += 1 + sovTx(uint64(m.RouteId))
	}
	l = m.Route.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateCrossChainRouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteId != 0 {
		n += 1 + sovTx(uint64(m.RouteId))
	}
	l = len(m.PreviousConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewConfig)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDisableCrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RouteId != 0 {
		n += 1 + sovTx(uint64(m.RouteId))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDisableCrossChainRouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteId != 0 {
		n += 1 + sovTx(uint64(m.RouteId))
	}
	if m.AffectedPositions != 0 {
		n += 1 + sovTx(uint64(m.AffectedPositions))
	}
	return n
}

func (m *MsgProcessInFlightPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	if m.ResultStatus != 0 {
		n += 1 + sovTx(uint64(m.ResultStatus))
	}
	l = m.ResultAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProviderTracking != nil {
		l = m.ProviderTracking.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgProcessInFlightPositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovTx(uint64(m.Nonce))
	}
	if m.FinalStatus != 0 {
		n += 1 + sovTx(uint64(m.FinalStatus))
	}
	l = m.AmountProcessed.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.SharesAffected.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRequestWithdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	return n
}

func (m *MsgRequestWithdrawalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != 0 {
		n += 1 + sovTx(uint64(m.RequestId))
	}
	l = m.AmountLocked.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.YieldPortion.Size()
	n += 1 + l + sovTx(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedClaimableAt)
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgProcessWithdrawalQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MaxRequests != 0 {
		n += 1 + sovTx(uint64(m.MaxRequests))
	}
	return n
}

func (m *MsgProcessWithdrawalQueueResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestsProcessed != 0 {
		n += 1 + sovTx(uint64(m.RequestsProcessed))
	}
	l = m.TotalAmountProcessed.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TotalAmountDistributed.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.RemainingRequests != 0 {
		n += 1 + sovTx(uint64(m.RemainingRequests))
	}
	return n
}

func (m *MsgCreateRemotePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ChainId != 0 {
		n += 1 + sovTx(uint64(m.ChainId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinSharesOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateRemotePositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	if m.RouteId != 0 {
		n += 1 + sovTx(uint64(m.RouteId))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion)
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCloseRemotePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	l = m.PartialAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCloseRemotePositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	if m.Initiated {
		n += 2
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedCompletion)
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *TargetAllocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	if m.TargetPercentage != 0 {
		n += 1 + sovTx(uint64(m.TargetPercentage))
	}
	return n
}

func (m *MsgRebalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.TargetAllocations) > 0 {
		for _, e := range m.TargetAllocations {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgRebalanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationsInitiated != 0 {
		n += 1 + sovTx(uint64(m.OperationsInitiated))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimWithdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Claimer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovTx(uint64(m.RequestId))
	}
	return n
}

func (m *MsgClaimWithdrawalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountClaimed.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.PrincipalAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.YieldAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.FeesDeducted.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCancelWithdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovTx(uint64(m.RequestId))
	}
	return n
}

func (m *MsgCancelWithdrawalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AmountUnlocked.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	return n
}

func (m *MsgUpdateNAV) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.NewNav.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.PreviousNav.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.ChangeBps != 0 {
		n += 1 + sovTx(uint64(m.ChangeBps))
	}
	if m.CircuitBreakerActive {
		n += 2
	}
	return n
}

func (m *MsgUpdateNAVResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AppliedNav.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.ChangeBps != 0 {
		n += 1 + sovTx(uint64(m.ChangeBps))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovTx(uint64(l))
	if m.CircuitBreakerActive {
		n += 2
	}
	return n
}

func (m *MsgHandleStaleInflight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.InflightId != 0 {
		n += 1 + sovTx(uint64(m.InflightId))
	}
	if m.NewStatus != 0 {
		n += 1 + sovTx(uint64(m.NewStatus))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgHandleStaleInflightResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InflightId != 0 {
		n += 1 + sovTx(uint64(m.InflightId))
	}
	if m.FinalStatus != 0 {
		n += 1 + sovTx(uint64(m.FinalStatus))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.HandledAt)
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateDepositLimits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Limits.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateDepositLimitsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousLimits)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewLimits)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCleanupStaleInflight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.InflightId != 0 {
		n += 1 + sovTx(uint64(m.InflightId))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCleanupStaleInflightResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InflightId != 0 {
		n += 1 + sovTx(uint64(m.InflightId))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.AmountReturned.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.RouteId != 0 {
		n += 1 + sovTx(uint64(m.RouteId))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CleanedAt)
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateVaultAccounting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MaxPositions != 0 {
		n += 1 + sovTx(uint64(m.MaxPositions))
	}
	return n
}

func (m *MsgUpdateVaultAccountingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionsProcessed != 0 {
		n += 1 + sovTx(uint64(m.PositionsProcessed))
	}
	if m.TotalPositionsProcessed != 0 {
		n += 1 + sovTx(uint64(m.TotalPositionsProcessed))
	}
	if m.TotalPositions != 0 {
		n += 1 + sovTx(uint64(m.TotalPositions))
	}
	if m.AccountingComplete {
		n += 2
	}
	l = m.AppliedNav.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.YieldDistributed.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.NextUser)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NegativeYieldWarning)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgProcessIncomingWarpFunds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Processor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.AmountReceived.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.RouteId != 0 {
		n += 1 + sovTx(uint64(m.RouteId))
	}
	l = len(m.HyperlaneMessageId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OriginDomain != 0 {
		n += 1 + sovTx(uint64(m.OriginDomain))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ReceivedAt)
	n += 1 + l + sovTx(uint64(l))
	if m.InflightId != 0 {
		n += 1 + sovTx(uint64(m.InflightId))
	}
	return n
}

func (m *MsgProcessIncomingWarpFundsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RouteId != 0 {
		n += 1 + sovTx(uint64(m.RouteId))
	}
	l = m.AmountCompleted.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.OriginalAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.AmountMatched {
		n += 2
	}
	l = m.UpdatedPendingDistribution.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.InflightId != 0 {
		n += 1 + sovTx(uint64(m.InflightId))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveYield", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiveYield = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountDeposited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountDeposited.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetYieldPreference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetYieldPreference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetYieldPreference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveYield", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReceiveYield = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetYieldPreferenceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetYieldPreferenceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetYieldPreferenceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousPreference", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreviousPreference = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPreference", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewPreference = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateVaultConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateVaultConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateVaultConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateVaultConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateVaultConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateVaultConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCrossChainRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCrossChainRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCrossChainRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCrossChainRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCrossChainRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCrossChainRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableCrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableCrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableCrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisableCrossChainRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisableCrossChainRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisableCrossChainRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedPositions", wireType)
			}
			m.AffectedPositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedPositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessInFlightPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessInFlightPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessInFlightPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultStatus", wireType)
			}
			m.ResultStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResultStatus |= InflightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResultAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderTracking == nil {
				m.ProviderTracking = &ProviderTrackingInfo{}
			}
			if err := m.ProviderTracking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessInFlightPositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessInFlightPositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessInFlightPositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalStatus", wireType)
			}
			m.FinalStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalStatus |= InflightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountProcessed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountProcessed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesAffected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesAffected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestWithdrawal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestWithdrawal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestWithdrawal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestWithdrawalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestWithdrawalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestWithdrawalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountLocked", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountLocked.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldPortion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YieldPortion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedClaimableAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedClaimableAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessWithdrawalQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessWithdrawalQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessWithdrawalQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequests", wireType)
			}
			m.MaxRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequests |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessWithdrawalQueueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessWithdrawalQueueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessWithdrawalQueueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestsProcessed", wireType)
			}
			m.RequestsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestsProcessed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmountProcessed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmountProcessed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmountDistributed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalAmountDistributed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingRequests", wireType)
			}
			m.RemainingRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainingRequests |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateRemotePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateRemotePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateRemotePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSharesOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinSharesOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateRemotePositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateRemotePositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateRemotePositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedCompletion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedCompletion, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCloseRemotePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCloseRemotePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCloseRemotePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartialAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCloseRemotePositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCloseRemotePositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCloseRemotePositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initiated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Initiated = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedCompletion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedCompletion, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetAllocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetAllocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetAllocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPercentage", wireType)
			}
			m.TargetPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPercentage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRebalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRebalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRebalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAllocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetAllocations = append(m.TargetAllocations, &TargetAllocation{})
			if err := m.TargetAllocations[len(m.TargetAllocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRebalanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRebalanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRebalanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationsInitiated", wireType)
			}
			m.OperationsInitiated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationsInitiated |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimWithdrawal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimWithdrawal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimWithdrawal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claimer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Claimer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimWithdrawalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimWithdrawalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimWithdrawalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountClaimed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountClaimed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrincipalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrincipalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YieldAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesDeducted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FeesDeducted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelWithdrawal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelWithdrawal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelWithdrawal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelWithdrawalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelWithdrawalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelWithdrawalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountUnlocked", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountUnlocked.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNAV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNAV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNAV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreviousNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeBps", wireType)
			}
			m.ChangeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeBps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreakerActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CircuitBreakerActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNAVResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNAVResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNAVResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppliedNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeBps", wireType)
			}
			m.ChangeBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeBps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircuitBreakerActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CircuitBreakerActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgHandleStaleInflight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgHandleStaleInflight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgHandleStaleInflight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflightId", wireType)
			}
			m.InflightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InflightId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewStatus", wireType)
			}
			m.NewStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewStatus |= InflightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgHandleStaleInflightResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgHandleStaleInflightResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgHandleStaleInflightResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflightId", wireType)
			}
			m.InflightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InflightId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalStatus", wireType)
			}
			m.FinalStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalStatus |= InflightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandledAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.HandledAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDepositLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDepositLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDepositLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Limits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDepositLimitsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDepositLimitsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDepositLimitsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousLimits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousLimits = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewLimits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewLimits = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCleanupStaleInflight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCleanupStaleInflight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCleanupStaleInflight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflightId", wireType)
			}
			m.InflightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InflightId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCleanupStaleInflightResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCleanupStaleInflightResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCleanupStaleInflightResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflightId", wireType)
			}
			m.InflightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InflightId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountReturned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountReturned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CleanedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateVaultAccounting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateVaultAccounting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateVaultAccounting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPositions", wireType)
			}
			m.MaxPositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPositions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateVaultAccountingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateVaultAccountingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateVaultAccountingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionsProcessed", wireType)
			}
			m.PositionsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionsProcessed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPositionsProcessed", wireType)
			}
			m.TotalPositionsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPositionsProcessed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPositions", wireType)
			}
			m.TotalPositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPositions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountingComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AccountingComplete = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedNav", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppliedNav.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YieldDistributed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YieldDistributed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeYieldWarning", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NegativeYieldWarning = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessIncomingWarpFunds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessIncomingWarpFunds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessIncomingWarpFunds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountReceived.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyperlaneMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HyperlaneMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginDomain", wireType)
			}
			m.OriginDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ReceivedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflightId", wireType)
			}
			m.InflightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InflightId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProcessIncomingWarpFundsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProcessIncomingWarpFundsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProcessIncomingWarpFundsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountCompleted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AmountCompleted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OriginalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountMatched", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AmountMatched = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedPendingDistribution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedPendingDistribution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InflightId", wireType)
			}
			m.InflightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InflightId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
