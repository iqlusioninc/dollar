// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/cross_chain.proto

package v2

import (
	cosmossdk_io_math "cosmossdk.io/math"
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_bcp_innovations_hyperlane_cosmos_util "github.com/bcp-innovations/hyperlane-cosmos/util"
	_ "github.com/bcp-innovations/hyperlane-cosmos/x/warp/types"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RemotePositionStatus represents the status of a remote position
type RemotePositionStatus int32

const (
	// Position is active and being tracked
	REMOTE_POSITION_ACTIVE RemotePositionStatus = 0
	// Position is being withdrawn from
	REMOTE_POSITION_WITHDRAWING RemotePositionStatus = 1
	// Position has been closed
	REMOTE_POSITION_CLOSED RemotePositionStatus = 2
	// Position is in error state
	REMOTE_POSITION_ERROR RemotePositionStatus = 3
)

var RemotePositionStatus_name = map[int32]string{
	0: "REMOTE_POSITION_ACTIVE",
	1: "REMOTE_POSITION_WITHDRAWING",
	2: "REMOTE_POSITION_CLOSED",
	3: "REMOTE_POSITION_ERROR",
}

var RemotePositionStatus_value = map[string]int32{
	"REMOTE_POSITION_ACTIVE":      0,
	"REMOTE_POSITION_WITHDRAWING": 1,
	"REMOTE_POSITION_CLOSED":      2,
	"REMOTE_POSITION_ERROR":       3,
}

func (x RemotePositionStatus) String() string {
	return proto.EnumName(RemotePositionStatus_name, int32(x))
}

func (RemotePositionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{0}
}

// OperationType represents the type of cross-chain operation
type OperationType int32

const (
	// Deposit operation
	OPERATION_TYPE_DEPOSIT OperationType = 0
	// Withdrawal operation
	OPERATION_TYPE_WITHDRAWAL OperationType = 1
	// Rebalance operation
	OPERATION_TYPE_REBALANCE OperationType = 2
)

var OperationType_name = map[int32]string{
	0: "OPERATION_TYPE_DEPOSIT",
	1: "OPERATION_TYPE_WITHDRAWAL",
	2: "OPERATION_TYPE_REBALANCE",
}

var OperationType_value = map[string]int32{
	"OPERATION_TYPE_DEPOSIT":    0,
	"OPERATION_TYPE_WITHDRAWAL": 1,
	"OPERATION_TYPE_REBALANCE":  2,
}

func (x OperationType) String() string {
	return proto.EnumName(OperationType_name, int32(x))
}

func (OperationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{1}
}

// InflightType defines the type of inflight funds
type InflightType int32

const (
	// USDN being deployed to a remote position
	INFLIGHT_DEPOSIT_TO_POSITION InflightType = 0
	// USDN returning from a remote position
	INFLIGHT_WITHDRAWAL_FROM_POSITION InflightType = 1
	// USDN moving between positions (via Noble)
	INFLIGHT_REBALANCE_BETWEEN_POSITIONS InflightType = 2
	// USDN awaiting deployment to positions
	INFLIGHT_PENDING_DEPLOYMENT InflightType = 3
	// USDN awaiting distribution to withdrawal queue
	INFLIGHT_PENDING_WITHDRAWAL_DISTRIBUTION InflightType = 4
)

var InflightType_name = map[int32]string{
	0: "INFLIGHT_DEPOSIT_TO_POSITION",
	1: "INFLIGHT_WITHDRAWAL_FROM_POSITION",
	2: "INFLIGHT_REBALANCE_BETWEEN_POSITIONS",
	3: "INFLIGHT_PENDING_DEPLOYMENT",
	4: "INFLIGHT_PENDING_WITHDRAWAL_DISTRIBUTION",
}

var InflightType_value = map[string]int32{
	"INFLIGHT_DEPOSIT_TO_POSITION":             0,
	"INFLIGHT_WITHDRAWAL_FROM_POSITION":        1,
	"INFLIGHT_REBALANCE_BETWEEN_POSITIONS":     2,
	"INFLIGHT_PENDING_DEPLOYMENT":              3,
	"INFLIGHT_PENDING_WITHDRAWAL_DISTRIBUTION": 4,
}

func (x InflightType) String() string {
	return proto.EnumName(InflightType_name, int32(x))
}

func (InflightType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{2}
}

// InflightStatus represents the status of inflight funds
type InflightStatus int32

const (
	// Transaction is pending
	INFLIGHT_PENDING InflightStatus = 0
	// Transaction is confirmed by provider
	INFLIGHT_CONFIRMED InflightStatus = 1
	// Transaction completed successfully
	INFLIGHT_COMPLETED InflightStatus = 2
	// Transaction failed
	INFLIGHT_FAILED InflightStatus = 3
	// Transaction timed out
	INFLIGHT_TIMEOUT InflightStatus = 4
)

var InflightStatus_name = map[int32]string{
	0: "INFLIGHT_PENDING",
	1: "INFLIGHT_CONFIRMED",
	2: "INFLIGHT_COMPLETED",
	3: "INFLIGHT_FAILED",
	4: "INFLIGHT_TIMEOUT",
}

var InflightStatus_value = map[string]int32{
	"INFLIGHT_PENDING":   0,
	"INFLIGHT_CONFIRMED": 1,
	"INFLIGHT_COMPLETED": 2,
	"INFLIGHT_FAILED":    3,
	"INFLIGHT_TIMEOUT":   4,
}

func (x InflightStatus) String() string {
	return proto.EnumName(InflightStatus_name, int32(x))
}

func (InflightStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{3}
}

// OracleUpdateStatus represents the status of an oracle update
type OracleUpdateStatus int32

const (
	// Update has been validated
	ORACLE_UPDATE_VALIDATED OracleUpdateStatus = 0
	// Update has been applied to position
	ORACLE_UPDATE_APPLIED OracleUpdateStatus = 1
	// Update was rejected (stale, invalid, etc.)
	ORACLE_UPDATE_REJECTED OracleUpdateStatus = 2
)

var OracleUpdateStatus_name = map[int32]string{
	0: "ORACLE_UPDATE_VALIDATED",
	1: "ORACLE_UPDATE_APPLIED",
	2: "ORACLE_UPDATE_REJECTED",
}

var OracleUpdateStatus_value = map[string]int32{
	"ORACLE_UPDATE_VALIDATED": 0,
	"ORACLE_UPDATE_APPLIED":   1,
	"ORACLE_UPDATE_REJECTED":  2,
}

func (x OracleUpdateStatus) String() string {
	return proto.EnumName(OracleUpdateStatus_name, int32(x))
}

func (OracleUpdateStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{4}
}

// ProviderType represents the cross-chain provider type
type ProviderType int32

const (
	// Hyperlane provider
	PROVIDER_TYPE_HYPERLANE ProviderType = 0
	// IBC provider
	PROVIDER_TYPE_IBC ProviderType = 1
)

var ProviderType_name = map[int32]string{
	0: "PROVIDER_TYPE_HYPERLANE",
	1: "PROVIDER_TYPE_IBC",
}

var ProviderType_value = map[string]int32{
	"PROVIDER_TYPE_HYPERLANE": 0,
	"PROVIDER_TYPE_IBC":       1,
}

func (x ProviderType) String() string {
	return proto.EnumName(ProviderType_name, int32(x))
}

func (ProviderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{5}
}

// CrossChainRoute defines a route for cross-chain operations
// Currently supports Hyperlane, with potential for future IBC support
type CrossChainRoute struct {
	// HypToken
	HyptokenId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=hyptoken_id,json=hyptokenId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"hyptoken_id"`
	// Reciever chain hook;
	ReceiverChainHook github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,2,opt,name=receiver_chain_hook,json=receiverChainHook,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"receiver_chain_hook"`
	// Vault
	RemotePositionAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,3,opt,name=remote_position_address,json=remotePositionAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"remote_position_address"`
	// Maximum value allowed inflight on this route
	MaxInflightValue cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=max_inflight_value,json=maxInflightValue,proto3,customtype=cosmossdk.io/math.Int" json:"max_inflight_value"`
}

func (m *CrossChainRoute) Reset()         { *m = CrossChainRoute{} }
func (m *CrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*CrossChainRoute) ProtoMessage()    {}
func (*CrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{0}
}
func (m *CrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainRoute.Merge(m, src)
}
func (m *CrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainRoute proto.InternalMessageInfo

// RemotePosition represents a position in an ERC-4626 compatible vault on another chain
type RemotePosition struct {
	// HypToken
	HyptokenId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=hyptoken_id,json=hyptokenId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"hyptoken_id"`
	// Address of the ERC-4626 compatible vault
	VaultAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,2,opt,name=vault_address,json=vaultAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"vault_address"`
	// Number of vault shares held
	SharesHeld cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares_held,json=sharesHeld,proto3,customtype=cosmossdk.io/math.Int" json:"shares_held"`
	// Principal amount initially deposited (in USDN)
	Principal cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=principal,proto3,customtype=cosmossdk.io/math.Int" json:"principal"`
	// Current share price from oracle
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
	// Total value of position (shares * price)
	TotalValue cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=total_value,json=totalValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_value"`
	// Last oracle update timestamp
	LastUpdate time.Time `protobuf:"bytes,7,opt,name=last_update,json=lastUpdate,proto3,stdtime" json:"last_update"`
	// Position status
	Status RemotePositionStatus `protobuf:"varint,8,opt,name=status,proto3,enum=noble.dollar.vaults.v2.RemotePositionStatus" json:"status,omitempty"`
	// Oracle configuration for this position
	OracleAddress string `protobuf:"bytes,9,opt,name=oracle_address,json=oracleAddress,proto3" json:"oracle_address,omitempty"`
	// Maximum staleness for oracle data (seconds)
	MaxStaleness int64 `protobuf:"varint,10,opt,name=max_staleness,json=maxStaleness,proto3" json:"max_staleness,omitempty"`
}

func (m *RemotePosition) Reset()         { *m = RemotePosition{} }
func (m *RemotePosition) String() string { return proto.CompactTextString(m) }
func (*RemotePosition) ProtoMessage()    {}
func (*RemotePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{1}
}
func (m *RemotePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemotePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemotePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemotePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemotePosition.Merge(m, src)
}
func (m *RemotePosition) XXX_Size() int {
	return m.Size()
}
func (m *RemotePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_RemotePosition.DiscardUnknown(m)
}

var xxx_messageInfo_RemotePosition proto.InternalMessageInfo

func (m *RemotePosition) GetLastUpdate() time.Time {
	if m != nil {
		return m.LastUpdate
	}
	return time.Time{}
}

func (m *RemotePosition) GetStatus() RemotePositionStatus {
	if m != nil {
		return m.Status
	}
	return REMOTE_POSITION_ACTIVE
}

func (m *RemotePosition) GetOracleAddress() string {
	if m != nil {
		return m.OracleAddress
	}
	return ""
}

func (m *RemotePosition) GetMaxStaleness() int64 {
	if m != nil {
		return m.MaxStaleness
	}
	return 0
}

// InflightFund represents funds in transit between Noble and remote positions
type InflightFund struct {
	// Unique identifier for this inflight transaction
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Transaction ID (Hyperlane message ID or IBC packet sequence)
	TransactionId string `protobuf:"bytes,2,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	// Amount in USDN (always USDN, never shares)
	Amount cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// Origin information
	//
	// Types that are valid to be assigned to Origin:
	//	*InflightFund_NobleOrigin
	//	*InflightFund_RemoteOrigin
	Origin isInflightFund_Origin `protobuf_oneof:"origin"`
	// Destination information
	//
	// Types that are valid to be assigned to Destination:
	//	*InflightFund_NobleDestination
	//	*InflightFund_RemoteDestination
	Destination isInflightFund_Destination `protobuf_oneof:"destination"`
	// When the operation was initiated
	InitiatedAt time.Time `protobuf:"bytes,8,opt,name=initiated_at,json=initiatedAt,proto3,stdtime" json:"initiated_at"`
	// Expected completion time
	ExpectedAt time.Time `protobuf:"bytes,9,opt,name=expected_at,json=expectedAt,proto3,stdtime" json:"expected_at"`
	// Current status
	Status InflightStatus `protobuf:"varint,10,opt,name=status,proto3,enum=noble.dollar.vaults.v2.InflightStatus" json:"status,omitempty"`
	// Value at initiation (for NAV calculation)
	ValueAtInitiation cosmossdk_io_math.Int `protobuf:"bytes,11,opt,name=value_at_initiation,json=valueAtInitiation,proto3,customtype=cosmossdk.io/math.Int" json:"value_at_initiation"`
	// Provider-specific tracking information
	ProviderTracking *ProviderTrackingInfo `protobuf:"bytes,12,opt,name=provider_tracking,json=providerTracking,proto3" json:"provider_tracking,omitempty"`
}

func (m *InflightFund) Reset()         { *m = InflightFund{} }
func (m *InflightFund) String() string { return proto.CompactTextString(m) }
func (*InflightFund) ProtoMessage()    {}
func (*InflightFund) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{2}
}
func (m *InflightFund) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InflightFund) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InflightFund.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InflightFund) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InflightFund.Merge(m, src)
}
func (m *InflightFund) XXX_Size() int {
	return m.Size()
}
func (m *InflightFund) XXX_DiscardUnknown() {
	xxx_messageInfo_InflightFund.DiscardUnknown(m)
}

var xxx_messageInfo_InflightFund proto.InternalMessageInfo

type isInflightFund_Origin interface {
	isInflightFund_Origin()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isInflightFund_Destination interface {
	isInflightFund_Destination()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InflightFund_NobleOrigin struct {
	NobleOrigin *NobleEndpoint `protobuf:"bytes,4,opt,name=noble_origin,json=nobleOrigin,proto3,oneof" json:"noble_origin,omitempty"`
}
type InflightFund_RemoteOrigin struct {
	RemoteOrigin *RemotePosition `protobuf:"bytes,5,opt,name=remote_origin,json=remoteOrigin,proto3,oneof" json:"remote_origin,omitempty"`
}
type InflightFund_NobleDestination struct {
	NobleDestination *NobleEndpoint `protobuf:"bytes,6,opt,name=noble_destination,json=nobleDestination,proto3,oneof" json:"noble_destination,omitempty"`
}
type InflightFund_RemoteDestination struct {
	RemoteDestination *RemotePosition `protobuf:"bytes,7,opt,name=remote_destination,json=remoteDestination,proto3,oneof" json:"remote_destination,omitempty"`
}

func (*InflightFund_NobleOrigin) isInflightFund_Origin()            {}
func (*InflightFund_RemoteOrigin) isInflightFund_Origin()           {}
func (*InflightFund_NobleDestination) isInflightFund_Destination()  {}
func (*InflightFund_RemoteDestination) isInflightFund_Destination() {}

func (m *InflightFund) GetOrigin() isInflightFund_Origin {
	if m != nil {
		return m.Origin
	}
	return nil
}
func (m *InflightFund) GetDestination() isInflightFund_Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *InflightFund) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *InflightFund) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *InflightFund) GetNobleOrigin() *NobleEndpoint {
	if x, ok := m.GetOrigin().(*InflightFund_NobleOrigin); ok {
		return x.NobleOrigin
	}
	return nil
}

func (m *InflightFund) GetRemoteOrigin() *RemotePosition {
	if x, ok := m.GetOrigin().(*InflightFund_RemoteOrigin); ok {
		return x.RemoteOrigin
	}
	return nil
}

func (m *InflightFund) GetNobleDestination() *NobleEndpoint {
	if x, ok := m.GetDestination().(*InflightFund_NobleDestination); ok {
		return x.NobleDestination
	}
	return nil
}

func (m *InflightFund) GetRemoteDestination() *RemotePosition {
	if x, ok := m.GetDestination().(*InflightFund_RemoteDestination); ok {
		return x.RemoteDestination
	}
	return nil
}

func (m *InflightFund) GetInitiatedAt() time.Time {
	if m != nil {
		return m.InitiatedAt
	}
	return time.Time{}
}

func (m *InflightFund) GetExpectedAt() time.Time {
	if m != nil {
		return m.ExpectedAt
	}
	return time.Time{}
}

func (m *InflightFund) GetStatus() InflightStatus {
	if m != nil {
		return m.Status
	}
	return INFLIGHT_PENDING
}

func (m *InflightFund) GetProviderTracking() *ProviderTrackingInfo {
	if m != nil {
		return m.ProviderTracking
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*InflightFund) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*InflightFund_NobleOrigin)(nil),
		(*InflightFund_RemoteOrigin)(nil),
		(*InflightFund_NobleDestination)(nil),
		(*InflightFund_RemoteDestination)(nil),
	}
}

// NobleEndpoint represents Noble as an origin or destination
type NobleEndpoint struct {
	// Purpose/context of the operation (deposit, withdrawal, rebalance)
	OperationType OperationType `protobuf:"varint,1,opt,name=operation_type,json=operationType,proto3,enum=noble.dollar.vaults.v2.OperationType" json:"operation_type,omitempty"`
}

func (m *NobleEndpoint) Reset()         { *m = NobleEndpoint{} }
func (m *NobleEndpoint) String() string { return proto.CompactTextString(m) }
func (*NobleEndpoint) ProtoMessage()    {}
func (*NobleEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{3}
}
func (m *NobleEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NobleEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NobleEndpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NobleEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NobleEndpoint.Merge(m, src)
}
func (m *NobleEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *NobleEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_NobleEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_NobleEndpoint proto.InternalMessageInfo

func (m *NobleEndpoint) GetOperationType() OperationType {
	if m != nil {
		return m.OperationType
	}
	return OPERATION_TYPE_DEPOSIT
}

// ProviderTrackingInfo contains provider-specific tracking data
type ProviderTrackingInfo struct {
	// Types that are valid to be assigned to TrackingInfo:
	//
	//	*ProviderTrackingInfo_HyperlaneTracking
	TrackingInfo isProviderTrackingInfo_TrackingInfo `protobuf_oneof:"tracking_info"`
}

func (m *ProviderTrackingInfo) Reset()         { *m = ProviderTrackingInfo{} }
func (m *ProviderTrackingInfo) String() string { return proto.CompactTextString(m) }
func (*ProviderTrackingInfo) ProtoMessage()    {}
func (*ProviderTrackingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{4}
}
func (m *ProviderTrackingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderTrackingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderTrackingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderTrackingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderTrackingInfo.Merge(m, src)
}
func (m *ProviderTrackingInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProviderTrackingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderTrackingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderTrackingInfo proto.InternalMessageInfo

type isProviderTrackingInfo_TrackingInfo interface {
	isProviderTrackingInfo_TrackingInfo()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProviderTrackingInfo_HyperlaneTracking struct {
	HyperlaneTracking *HyperlaneTrackingInfo `protobuf:"bytes,1,opt,name=hyperlane_tracking,json=hyperlaneTracking,proto3,oneof" json:"hyperlane_tracking,omitempty"`
}

func (*ProviderTrackingInfo_HyperlaneTracking) isProviderTrackingInfo_TrackingInfo() {}

func (m *ProviderTrackingInfo) GetTrackingInfo() isProviderTrackingInfo_TrackingInfo {
	if m != nil {
		return m.TrackingInfo
	}
	return nil
}

func (m *ProviderTrackingInfo) GetHyperlaneTracking() *HyperlaneTrackingInfo {
	if x, ok := m.GetTrackingInfo().(*ProviderTrackingInfo_HyperlaneTracking); ok {
		return x.HyperlaneTracking
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ProviderTrackingInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ProviderTrackingInfo_HyperlaneTracking)(nil),
	}
}

// HyperlaneTrackingInfo contains Hyperlane-specific tracking data
type HyperlaneTrackingInfo struct {
	// Hyperlane message ID
	MessageId []byte `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Origin domain
	OriginDomain uint32 `protobuf:"varint,2,opt,name=origin_domain,json=originDomain,proto3" json:"origin_domain,omitempty"`
	// Destination domain
	DestinationDomain uint32 `protobuf:"varint,3,opt,name=destination_domain,json=destinationDomain,proto3" json:"destination_domain,omitempty"`
	// Message nonce
	Nonce uint64 `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Transaction hash on origin chain
	OriginTxHash string `protobuf:"bytes,5,opt,name=origin_tx_hash,json=originTxHash,proto3" json:"origin_tx_hash,omitempty"`
	// Transaction hash on destination chain
	DestinationTxHash string `protobuf:"bytes,6,opt,name=destination_tx_hash,json=destinationTxHash,proto3" json:"destination_tx_hash,omitempty"`
	// Whether message has been processed
	Processed bool `protobuf:"varint,7,opt,name=processed,proto3" json:"processed,omitempty"`
}

func (m *HyperlaneTrackingInfo) Reset()         { *m = HyperlaneTrackingInfo{} }
func (m *HyperlaneTrackingInfo) String() string { return proto.CompactTextString(m) }
func (*HyperlaneTrackingInfo) ProtoMessage()    {}
func (*HyperlaneTrackingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{5}
}
func (m *HyperlaneTrackingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HyperlaneTrackingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HyperlaneTrackingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HyperlaneTrackingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HyperlaneTrackingInfo.Merge(m, src)
}
func (m *HyperlaneTrackingInfo) XXX_Size() int {
	return m.Size()
}
func (m *HyperlaneTrackingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HyperlaneTrackingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HyperlaneTrackingInfo proto.InternalMessageInfo

func (m *HyperlaneTrackingInfo) GetMessageId() []byte {
	if m != nil {
		return m.MessageId
	}
	return nil
}

func (m *HyperlaneTrackingInfo) GetOriginDomain() uint32 {
	if m != nil {
		return m.OriginDomain
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetOriginTxHash() string {
	if m != nil {
		return m.OriginTxHash
	}
	return ""
}

func (m *HyperlaneTrackingInfo) GetDestinationTxHash() string {
	if m != nil {
		return m.DestinationTxHash
	}
	return ""
}

func (m *HyperlaneTrackingInfo) GetProcessed() bool {
	if m != nil {
		return m.Processed
	}
	return false
}

// NAVOracleUpdate represents an oracle price update received via cross-chain messaging
type NAVOracleUpdate struct {
	// Position identifier this update is for
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Current share price
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
	// Number of shares held
	SharesHeld cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares_held,json=sharesHeld,proto3,customtype=cosmossdk.io/math.Int" json:"shares_held"`
	// Timestamp of the update
	Timestamp time.Time `protobuf:"bytes,4,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,5,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Message ID (Hyperlane message ID or IBC packet)
	MessageId string `protobuf:"bytes,6,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Update status
	Status OracleUpdateStatus `protobuf:"varint,7,opt,name=status,proto3,enum=noble.dollar.vaults.v2.OracleUpdateStatus" json:"status,omitempty"`
}

func (m *NAVOracleUpdate) Reset()         { *m = NAVOracleUpdate{} }
func (m *NAVOracleUpdate) String() string { return proto.CompactTextString(m) }
func (*NAVOracleUpdate) ProtoMessage()    {}
func (*NAVOracleUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{6}
}
func (m *NAVOracleUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NAVOracleUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NAVOracleUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NAVOracleUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NAVOracleUpdate.Merge(m, src)
}
func (m *NAVOracleUpdate) XXX_Size() int {
	return m.Size()
}
func (m *NAVOracleUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_NAVOracleUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_NAVOracleUpdate proto.InternalMessageInfo

func (m *NAVOracleUpdate) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *NAVOracleUpdate) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *NAVOracleUpdate) GetSourceChain() string {
	if m != nil {
		return m.SourceChain
	}
	return ""
}

func (m *NAVOracleUpdate) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

func (m *NAVOracleUpdate) GetStatus() OracleUpdateStatus {
	if m != nil {
		return m.Status
	}
	return ORACLE_UPDATE_VALIDATED
}

// PositionOracleConfig stores oracle configuration for a position
type PositionOracleConfig struct {
	// Unique position identifier
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Expected origin mailbox/channel
	OriginIdentifier string `protobuf:"bytes,2,opt,name=origin_identifier,json=originIdentifier,proto3" json:"origin_identifier,omitempty"`
	// Maximum age before data is considered stale (seconds)
	MaxStaleness int64 `protobuf:"varint,3,opt,name=max_staleness,json=maxStaleness,proto3" json:"max_staleness,omitempty"`
	// Authorized oracle contract address on remote chain
	OracleContract string `protobuf:"bytes,4,opt,name=oracle_contract,json=oracleContract,proto3" json:"oracle_contract,omitempty"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,5,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Last update timestamp
	LastUpdate time.Time `protobuf:"bytes,6,opt,name=last_update,json=lastUpdate,proto3,stdtime" json:"last_update"`
	// Provider type (HYPERLANE, IBC)
	ProviderType ProviderType `protobuf:"varint,7,opt,name=provider_type,json=providerType,proto3,enum=noble.dollar.vaults.v2.ProviderType" json:"provider_type,omitempty"`
}

func (m *PositionOracleConfig) Reset()         { *m = PositionOracleConfig{} }
func (m *PositionOracleConfig) String() string { return proto.CompactTextString(m) }
func (*PositionOracleConfig) ProtoMessage()    {}
func (*PositionOracleConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{7}
}
func (m *PositionOracleConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PositionOracleConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PositionOracleConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PositionOracleConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PositionOracleConfig.Merge(m, src)
}
func (m *PositionOracleConfig) XXX_Size() int {
	return m.Size()
}
func (m *PositionOracleConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PositionOracleConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PositionOracleConfig proto.InternalMessageInfo

func (m *PositionOracleConfig) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *PositionOracleConfig) GetOriginIdentifier() string {
	if m != nil {
		return m.OriginIdentifier
	}
	return ""
}

func (m *PositionOracleConfig) GetMaxStaleness() int64 {
	if m != nil {
		return m.MaxStaleness
	}
	return 0
}

func (m *PositionOracleConfig) GetOracleContract() string {
	if m != nil {
		return m.OracleContract
	}
	return ""
}

func (m *PositionOracleConfig) GetSourceChain() string {
	if m != nil {
		return m.SourceChain
	}
	return ""
}

func (m *PositionOracleConfig) GetLastUpdate() time.Time {
	if m != nil {
		return m.LastUpdate
	}
	return time.Time{}
}

func (m *PositionOracleConfig) GetProviderType() ProviderType {
	if m != nil {
		return m.ProviderType
	}
	return PROVIDER_TYPE_HYPERLANE
}

// CrossChainPositionSnapshot provides a snapshot of all cross-chain positions
type CrossChainPositionSnapshot struct {
	// Total value of all remote positions
	TotalRemoteValue cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_remote_value,json=totalRemoteValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_remote_value"`
	// Total value of inflight funds
	TotalInflightValue cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_inflight_value,json=totalInflightValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_inflight_value"`
	// Number of active remote positions
	ActivePositions int64 `protobuf:"varint,3,opt,name=active_positions,json=activePositions,proto3" json:"active_positions,omitempty"`
	// Number of positions with stale data
	StalePositions int64 `protobuf:"varint,4,opt,name=stale_positions,json=stalePositions,proto3" json:"stale_positions,omitempty"`
	// Snapshot block height
	BlockHeight int64 `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Breakdown by route
	ValueByRoute map[uint32]string `protobuf:"bytes,6,rep,name=value_by_route,json=valueByRoute,proto3" json:"value_by_route,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CrossChainPositionSnapshot) Reset()         { *m = CrossChainPositionSnapshot{} }
func (m *CrossChainPositionSnapshot) String() string { return proto.CompactTextString(m) }
func (*CrossChainPositionSnapshot) ProtoMessage()    {}
func (*CrossChainPositionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{8}
}
func (m *CrossChainPositionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainPositionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainPositionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainPositionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainPositionSnapshot.Merge(m, src)
}
func (m *CrossChainPositionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainPositionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainPositionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainPositionSnapshot proto.InternalMessageInfo

func (m *CrossChainPositionSnapshot) GetActivePositions() int64 {
	if m != nil {
		return m.ActivePositions
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetStalePositions() int64 {
	if m != nil {
		return m.StalePositions
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetValueByRoute() map[uint32]string {
	if m != nil {
		return m.ValueByRoute
	}
	return nil
}

// CrossChainConfig defines global configuration for cross-chain operations
type CrossChainConfig struct {
	// Maximum total remote position value as percentage of vault (basis points)
	MaxRemoteExposure int32 `protobuf:"varint,1,opt,name=max_remote_exposure,json=maxRemoteExposure,proto3" json:"max_remote_exposure,omitempty"`
	// Default operation timeout (seconds)
	DefaultTimeout int64 `protobuf:"varint,2,opt,name=default_timeout,json=defaultTimeout,proto3" json:"default_timeout,omitempty"`
	// Position update frequency (seconds)
	UpdateFrequency int64 `protobuf:"varint,3,opt,name=update_frequency,json=updateFrequency,proto3" json:"update_frequency,omitempty"`
	// Maximum number of remote positions
	MaxRemotePositions uint32 `protobuf:"varint,4,opt,name=max_remote_positions,json=maxRemotePositions,proto3" json:"max_remote_positions,omitempty"`
	// Allowed chains (can be Hyperlane domains or IBC chain IDs)
	AllowedChains []string `protobuf:"bytes,5,rep,name=allowed_chains,json=allowedChains,proto3" json:"allowed_chains,omitempty"`
	// Whether cross-chain operations are enabled
	Enabled bool `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Maximum duration funds can be inflight (seconds)
	MaxInflightDuration int64 `protobuf:"varint,7,opt,name=max_inflight_duration,json=maxInflightDuration,proto3" json:"max_inflight_duration,omitempty"`
	// Maximum total value allowed inflight
	MaxInflightValue cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=max_inflight_value,json=maxInflightValue,proto3,customtype=cosmossdk.io/math.Int" json:"max_inflight_value"`
	// Supported providers (currently only HYPERLANE)
	SupportedProviders []ProviderType `protobuf:"varint,9,rep,packed,name=supported_providers,json=supportedProviders,proto3,enum=noble.dollar.vaults.v2.ProviderType" json:"supported_providers,omitempty"`
}

func (m *CrossChainConfig) Reset()         { *m = CrossChainConfig{} }
func (m *CrossChainConfig) String() string { return proto.CompactTextString(m) }
func (*CrossChainConfig) ProtoMessage()    {}
func (*CrossChainConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{9}
}
func (m *CrossChainConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainConfig.Merge(m, src)
}
func (m *CrossChainConfig) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainConfig proto.InternalMessageInfo

func (m *CrossChainConfig) GetMaxRemoteExposure() int32 {
	if m != nil {
		return m.MaxRemoteExposure
	}
	return 0
}

func (m *CrossChainConfig) GetDefaultTimeout() int64 {
	if m != nil {
		return m.DefaultTimeout
	}
	return 0
}

func (m *CrossChainConfig) GetUpdateFrequency() int64 {
	if m != nil {
		return m.UpdateFrequency
	}
	return 0
}

func (m *CrossChainConfig) GetMaxRemotePositions() uint32 {
	if m != nil {
		return m.MaxRemotePositions
	}
	return 0
}

func (m *CrossChainConfig) GetAllowedChains() []string {
	if m != nil {
		return m.AllowedChains
	}
	return nil
}

func (m *CrossChainConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *CrossChainConfig) GetMaxInflightDuration() int64 {
	if m != nil {
		return m.MaxInflightDuration
	}
	return 0
}

func (m *CrossChainConfig) GetSupportedProviders() []ProviderType {
	if m != nil {
		return m.SupportedProviders
	}
	return nil
}

// StaleInflightAlert represents an alert for inflight funds exceeding expected duration
type StaleInflightAlert struct {
	// Route ID
	RouteId uint32 `protobuf:"varint,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Transaction ID
	TransactionId string `protobuf:"bytes,2,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	// Hours overdue
	HoursOverdue float64 `protobuf:"fixed64,3,opt,name=hours_overdue,json=hoursOverdue,proto3" json:"hours_overdue,omitempty"`
	// Alert timestamp
	Timestamp time.Time `protobuf:"bytes,4,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Amount stuck in transit
	Amount cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
}

func (m *StaleInflightAlert) Reset()         { *m = StaleInflightAlert{} }
func (m *StaleInflightAlert) String() string { return proto.CompactTextString(m) }
func (*StaleInflightAlert) ProtoMessage()    {}
func (*StaleInflightAlert) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{10}
}
func (m *StaleInflightAlert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaleInflightAlert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StaleInflightAlert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StaleInflightAlert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaleInflightAlert.Merge(m, src)
}
func (m *StaleInflightAlert) XXX_Size() int {
	return m.Size()
}
func (m *StaleInflightAlert) XXX_DiscardUnknown() {
	xxx_messageInfo_StaleInflightAlert.DiscardUnknown(m)
}

var xxx_messageInfo_StaleInflightAlert proto.InternalMessageInfo

func (m *StaleInflightAlert) GetRouteId() uint32 {
	if m != nil {
		return m.RouteId
	}
	return 0
}

func (m *StaleInflightAlert) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *StaleInflightAlert) GetHoursOverdue() float64 {
	if m != nil {
		return m.HoursOverdue
	}
	return 0
}

func (m *StaleInflightAlert) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v2.RemotePositionStatus", RemotePositionStatus_name, RemotePositionStatus_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.OperationType", OperationType_name, OperationType_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.InflightType", InflightType_name, InflightType_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.InflightStatus", InflightStatus_name, InflightStatus_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.OracleUpdateStatus", OracleUpdateStatus_name, OracleUpdateStatus_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.ProviderType", ProviderType_name, ProviderType_value)
	proto.RegisterType((*CrossChainRoute)(nil), "noble.dollar.vaults.v2.CrossChainRoute")
	proto.RegisterType((*RemotePosition)(nil), "noble.dollar.vaults.v2.RemotePosition")
	proto.RegisterType((*InflightFund)(nil), "noble.dollar.vaults.v2.InflightFund")
	proto.RegisterType((*NobleEndpoint)(nil), "noble.dollar.vaults.v2.NobleEndpoint")
	proto.RegisterType((*ProviderTrackingInfo)(nil), "noble.dollar.vaults.v2.ProviderTrackingInfo")
	proto.RegisterType((*HyperlaneTrackingInfo)(nil), "noble.dollar.vaults.v2.HyperlaneTrackingInfo")
	proto.RegisterType((*NAVOracleUpdate)(nil), "noble.dollar.vaults.v2.NAVOracleUpdate")
	proto.RegisterType((*PositionOracleConfig)(nil), "noble.dollar.vaults.v2.PositionOracleConfig")
	proto.RegisterType((*CrossChainPositionSnapshot)(nil), "noble.dollar.vaults.v2.CrossChainPositionSnapshot")
	proto.RegisterMapType((map[uint32]string)(nil), "noble.dollar.vaults.v2.CrossChainPositionSnapshot.ValueByRouteEntry")
	proto.RegisterType((*CrossChainConfig)(nil), "noble.dollar.vaults.v2.CrossChainConfig")
	proto.RegisterType((*StaleInflightAlert)(nil), "noble.dollar.vaults.v2.StaleInflightAlert")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v2/cross_chain.proto", fileDescriptor_4abec74535b2c22a)
}

var fileDescriptor_4abec74535b2c22a = []byte{
	// 2091 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4b, 0x73, 0x1b, 0x59,
	0xf5, 0x57, 0x4b, 0xb6, 0x63, 0x1f, 0x3d, 0xdc, 0xba, 0xb6, 0x67, 0x14, 0x27, 0xb1, 0x1d, 0x25,
	0xf9, 0xff, 0x4d, 0x98, 0x48, 0x83, 0xa7, 0x8a, 0xa2, 0xa0, 0x80, 0xd2, 0xa3, 0x1d, 0xf5, 0x94,
	0x2c, 0x89, 0x6b, 0x25, 0xa9, 0x50, 0x05, 0x4d, 0x5b, 0x7d, 0x2d, 0x35, 0x6e, 0xf5, 0x6d, 0xba,
	0x5b, 0x1a, 0x0b, 0xb6, 0x54, 0xcd, 0xb0, 0xcb, 0x82, 0x6f, 0xc0, 0x66, 0x96, 0x2c, 0xf8, 0x10,
	0xc3, 0x6e, 0x8a, 0x05, 0x45, 0xb1, 0x18, 0xa8, 0x64, 0x31, 0x5f, 0x80, 0x3d, 0xd4, 0x7d, 0x74,
	0xeb, 0xe1, 0xb8, 0xc6, 0x31, 0x2e, 0x36, 0x2e, 0xf5, 0xef, 0x9e, 0xfb, 0x3b, 0xe7, 0xde, 0x73,
	0xee, 0x79, 0x18, 0xf6, 0x5d, 0x7a, 0xe2, 0x90, 0xb2, 0x45, 0x1d, 0xc7, 0xf4, 0xcb, 0x63, 0x73,
	0xe4, 0x84, 0x41, 0x79, 0x7c, 0x50, 0xee, 0xf9, 0x34, 0x08, 0x8c, 0xde, 0xc0, 0xb4, 0xdd, 0x92,
	0xe7, 0xd3, 0x90, 0xa2, 0xf7, 0xb8, 0x64, 0x49, 0x48, 0x96, 0x84, 0x64, 0x69, 0x7c, 0xb0, 0x9d,
	0x37, 0x87, 0xb6, 0x4b, 0xcb, 0xfc, 0xaf, 0x10, 0xdd, 0xbe, 0xdd, 0xa3, 0xc1, 0x90, 0x06, 0x06,
	0xff, 0x2a, 0x8b, 0x0f, 0xb9, 0xb4, 0xd9, 0xa7, 0x7d, 0x2a, 0x70, 0xf6, 0x4b, 0xa2, 0xbb, 0x7d,
	0x4a, 0xfb, 0x0e, 0x29, 0xf3, 0xaf, 0x93, 0xd1, 0x69, 0x39, 0xb4, 0x87, 0x24, 0x08, 0xcd, 0xa1,
	0x27, 0x05, 0xee, 0x0d, 0x26, 0x1e, 0xf1, 0x1d, 0xd3, 0x25, 0xe5, 0x4f, 0x4c, 0xdf, 0x2b, 0x8f,
	0xbf, 0x53, 0x0e, 0x27, 0x1e, 0x91, 0xac, 0xc5, 0x3f, 0xa7, 0x60, 0xbd, 0xc6, 0x2c, 0xae, 0x31,
	0x83, 0x31, 0x1d, 0x85, 0x04, 0x59, 0x90, 0x1e, 0x4c, 0xbc, 0x90, 0x9e, 0x11, 0xd7, 0xb0, 0xad,
	0x82, 0xb2, 0xa7, 0xec, 0xaf, 0x55, 0x6b, 0x5f, 0x7c, 0xb5, 0x9b, 0xf8, 0xfb, 0x57, 0xbb, 0x3f,
	0xe8, 0xdb, 0xe1, 0x60, 0x74, 0x52, 0xea, 0xd1, 0x61, 0xf9, 0xa4, 0xe7, 0x3d, 0xb1, 0x5d, 0x97,
	0x8e, 0xcd, 0xd0, 0xa6, 0x6e, 0x50, 0x8e, 0x55, 0x3d, 0x11, 0x96, 0x97, 0x47, 0xa1, 0xed, 0x94,
	0x1a, 0xe4, 0xbc, 0x62, 0x59, 0x3e, 0x09, 0x02, 0x0c, 0x11, 0xaf, 0x6e, 0xa1, 0x00, 0x36, 0x7c,
	0xd2, 0x23, 0xf6, 0x98, 0xf8, 0xe2, 0xb6, 0x8c, 0x01, 0xa5, 0x67, 0x85, 0xe4, 0xcd, 0x69, 0xcb,
	0x47, 0xfc, 0xfc, 0x6c, 0x0d, 0x4a, 0xcf, 0xd0, 0x6f, 0xe0, 0x7d, 0x9f, 0x0c, 0x69, 0x48, 0x0c,
	0x8f, 0x06, 0x36, 0xe3, 0x31, 0x4c, 0x21, 0x5d, 0x48, 0xdd, 0x9c, 0xe2, 0x2d, 0xa1, 0xa3, 0x23,
	0x55, 0x48, 0x18, 0xfd, 0x1c, 0xd0, 0xd0, 0x3c, 0x37, 0x6c, 0xf7, 0xd4, 0xb1, 0xfb, 0x83, 0xd0,
	0x18, 0x9b, 0xce, 0x88, 0x14, 0x96, 0xb8, 0xde, 0x0f, 0xa5, 0xde, 0x2d, 0x41, 0x19, 0x58, 0x67,
	0x25, 0x9b, 0x96, 0x87, 0x66, 0x38, 0x28, 0xe9, 0x6e, 0xf8, 0x97, 0x3f, 0x3d, 0x01, 0x19, 0x0c,
	0xba, 0x1b, 0x7e, 0xfe, 0xf5, 0x1f, 0x1f, 0x2b, 0x58, 0x1d, 0x9a, 0xe7, 0xba, 0xa4, 0x7a, 0xce,
	0x98, 0x8a, 0x9f, 0xad, 0x40, 0x0e, 0xcf, 0x69, 0xfe, 0x1f, 0xb9, 0x72, 0x00, 0x59, 0x1e, 0xd5,
	0xf1, 0x5d, 0x32, 0x27, 0x66, 0x6e, 0x46, 0x4f, 0x86, 0x33, 0x47, 0x57, 0xf8, 0x13, 0x48, 0x07,
	0x03, 0xd3, 0x27, 0x81, 0x31, 0x20, 0x8e, 0x25, 0x7d, 0xf6, 0xee, 0x77, 0x07, 0x82, 0xa4, 0x41,
	0x1c, 0x0b, 0xb5, 0x60, 0xcd, 0xf3, 0x6d, 0xb7, 0x67, 0x7b, 0xa6, 0x73, 0x6d, 0x67, 0x4c, 0x29,
	0xd0, 0x0b, 0x69, 0xa2, 0xe1, 0xf9, 0x76, 0x8f, 0x14, 0x96, 0x39, 0xe3, 0x77, 0x25, 0xe3, 0x9d,
	0x8b, 0x8c, 0x4d, 0xd2, 0x37, 0x7b, 0x93, 0x3a, 0xe9, 0xcd, 0xf0, 0xd6, 0x49, 0x6f, 0xd6, 0xd0,
	0x0e, 0x63, 0x62, 0x67, 0x0f, 0x69, 0x68, 0x3a, 0x32, 0x6e, 0x56, 0xae, 0x7b, 0x76, 0x4e, 0xc2,
	0x23, 0x06, 0x69, 0x90, 0x76, 0xcc, 0x20, 0x34, 0x46, 0x9e, 0x65, 0x86, 0xa4, 0x70, 0x6b, 0x4f,
	0xd9, 0x4f, 0x1f, 0x6c, 0x97, 0x44, 0x4e, 0x29, 0x45, 0x39, 0xa5, 0xd4, 0x8d, 0x72, 0x4a, 0x75,
	0x95, 0xa9, 0x7b, 0xf5, 0x8f, 0x5d, 0x05, 0x03, 0xdb, 0xf8, 0x8c, 0xef, 0x43, 0x75, 0x58, 0x09,
	0x42, 0x33, 0x1c, 0x05, 0x85, 0xd5, 0x3d, 0x65, 0x3f, 0x77, 0xf0, 0x41, 0xe9, 0xed, 0x19, 0xaf,
	0x34, 0x1f, 0x9d, 0xc7, 0x7c, 0x0f, 0x96, 0x7b, 0xd1, 0x23, 0xc8, 0x51, 0xdf, 0xec, 0x39, 0x24,
	0x0e, 0xa3, 0x35, 0x76, 0x44, 0x9c, 0x15, 0x68, 0x14, 0x02, 0x0f, 0x20, 0xcb, 0x5e, 0x51, 0x10,
	0x9a, 0x0e, 0x71, 0x99, 0x14, 0xec, 0x29, 0xfb, 0x29, 0x9c, 0x19, 0x9a, 0xe7, 0xc7, 0x11, 0x56,
	0xfc, 0xf7, 0x0a, 0x64, 0xa2, 0xc7, 0x71, 0x38, 0x72, 0x2d, 0x94, 0x83, 0xa4, 0x8c, 0xff, 0x25,
	0x9c, 0xb4, 0x2d, 0xa6, 0x2c, 0xf4, 0x4d, 0x37, 0x30, 0x7b, 0x3c, 0x09, 0xd8, 0x96, 0x48, 0x3c,
	0x38, 0x3b, 0x83, 0xea, 0x16, 0x6a, 0xc0, 0x8a, 0x39, 0xa4, 0x23, 0x37, 0xbc, 0x76, 0xa8, 0xc9,
	0xfd, 0xe8, 0x63, 0xc8, 0xf0, 0x4b, 0x31, 0xa8, 0x6f, 0xf7, 0x6d, 0x97, 0x47, 0x5a, 0xfa, 0xe0,
	0xd1, 0x65, 0x37, 0xd5, 0x62, 0xb0, 0xe6, 0x5a, 0x1e, 0xb5, 0xdd, 0xb0, 0x91, 0xc0, 0x69, 0x2e,
	0xd7, 0xe6, 0x7b, 0xd1, 0x11, 0x64, 0x65, 0x16, 0x93, 0x64, 0xcb, 0x9c, 0xec, 0xff, 0xae, 0x76,
	0xed, 0x8d, 0x04, 0xce, 0x88, 0xed, 0x92, 0xae, 0x0b, 0x79, 0x61, 0x9a, 0x45, 0x82, 0xd0, 0x76,
	0xf9, 0xcb, 0xe4, 0xe1, 0x75, 0x65, 0xfb, 0x14, 0xac, 0x72, 0xb9, 0xfa, 0x94, 0x00, 0xbd, 0x00,
	0x24, 0x8d, 0x9c, 0xa5, 0xbd, 0xf5, 0x4e, 0x96, 0x2a, 0x2c, 0x87, 0x33, 0x64, 0x96, 0xf8, 0x29,
	0x64, 0x6c, 0xd7, 0x0e, 0x6d, 0x33, 0x24, 0x96, 0x61, 0x86, 0x3c, 0xe6, 0xae, 0x1a, 0xb5, 0xe9,
	0x78, 0x67, 0x25, 0x64, 0xd1, 0x4f, 0xce, 0x3d, 0xd2, 0x93, 0x3c, 0x6b, 0xef, 0x12, 0xfd, 0xd1,
	0xc6, 0x4a, 0x88, 0x7e, 0x14, 0x47, 0x3f, 0xf0, 0xe8, 0xbf, 0xf4, 0x70, 0x51, 0x40, 0x2e, 0xc4,
	0xfd, 0x2f, 0x60, 0x83, 0xbf, 0x68, 0xc3, 0x0c, 0x0d, 0x69, 0x1e, 0xbb, 0xa9, 0xf4, 0x35, 0x03,
	0x2e, 0xcf, 0xc9, 0x2a, 0xa1, 0x1e, 0x53, 0xa1, 0x97, 0x90, 0xf7, 0x7c, 0x3a, 0xb6, 0x2d, 0xe2,
	0x1b, 0xa1, 0x6f, 0xf6, 0xce, 0x6c, 0xb7, 0x5f, 0xc8, 0xf0, 0xe3, 0x5e, 0xfa, 0x54, 0x3b, 0x72,
	0x43, 0x57, 0xca, 0xeb, 0xee, 0x29, 0xc5, 0xaa, 0xb7, 0x80, 0x56, 0x57, 0x61, 0x45, 0xc4, 0x60,
	0x35, 0x0b, 0xe9, 0x19, 0x47, 0x17, 0x7f, 0x06, 0xd9, 0xb9, 0x18, 0x41, 0x4d, 0xc8, 0x51, 0x8f,
	0xf8, 0x7c, 0xd5, 0x60, 0x2d, 0x08, 0x7f, 0x8d, 0xb9, 0xcb, 0x43, 0xac, 0x1d, 0x49, 0x77, 0x27,
	0x1e, 0xc1, 0x59, 0x3a, 0xfb, 0x59, 0xfc, 0x54, 0x81, 0xcd, 0xb7, 0x99, 0xc8, 0x8a, 0x6c, 0x5c,
	0x53, 0xa6, 0x87, 0x55, 0xf8, 0x61, 0x9f, 0x5c, 0xa6, 0xaa, 0x11, 0xed, 0x98, 0xa5, 0x6a, 0x24,
	0x70, 0x7e, 0xb0, 0xb8, 0x50, 0x5d, 0x87, 0x6c, 0xc4, 0xca, 0x2a, 0x39, 0x2d, 0xfe, 0x3e, 0x09,
	0x5b, 0x6f, 0xdd, 0x8f, 0xee, 0x01, 0x0c, 0x49, 0x10, 0x98, 0x7d, 0x12, 0xd5, 0xde, 0x0c, 0x5e,
	0x93, 0x88, 0x6e, 0xb1, 0x44, 0x26, 0xae, 0xce, 0xb0, 0xe8, 0xd0, 0xb4, 0x5d, 0x9e, 0x81, 0xb2,
	0x38, 0x23, 0xc0, 0x3a, 0xc7, 0xd0, 0x13, 0x40, 0x33, 0xb7, 0x1a, 0x49, 0xa6, 0xb8, 0x64, 0x7e,
	0x66, 0x45, 0x8a, 0x6f, 0xc2, 0xb2, 0x4b, 0xdd, 0x9e, 0xe8, 0x2a, 0x96, 0xb0, 0xf8, 0x40, 0x0f,
	0x59, 0x66, 0xe5, 0x9a, 0xc2, 0x73, 0x63, 0x60, 0x06, 0x03, 0x51, 0x95, 0x22, 0x55, 0xdd, 0xf3,
	0x86, 0x19, 0x0c, 0x50, 0x09, 0x36, 0x66, 0x55, 0x45, 0xa2, 0xbc, 0xce, 0xcc, 0xe9, 0x92, 0xf2,
	0x77, 0x59, 0xe1, 0xa4, 0x3d, 0x12, 0x04, 0xc4, 0xe2, 0xef, 0x7a, 0x15, 0x4f, 0x81, 0xe2, 0xe7,
	0x29, 0x58, 0x6f, 0x55, 0x9e, 0xb7, 0x79, 0xee, 0x96, 0x75, 0x62, 0x17, 0xd2, 0x71, 0xdb, 0x15,
	0x67, 0x63, 0x88, 0x20, 0xdd, 0x5a, 0xac, 0x9d, 0xc9, 0x9b, 0xac, 0x9d, 0x37, 0xdd, 0x37, 0x54,
	0x61, 0x2d, 0xee, 0xb5, 0x65, 0x36, 0xbf, 0x5a, 0xee, 0x98, 0x6e, 0x43, 0xf7, 0x21, 0x13, 0xd0,
	0x91, 0xdf, 0x23, 0xa2, 0x03, 0x96, 0x6e, 0x49, 0x0b, 0x8c, 0x77, 0xad, 0x0b, 0x41, 0x24, 0x9c,
	0x31, 0x13, 0x44, 0xd5, 0x38, 0xf9, 0xdc, 0xe2, 0xaf, 0xe9, 0xf1, 0xa5, 0xaf, 0x69, 0xc6, 0x11,
	0xf3, 0x09, 0xa8, 0xf8, 0x75, 0x12, 0x36, 0xa3, 0x94, 0x2b, 0xc4, 0x6a, 0xd4, 0x3d, 0xb5, 0xfb,
	0xdf, 0xec, 0xaf, 0x6f, 0x43, 0x5e, 0x06, 0x96, 0x6d, 0x11, 0x37, 0xb4, 0x4f, 0x6d, 0xe2, 0xcb,
	0x42, 0xaa, 0x8a, 0x05, 0x3d, 0xc6, 0x2f, 0x16, 0xee, 0xd4, 0xc5, 0xc2, 0x8d, 0xfe, 0x1f, 0xd6,
	0x65, 0x13, 0xd0, 0xa3, 0x2e, 0x7b, 0x68, 0xa1, 0xe8, 0xc9, 0xb0, 0xec, 0x0d, 0x6a, 0x12, 0xbd,
	0xca, 0xd5, 0x2d, 0x74, 0x37, 0x2b, 0xd7, 0xec, 0x6e, 0x74, 0xc8, 0x4e, 0xb3, 0x27, 0xcb, 0x5b,
	0xe2, 0xa6, 0x1f, 0x7e, 0x63, 0xe6, 0x64, 0x69, 0x2b, 0xe3, 0xcd, 0x7c, 0x15, 0x7f, 0xbb, 0x04,
	0xdb, 0xd3, 0x69, 0x2b, 0xee, 0x83, 0x5c, 0xd3, 0x0b, 0x06, 0x34, 0x64, 0xb9, 0x4b, 0x74, 0x78,
	0xb2, 0x70, 0x8a, 0x46, 0x4f, 0xb9, 0xee, 0x80, 0xc0, 0xb9, 0x44, 0x45, 0x15, 0xed, 0xde, 0x09,
	0x6c, 0x0a, 0xfe, 0x85, 0x11, 0x24, 0x79, 0x4d, 0x0d, 0xc2, 0xda, 0xb9, 0x21, 0x04, 0x7d, 0x0b,
	0x54, 0xd6, 0x3d, 0x8d, 0xa7, 0x13, 0x56, 0xe4, 0xe8, 0x75, 0x81, 0x47, 0xa7, 0xe6, 0xbe, 0xe6,
	0xc1, 0x30, 0x23, 0xb9, 0xc4, 0x25, 0x73, 0x1c, 0x9e, 0x0a, 0xde, 0x87, 0xcc, 0x89, 0x43, 0x7b,
	0x67, 0xc6, 0x80, 0x30, 0x45, 0xdc, 0xd7, 0x29, 0x9c, 0xe6, 0x58, 0x83, 0x43, 0xe8, 0x97, 0x90,
	0x13, 0x45, 0xf4, 0x64, 0x62, 0xf8, 0x6c, 0x8a, 0x2d, 0xac, 0xec, 0xa5, 0xf6, 0xd3, 0x07, 0xf5,
	0xcb, 0xbc, 0x74, 0xb9, 0x1b, 0x4a, 0xfc, 0x20, 0xd5, 0x09, 0x1f, 0x86, 0x35, 0x37, 0xf4, 0x27,
	0x6c, 0x08, 0x99, 0x42, 0xdb, 0x3f, 0x86, 0xfc, 0x05, 0x11, 0xa4, 0x42, 0xea, 0x8c, 0x4c, 0xb8,
	0xb3, 0xb2, 0x98, 0xfd, 0x64, 0xb9, 0x78, 0xe6, 0x7a, 0xb1, 0xf8, 0xf8, 0x7e, 0xf2, 0x7b, 0x4a,
	0xf1, 0x5f, 0x29, 0x50, 0xa7, 0xfa, 0xe5, 0x63, 0x2b, 0xc1, 0x06, 0x7b, 0x1e, 0xd2, 0xf5, 0xe4,
	0xdc, 0xa3, 0xc1, 0xc8, 0x17, 0xde, 0x5f, 0xc6, 0xf9, 0xa1, 0x79, 0x2e, 0x3c, 0xa9, 0xc9, 0x05,
	0x76, 0x7b, 0x16, 0x39, 0xe5, 0x63, 0x17, 0x4b, 0x28, 0x74, 0x14, 0x72, 0x45, 0x29, 0x9c, 0x93,
	0x70, 0x57, 0xa0, 0xcc, 0x23, 0xe2, 0x05, 0x18, 0xa7, 0x3e, 0xf9, 0xd5, 0x88, 0xb8, 0xbd, 0x49,
	0xe4, 0x11, 0x81, 0x1f, 0x46, 0x30, 0xfa, 0x10, 0x36, 0x67, 0x6c, 0x98, 0x77, 0x4b, 0x16, 0xa3,
	0xd8, 0x88, 0xa9, 0x6b, 0x1e, 0x41, 0xce, 0x74, 0x1c, 0xfa, 0x09, 0xb1, 0xc4, 0x3b, 0x0c, 0x0a,
	0xcb, 0x7b, 0x29, 0xd6, 0x47, 0x4b, 0x94, 0x9f, 0x30, 0x40, 0x05, 0xb8, 0x45, 0x5c, 0xf3, 0xc4,
	0x21, 0x22, 0x85, 0xad, 0xe2, 0xe8, 0x13, 0x1d, 0xc0, 0xd6, 0xdc, 0x50, 0x6c, 0x8d, 0xfc, 0x69,
	0xa7, 0x98, 0xc2, 0x1b, 0x33, 0x53, 0x6e, 0x5d, 0x2e, 0x5d, 0x32, 0x48, 0xaf, 0xde, 0xd4, 0x20,
	0x8d, 0x9e, 0xc1, 0x46, 0x30, 0xf2, 0x3c, 0xea, 0xb3, 0xce, 0x30, 0x7a, 0xc0, 0x6c, 0x1c, 0x49,
	0x5d, 0xf9, 0xdd, 0xa3, 0x98, 0x20, 0x82, 0x83, 0xe2, 0xef, 0x92, 0x80, 0x78, 0xa6, 0x8b, 0xb4,
	0x55, 0x1c, 0xe2, 0x87, 0xe8, 0x36, 0xac, 0xf2, 0x88, 0x8d, 0x52, 0x6c, 0x16, 0xdf, 0xe2, 0xdf,
	0xfa, 0x95, 0xa7, 0x94, 0x07, 0x90, 0x1d, 0xd0, 0x91, 0x1f, 0x18, 0x74, 0x4c, 0x7c, 0x6b, 0x44,
	0xb8, 0x7b, 0x15, 0x9c, 0xe1, 0x60, 0x5b, 0x60, 0x37, 0x52, 0xaf, 0xa6, 0xe3, 0xd0, 0xf2, 0x7f,
	0x37, 0x0e, 0x3d, 0x7e, 0xa5, 0xc0, 0xe6, 0xdb, 0xa6, 0x41, 0xb4, 0x0d, 0xef, 0x61, 0xed, 0xa8,
	0xdd, 0xd5, 0x8c, 0x4e, 0xfb, 0x58, 0xef, 0xea, 0xed, 0x96, 0x51, 0xa9, 0x75, 0xf5, 0xe7, 0x9a,
	0x9a, 0x40, 0xbb, 0x70, 0x67, 0x71, 0xed, 0x85, 0xde, 0x6d, 0xd4, 0x71, 0xe5, 0x85, 0xde, 0x7a,
	0xaa, 0x2a, 0x6f, 0xdb, 0x5c, 0x6b, 0xb6, 0x8f, 0xb5, 0xba, 0x9a, 0x44, 0xb7, 0x61, 0x6b, 0x71,
	0x4d, 0xc3, 0xb8, 0x8d, 0xd5, 0xd4, 0xf6, 0xd2, 0x67, 0x7f, 0xd8, 0x49, 0x3c, 0x76, 0x21, 0x3b,
	0xd7, 0x72, 0x32, 0xb6, 0x76, 0x47, 0xc3, 0x15, 0x2e, 0xdb, 0x7d, 0xd9, 0xd1, 0x8c, 0xba, 0xc6,
	0xf7, 0xaa, 0x09, 0x74, 0x0f, 0x6e, 0x2f, 0xac, 0x45, 0x96, 0x54, 0x9a, 0xaa, 0x82, 0xee, 0x42,
	0x61, 0x61, 0x19, 0x6b, 0xd5, 0x4a, 0xb3, 0xd2, 0xaa, 0x69, 0x6a, 0x52, 0xea, 0xfb, 0xab, 0x32,
	0x9d, 0x51, 0xb9, 0xbe, 0x3d, 0xb8, 0xab, 0xb7, 0x0e, 0x9b, 0xfa, 0xd3, 0x46, 0x37, 0xd2, 0x64,
	0x74, 0xdb, 0xb1, 0xb9, 0x6a, 0x02, 0x3d, 0x82, 0xfb, 0xb1, 0xc4, 0x54, 0x9f, 0x71, 0x88, 0xdb,
	0x47, 0x53, 0x31, 0x05, 0xed, 0xc3, 0xc3, 0x58, 0x2c, 0xd6, 0x6b, 0x54, 0xb5, 0xee, 0x0b, 0x4d,
	0x6b, 0xc5, 0x82, 0xc7, 0x6a, 0x92, 0xdd, 0x68, 0x2c, 0xd9, 0xd1, 0x5a, 0x75, 0xbd, 0xf5, 0x94,
	0xa9, 0x6e, 0xb6, 0x5f, 0x1e, 0x69, 0xad, 0xae, 0x9a, 0x42, 0x1f, 0xc0, 0xfe, 0x05, 0x81, 0x19,
	0xcd, 0x75, 0xfd, 0xb8, 0x8b, 0xf5, 0xea, 0x33, 0xae, 0x78, 0x49, 0x1e, 0xec, 0x53, 0x05, 0x72,
	0xf3, 0xb3, 0x0e, 0xda, 0x04, 0x75, 0x91, 0x46, 0x4d, 0xa0, 0xf7, 0x00, 0xc5, 0x68, 0xad, 0xdd,
	0x3a, 0xd4, 0xf1, 0x91, 0x56, 0x57, 0x95, 0x05, 0xfc, 0xa8, 0xd3, 0xd4, 0xba, 0xdc, 0x85, 0x1b,
	0xb0, 0x1e, 0xe3, 0x87, 0x15, 0xbd, 0xa9, 0xd5, 0xd5, 0xd4, 0x1c, 0x75, 0x57, 0x3f, 0xd2, 0xda,
	0xcf, 0xba, 0xb1, 0x25, 0x2e, 0xa0, 0x8b, 0x7d, 0x0f, 0xba, 0x03, 0xef, 0xb7, 0x71, 0xa5, 0xd6,
	0xd4, 0x8c, 0x67, 0x9d, 0x7a, 0xa5, 0xab, 0x19, 0xcf, 0x2b, 0x4d, 0x9d, 0xfd, 0xa8, 0xab, 0x09,
	0x16, 0x26, 0xf3, 0x8b, 0x95, 0x4e, 0xa7, 0xa9, 0x73, 0xb3, 0x58, 0x3c, 0xcc, 0x2d, 0x61, 0xed,
	0x63, 0xad, 0xc6, 0x4d, 0x93, 0xfa, 0x1a, 0x90, 0x99, 0xcd, 0x02, 0x4c, 0x53, 0x07, 0xb7, 0x9f,
	0xeb, 0x75, 0x0d, 0x8b, 0x28, 0x68, 0xbc, 0xec, 0x68, 0xb8, 0x59, 0x69, 0xb1, 0x68, 0xde, 0x82,
	0xfc, 0xfc, 0xa2, 0x5e, 0xad, 0xa9, 0x8a, 0x60, 0xaa, 0xfe, 0xf0, 0x8b, 0xd7, 0x3b, 0xca, 0x97,
	0xaf, 0x77, 0x94, 0x7f, 0xbe, 0xde, 0x51, 0x5e, 0xbd, 0xd9, 0x49, 0x7c, 0xf9, 0x66, 0x27, 0xf1,
	0xb7, 0x37, 0x3b, 0x89, 0x9f, 0x3e, 0x90, 0x89, 0x47, 0x64, 0xa1, 0xf3, 0xc9, 0xaf, 0xcb, 0xe3,
	0x8f, 0xc4, 0xbf, 0x74, 0xa7, 0xff, 0x84, 0x3e, 0x59, 0xe1, 0x2f, 0xfa, 0xa3, 0xff, 0x04, 0x00,
	0x00, 0xff, 0xff, 0xd2, 0xe3, 0x20, 0x58, 0xa5, 0x16, 0x00, 0x00,
}

func (m *CrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxInflightValue.Size()
		i -= size
		if _, err := m.MaxInflightValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.RemotePositionAddress.Size()
		i -= size
		if _, err := m.RemotePositionAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.ReceiverChainHook.Size()
		i -= size
		if _, err := m.ReceiverChainHook.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.HyptokenId.Size()
		i -= size
		if _, err := m.HyptokenId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RemotePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemotePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemotePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxStaleness != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxStaleness))
		i--
		dAtA[i] = 0x50
	}
	if len(m.OracleAddress) > 0 {
		i -= len(m.OracleAddress)
		copy(dAtA[i:], m.OracleAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.OracleAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x40
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastUpdate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintCrossChain(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x3a
	{
		size := m.TotalValue.Size()
		i -= size
		if _, err := m.TotalValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Principal.Size()
		i -= size
		if _, err := m.Principal.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.SharesHeld.Size()
		i -= size
		if _, err := m.SharesHeld.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.VaultAddress.Size()
		i -= size
		if _, err := m.VaultAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.HyptokenId.Size()
		i -= size
		if _, err := m.HyptokenId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InflightFund) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InflightFund) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InflightFund) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProviderTracking != nil {
		{
			size, err := m.ProviderTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	{
		size := m.ValueAtInitiation.Size()
		i -= size
		if _, err := m.ValueAtInitiation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintCrossChain(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x4a
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.InitiatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintCrossChain(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x42
	if m.Destination != nil {
		{
			size := m.Destination.Size()
			i -= size
			if _, err := m.Destination.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Origin != nil {
		{
			size := m.Origin.Size()
			i -= size
			if _, err := m.Origin.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.TransactionId) > 0 {
		i -= len(m.TransactionId)
		copy(dAtA[i:], m.TransactionId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.TransactionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InflightFund_NobleOrigin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InflightFund_NobleOrigin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NobleOrigin != nil {
		{
			size, err := m.NobleOrigin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *InflightFund_RemoteOrigin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InflightFund_RemoteOrigin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoteOrigin != nil {
		{
			size, err := m.RemoteOrigin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *InflightFund_NobleDestination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InflightFund_NobleDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NobleDestination != nil {
		{
			size, err := m.NobleDestination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *InflightFund_RemoteDestination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InflightFund_RemoteDestination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoteDestination != nil {
		{
			size, err := m.RemoteDestination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *NobleEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NobleEndpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NobleEndpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OperationType != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.OperationType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProviderTrackingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderTrackingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderTrackingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TrackingInfo != nil {
		{
			size := m.TrackingInfo.Size()
			i -= size
			if _, err := m.TrackingInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProviderTrackingInfo_HyperlaneTracking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderTrackingInfo_HyperlaneTracking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HyperlaneTracking != nil {
		{
			size, err := m.HyperlaneTracking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *HyperlaneTrackingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HyperlaneTrackingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HyperlaneTrackingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Processed {
		i--
		if m.Processed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.DestinationTxHash) > 0 {
		i -= len(m.DestinationTxHash)
		copy(dAtA[i:], m.DestinationTxHash)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.DestinationTxHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OriginTxHash) > 0 {
		i -= len(m.OriginTxHash)
		copy(dAtA[i:], m.OriginTxHash)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.OriginTxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Nonce != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x18
	}
	if m.OriginDomain != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.OriginDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MessageId) > 0 {
		i -= len(m.MessageId)
		copy(dAtA[i:], m.MessageId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.MessageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NAVOracleUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NAVOracleUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NAVOracleUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.MessageId) > 0 {
		i -= len(m.MessageId)
		copy(dAtA[i:], m.MessageId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.MessageId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0x2a
	}
	n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintCrossChain(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x22
	{
		size := m.SharesHeld.Size()
		i -= size
		if _, err := m.SharesHeld.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PositionId != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PositionOracleConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionOracleConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PositionOracleConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProviderType != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.ProviderType))
		i--
		dAtA[i] = 0x38
	}
	n11, err11 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastUpdate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintCrossChain(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x32
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OracleContract) > 0 {
		i -= len(m.OracleContract)
		copy(dAtA[i:], m.OracleContract)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.OracleContract)))
		i--
		dAtA[i] = 0x22
	}
	if m.MaxStaleness != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxStaleness))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OriginIdentifier) > 0 {
		i -= len(m.OriginIdentifier)
		copy(dAtA[i:], m.OriginIdentifier)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.OriginIdentifier)))
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainPositionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainPositionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainPositionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValueByRoute) > 0 {
		for k := range m.ValueByRoute {
			v := m.ValueByRoute[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCrossChain(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintCrossChain(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCrossChain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.BlockHeight != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.StalePositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.StalePositions))
		i--
		dAtA[i] = 0x20
	}
	if m.ActivePositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.ActivePositions))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalInflightValue.Size()
		i -= size
		if _, err := m.TotalInflightValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalRemoteValue.Size()
		i -= size
		if _, err := m.TotalRemoteValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CrossChainConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SupportedProviders) > 0 {
		dAtA13 := make([]byte, len(m.SupportedProviders)*10)
		var j12 int
		for _, num := range m.SupportedProviders {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintCrossChain(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x4a
	}
	{
		size := m.MaxInflightValue.Size()
		i -= size
		if _, err := m.MaxInflightValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.MaxInflightDuration != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxInflightDuration))
		i--
		dAtA[i] = 0x38
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.AllowedChains) > 0 {
		for iNdEx := len(m.AllowedChains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedChains[iNdEx])
			copy(dAtA[i:], m.AllowedChains[iNdEx])
			i = encodeVarintCrossChain(dAtA, i, uint64(len(m.AllowedChains[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxRemotePositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxRemotePositions))
		i--
		dAtA[i] = 0x20
	}
	if m.UpdateFrequency != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.UpdateFrequency))
		i--
		dAtA[i] = 0x18
	}
	if m.DefaultTimeout != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DefaultTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxRemoteExposure != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxRemoteExposure))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StaleInflightAlert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaleInflightAlert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaleInflightAlert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	n14, err14 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintCrossChain(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0x22
	if m.HoursOverdue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.HoursOverdue))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.TransactionId) > 0 {
		i -= len(m.TransactionId)
		copy(dAtA[i:], m.TransactionId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.TransactionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.RouteId != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCrossChain(dAtA []byte, offset int, v uint64) int {
	offset -= sovCrossChain(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.HyptokenId.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.ReceiverChainHook.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.RemotePositionAddress.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.MaxInflightValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	return n
}

func (m *RemotePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.HyptokenId.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.VaultAddress.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.SharesHeld.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.Principal.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.TotalValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate)
	n += 1 + l + sovCrossChain(uint64(l))
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	l = len(m.OracleAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.MaxStaleness != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxStaleness))
	}
	return n
}

func (m *InflightFund) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCrossChain(uint64(m.Id))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.Origin != nil {
		n += m.Origin.Size()
	}
	if m.Destination != nil {
		n += m.Destination.Size()
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt)
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedAt)
	n += 1 + l + sovCrossChain(uint64(l))
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	l = m.ValueAtInitiation.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.ProviderTracking != nil {
		l = m.ProviderTracking.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}

func (m *InflightFund_NobleOrigin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NobleOrigin != nil {
		l = m.NobleOrigin.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}
func (m *InflightFund_RemoteOrigin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoteOrigin != nil {
		l = m.RemoteOrigin.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}
func (m *InflightFund_NobleDestination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NobleDestination != nil {
		l = m.NobleDestination.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}
func (m *InflightFund_RemoteDestination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoteDestination != nil {
		l = m.RemoteDestination.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}
func (m *NobleEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationType != 0 {
		n += 1 + sovCrossChain(uint64(m.OperationType))
	}
	return n
}

func (m *ProviderTrackingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrackingInfo != nil {
		n += m.TrackingInfo.Size()
	}
	return n
}

func (m *ProviderTrackingInfo_HyperlaneTracking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HyperlaneTracking != nil {
		l = m.HyperlaneTracking.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}
func (m *HyperlaneTrackingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.OriginDomain != 0 {
		n += 1 + sovCrossChain(uint64(m.OriginDomain))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovCrossChain(uint64(m.DestinationDomain))
	}
	if m.Nonce != 0 {
		n += 1 + sovCrossChain(uint64(m.Nonce))
	}
	l = len(m.OriginTxHash)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.DestinationTxHash)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Processed {
		n += 2
	}
	return n
}

func (m *NAVOracleUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovCrossChain(uint64(m.PositionId))
	}
	l = m.SharePrice.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.SharesHeld.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovCrossChain(uint64(l))
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	return n
}

func (m *PositionOracleConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovCrossChain(uint64(m.PositionId))
	}
	l = len(m.OriginIdentifier)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.MaxStaleness != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxStaleness))
	}
	l = len(m.OracleContract)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate)
	n += 1 + l + sovCrossChain(uint64(l))
	if m.ProviderType != 0 {
		n += 1 + sovCrossChain(uint64(m.ProviderType))
	}
	return n
}

func (m *CrossChainPositionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalRemoteValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.TotalInflightValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.ActivePositions != 0 {
		n += 1 + sovCrossChain(uint64(m.ActivePositions))
	}
	if m.StalePositions != 0 {
		n += 1 + sovCrossChain(uint64(m.StalePositions))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovCrossChain(uint64(m.BlockHeight))
	}
	if len(m.ValueByRoute) > 0 {
		for k, v := range m.ValueByRoute {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCrossChain(uint64(k)) + 1 + len(v) + sovCrossChain(uint64(len(v)))
			n += mapEntrySize + 1 + sovCrossChain(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CrossChainConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRemoteExposure != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxRemoteExposure))
	}
	if m.DefaultTimeout != 0 {
		n += 1 + sovCrossChain(uint64(m.DefaultTimeout))
	}
	if m.UpdateFrequency != 0 {
		n += 1 + sovCrossChain(uint64(m.UpdateFrequency))
	}
	if m.MaxRemotePositions != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxRemotePositions))
	}
	if len(m.AllowedChains) > 0 {
		for _, s := range m.AllowedChains {
			l = len(s)
			n += 1 + l + sovCrossChain(uint64(l))
		}
	}
	if m.Enabled {
		n += 2
	}
	if m.MaxInflightDuration != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxInflightDuration))
	}
	l = m.MaxInflightValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if len(m.SupportedProviders) > 0 {
		l = 0
		for _, e := range m.SupportedProviders {
			l += sovCrossChain(uint64(e))
		}
		n += 1 + sovCrossChain(uint64(l)) + l
	}
	return n
}

func (m *StaleInflightAlert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteId != 0 {
		n += 1 + sovCrossChain(uint64(m.RouteId))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.HoursOverdue != 0 {
		n += 9
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.Amount.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	return n
}

func sovCrossChain(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCrossChain(x uint64) (n int) {
	return sovCrossChain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyptokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HyptokenId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverChainHook", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReceiverChainHook.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePositionAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemotePositionAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInflightValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxInflightValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemotePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemotePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemotePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyptokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HyptokenId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VaultAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesHeld", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesHeld.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Principal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RemotePositionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStaleness", wireType)
			}
			m.MaxStaleness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxStaleness |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InflightFund) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InflightFund: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InflightFund: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NobleOrigin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NobleEndpoint{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Origin = &InflightFund_NobleOrigin{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteOrigin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemotePosition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Origin = &InflightFund_RemoteOrigin{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NobleDestination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NobleEndpoint{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Destination = &InflightFund_NobleDestination{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDestination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemotePosition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Destination = &InflightFund_RemoteDestination{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.InitiatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InflightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueAtInitiation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValueAtInitiation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderTracking == nil {
				m.ProviderTracking = &ProviderTrackingInfo{}
			}
			if err := m.ProviderTracking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NobleEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NobleEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NobleEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
			}
			m.OperationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationType |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderTrackingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderTrackingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderTrackingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyperlaneTracking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HyperlaneTrackingInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrackingInfo = &ProviderTrackingInfo_HyperlaneTracking{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HyperlaneTrackingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HyperlaneTrackingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HyperlaneTrackingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = append(m.MessageId[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageId == nil {
				m.MessageId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginDomain", wireType)
			}
			m.OriginDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Processed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NAVOracleUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NAVOracleUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NAVOracleUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesHeld", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesHeld.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OracleUpdateStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionOracleConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionOracleConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionOracleConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStaleness", wireType)
			}
			m.MaxStaleness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxStaleness |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderType", wireType)
			}
			m.ProviderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProviderType |= ProviderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainPositionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainPositionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainPositionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRemoteValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRemoteValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalInflightValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalInflightValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePositions", wireType)
			}
			m.ActivePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivePositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalePositions", wireType)
			}
			m.StalePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StalePositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueByRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValueByRoute == nil {
				m.ValueByRoute = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCrossChain
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCrossChain
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCrossChain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCrossChain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ValueByRoute[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRemoteExposure", wireType)
			}
			m.MaxRemoteExposure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRemoteExposure |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTimeout", wireType)
			}
			m.DefaultTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateFrequency", wireType)
			}
			m.UpdateFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateFrequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRemotePositions", wireType)
			}
			m.MaxRemotePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRemotePositions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedChains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedChains = append(m.AllowedChains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInflightDuration", wireType)
			}
			m.MaxInflightDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInflightDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInflightValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxInflightValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v ProviderType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ProviderType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedProviders = append(m.SupportedProviders, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCrossChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCrossChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.SupportedProviders) == 0 {
					m.SupportedProviders = make([]ProviderType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ProviderType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ProviderType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedProviders = append(m.SupportedProviders, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedProviders", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaleInflightAlert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaleInflightAlert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaleInflightAlert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoursOverdue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.HoursOverdue = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrossChain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCrossChain
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCrossChain
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCrossChain
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCrossChain        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrossChain          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCrossChain = fmt.Errorf("proto: unexpected end of group")
)
