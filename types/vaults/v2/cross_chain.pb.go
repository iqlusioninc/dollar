// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/cross_chain.proto

package v2

import (
	cosmossdk_io_math "cosmossdk.io/math"
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_bcp_innovations_hyperlane_cosmos_util "github.com/bcp-innovations/hyperlane-cosmos/util"
	_ "github.com/bcp-innovations/hyperlane-cosmos/x/warp/types"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RemotePositionStatus represents the status of a remote position
type RemotePositionStatus int32

const (
	// Position is waiting for initial deposit
	REMOTE_POSITION_INITIALIZING RemotePositionStatus = 0
	// Position is active and being tracked
	REMOTE_POSITION_ACTIVE RemotePositionStatus = 1
	// Position is being withdrawn from
	REMOTE_POSITION_WITHDRAWING RemotePositionStatus = 2
	// Position has been closed
	REMOTE_POSITION_CLOSED RemotePositionStatus = 3
	// Position is in error state
	REMOTE_POSITION_ERROR RemotePositionStatus = 4
)

var RemotePositionStatus_name = map[int32]string{
	0: "REMOTE_POSITION_INITIALIZING",
	1: "REMOTE_POSITION_ACTIVE",
	2: "REMOTE_POSITION_WITHDRAWING",
	3: "REMOTE_POSITION_CLOSED",
	4: "REMOTE_POSITION_ERROR",
}

var RemotePositionStatus_value = map[string]int32{
	"REMOTE_POSITION_INITIALIZING": 0,
	"REMOTE_POSITION_ACTIVE":       1,
	"REMOTE_POSITION_WITHDRAWING":  2,
	"REMOTE_POSITION_CLOSED":       3,
	"REMOTE_POSITION_ERROR":        4,
}

func (x RemotePositionStatus) String() string {
	return proto.EnumName(RemotePositionStatus_name, int32(x))
}

func (RemotePositionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{0}
}

// OperationType represents the type of cross-chain operation
type OperationType int32

const (
	// Deposit operation
	OPERATION_TYPE_DEPOSIT OperationType = 0
	// Withdrawal operation
	OPERATION_TYPE_WITHDRAWAL OperationType = 1
	// Rebalance operation
	OPERATION_TYPE_REBALANCE OperationType = 2
)

var OperationType_name = map[int32]string{
	0: "OPERATION_TYPE_DEPOSIT",
	1: "OPERATION_TYPE_WITHDRAWAL",
	2: "OPERATION_TYPE_REBALANCE",
}

var OperationType_value = map[string]int32{
	"OPERATION_TYPE_DEPOSIT":    0,
	"OPERATION_TYPE_WITHDRAWAL": 1,
	"OPERATION_TYPE_REBALANCE":  2,
}

func (x OperationType) String() string {
	return proto.EnumName(OperationType_name, int32(x))
}

func (OperationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{1}
}

// InflightStatus represents the status of inflight funds
type InflightStatus int32

const (
	// Transaction is pending
	INFLIGHT_PENDING InflightStatus = 0
	// Transaction completed successfully
	INFLIGHT_COMPLETED InflightStatus = 1
	// Transaction failed
	INFLIGHT_FAILED InflightStatus = 2
	// Transaction timed out
	INFLIGHT_TIMEOUT InflightStatus = 3
)

var InflightStatus_name = map[int32]string{
	0: "INFLIGHT_PENDING",
	1: "INFLIGHT_COMPLETED",
	2: "INFLIGHT_FAILED",
	3: "INFLIGHT_TIMEOUT",
}

var InflightStatus_value = map[string]int32{
	"INFLIGHT_PENDING":   0,
	"INFLIGHT_COMPLETED": 1,
	"INFLIGHT_FAILED":    2,
	"INFLIGHT_TIMEOUT":   3,
}

func (x InflightStatus) String() string {
	return proto.EnumName(InflightStatus_name, int32(x))
}

func (InflightStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{2}
}

// OracleUpdateStatus represents the status of an oracle update
type OracleUpdateStatus int32

const (
	// Update has been validated
	ORACLE_UPDATE_VALIDATED OracleUpdateStatus = 0
	// Update has been applied to position
	ORACLE_UPDATE_APPLIED OracleUpdateStatus = 1
	// Update was rejected (stale, invalid, etc.)
	ORACLE_UPDATE_REJECTED OracleUpdateStatus = 2
)

var OracleUpdateStatus_name = map[int32]string{
	0: "ORACLE_UPDATE_VALIDATED",
	1: "ORACLE_UPDATE_APPLIED",
	2: "ORACLE_UPDATE_REJECTED",
}

var OracleUpdateStatus_value = map[string]int32{
	"ORACLE_UPDATE_VALIDATED": 0,
	"ORACLE_UPDATE_APPLIED":   1,
	"ORACLE_UPDATE_REJECTED":  2,
}

func (x OracleUpdateStatus) String() string {
	return proto.EnumName(OracleUpdateStatus_name, int32(x))
}

func (OracleUpdateStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{3}
}

// CrossChainRoute defines a route for cross-chain operations
// Currently supports Hyperlane, with potential for future IBC support
type CrossChainRoute struct {
	// HypToken
	HyptokenId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=hyptoken_id,json=hyptokenId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"hyptoken_id"`
	// Reciever chain hook;
	ReceiverChainHook github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,2,opt,name=receiver_chain_hook,json=receiverChainHook,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"receiver_chain_hook"`
	// Vault
	RemotePositionAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,3,opt,name=remote_position_address,json=remotePositionAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"remote_position_address"`
	// Maximum value allowed inflight on this route
	MaxInflightValue cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=max_inflight_value,json=maxInflightValue,proto3,customtype=cosmossdk.io/math.Int" json:"max_inflight_value"`
}

func (m *CrossChainRoute) Reset()         { *m = CrossChainRoute{} }
func (m *CrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*CrossChainRoute) ProtoMessage()    {}
func (*CrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{0}
}
func (m *CrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainRoute.Merge(m, src)
}
func (m *CrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainRoute proto.InternalMessageInfo

// RemotePosition represents a position in an ERC-4626 compatible vault on another chain
type RemotePosition struct {
	// Remote Position ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// HypToken
	HyptokenId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,2,opt,name=hyptoken_id,json=hyptokenId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"hyptoken_id"`
	// Address of the ERC-4626 compatible vault
	VaultAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,3,opt,name=vault_address,json=vaultAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"vault_address"`
	// Number of vault shares held
	SharesHeld cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=shares_held,json=sharesHeld,proto3,customtype=cosmossdk.io/math.Int" json:"shares_held"`
	// Principal amount initially deposited (in USDN)
	Principal cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=principal,proto3,customtype=cosmossdk.io/math.Int" json:"principal"`
	// Current share price from oracle
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
	// Total value of position (shares * price)
	TotalValue cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=total_value,json=totalValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_value"`
	// Last oracle update timestamp
	LastUpdate time.Time `protobuf:"bytes,8,opt,name=last_update,json=lastUpdate,proto3,stdtime" json:"last_update"`
	// Position status
	Status RemotePositionStatus `protobuf:"varint,9,opt,name=status,proto3,enum=noble.dollar.vaults.v2.RemotePositionStatus" json:"status,omitempty"`
	// Oracle configuration for this position
	OracleAddress string `protobuf:"bytes,10,opt,name=oracle_address,json=oracleAddress,proto3" json:"oracle_address,omitempty"`
	// Maximum staleness for oracle data (seconds)
	MaxStaleness int64 `protobuf:"varint,11,opt,name=max_staleness,json=maxStaleness,proto3" json:"max_staleness,omitempty"`
}

func (m *RemotePosition) Reset()         { *m = RemotePosition{} }
func (m *RemotePosition) String() string { return proto.CompactTextString(m) }
func (*RemotePosition) ProtoMessage()    {}
func (*RemotePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{1}
}
func (m *RemotePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemotePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemotePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemotePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemotePosition.Merge(m, src)
}
func (m *RemotePosition) XXX_Size() int {
	return m.Size()
}
func (m *RemotePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_RemotePosition.DiscardUnknown(m)
}

var xxx_messageInfo_RemotePosition proto.InternalMessageInfo

func (m *RemotePosition) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RemotePosition) GetLastUpdate() time.Time {
	if m != nil {
		return m.LastUpdate
	}
	return time.Time{}
}

func (m *RemotePosition) GetStatus() RemotePositionStatus {
	if m != nil {
		return m.Status
	}
	return REMOTE_POSITION_INITIALIZING
}

func (m *RemotePosition) GetOracleAddress() string {
	if m != nil {
		return m.OracleAddress
	}
	return ""
}

func (m *RemotePosition) GetMaxStaleness() int64 {
	if m != nil {
		return m.MaxStaleness
	}
	return 0
}

// InflightFund represents funds in transit between Noble and remote positions
type InflightFund struct {
	// Unique identifier for this inflight transaction
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Id of the corresponding RemotePosition
	RemotePositionId uint64 `protobuf:"varint,2,opt,name=remote_position_id,json=remotePositionId,proto3" json:"remote_position_id,omitempty"`
	// Amount in USDN (always USDN, never shares)
	Amount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// When the operation was initiated
	InitiatedAt time.Time `protobuf:"bytes,9,opt,name=initiated_at,json=initiatedAt,proto3,stdtime" json:"initiated_at"`
	// Expected completion time
	ExpectedAt time.Time `protobuf:"bytes,10,opt,name=expected_at,json=expectedAt,proto3,stdtime" json:"expected_at"`
	// Current status
	Status InflightStatus `protobuf:"varint,11,opt,name=status,proto3,enum=noble.dollar.vaults.v2.InflightStatus" json:"status,omitempty"`
	// Value at initiation (for AUM calculation)
	ValueAtInitiation     cosmossdk_io_math.Int  `protobuf:"bytes,12,opt,name=value_at_initiation,json=valueAtInitiation,proto3,customtype=cosmossdk.io/math.Int" json:"value_at_initiation"`
	HyperlaneTrackingInfo *HyperlaneTrackingInfo `protobuf:"bytes,13,opt,name=hyperlane_tracking_info,json=hyperlaneTrackingInfo,proto3" json:"hyperlane_tracking_info,omitempty"`
}

func (m *InflightFund) Reset()         { *m = InflightFund{} }
func (m *InflightFund) String() string { return proto.CompactTextString(m) }
func (*InflightFund) ProtoMessage()    {}
func (*InflightFund) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{2}
}
func (m *InflightFund) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InflightFund) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InflightFund.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InflightFund) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InflightFund.Merge(m, src)
}
func (m *InflightFund) XXX_Size() int {
	return m.Size()
}
func (m *InflightFund) XXX_DiscardUnknown() {
	xxx_messageInfo_InflightFund.DiscardUnknown(m)
}

var xxx_messageInfo_InflightFund proto.InternalMessageInfo

func (m *InflightFund) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *InflightFund) GetRemotePositionId() uint64 {
	if m != nil {
		return m.RemotePositionId
	}
	return 0
}

func (m *InflightFund) GetInitiatedAt() time.Time {
	if m != nil {
		return m.InitiatedAt
	}
	return time.Time{}
}

func (m *InflightFund) GetExpectedAt() time.Time {
	if m != nil {
		return m.ExpectedAt
	}
	return time.Time{}
}

func (m *InflightFund) GetStatus() InflightStatus {
	if m != nil {
		return m.Status
	}
	return INFLIGHT_PENDING
}

func (m *InflightFund) GetHyperlaneTrackingInfo() *HyperlaneTrackingInfo {
	if m != nil {
		return m.HyperlaneTrackingInfo
	}
	return nil
}

// HyperlaneTrackingInfo contains Hyperlane-specific tracking data
type HyperlaneTrackingInfo struct {
	// Hyperlane message ID
	MessageId []byte `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Origin domain
	OriginDomain uint32 `protobuf:"varint,2,opt,name=origin_domain,json=originDomain,proto3" json:"origin_domain,omitempty"`
	// Destination domain
	DestinationDomain uint32 `protobuf:"varint,3,opt,name=destination_domain,json=destinationDomain,proto3" json:"destination_domain,omitempty"`
	// Transaction hash on origin chain
	OriginTxHash string `protobuf:"bytes,5,opt,name=origin_tx_hash,json=originTxHash,proto3" json:"origin_tx_hash,omitempty"`
	// Transaction hash on destination chain
	DestinationTxHash string `protobuf:"bytes,6,opt,name=destination_tx_hash,json=destinationTxHash,proto3" json:"destination_tx_hash,omitempty"`
	// Whether message has been processed
	Processed bool `protobuf:"varint,7,opt,name=processed,proto3" json:"processed,omitempty"`
}

func (m *HyperlaneTrackingInfo) Reset()         { *m = HyperlaneTrackingInfo{} }
func (m *HyperlaneTrackingInfo) String() string { return proto.CompactTextString(m) }
func (*HyperlaneTrackingInfo) ProtoMessage()    {}
func (*HyperlaneTrackingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{3}
}
func (m *HyperlaneTrackingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HyperlaneTrackingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HyperlaneTrackingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HyperlaneTrackingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HyperlaneTrackingInfo.Merge(m, src)
}
func (m *HyperlaneTrackingInfo) XXX_Size() int {
	return m.Size()
}
func (m *HyperlaneTrackingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HyperlaneTrackingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HyperlaneTrackingInfo proto.InternalMessageInfo

func (m *HyperlaneTrackingInfo) GetMessageId() []byte {
	if m != nil {
		return m.MessageId
	}
	return nil
}

func (m *HyperlaneTrackingInfo) GetOriginDomain() uint32 {
	if m != nil {
		return m.OriginDomain
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetOriginTxHash() string {
	if m != nil {
		return m.OriginTxHash
	}
	return ""
}

func (m *HyperlaneTrackingInfo) GetDestinationTxHash() string {
	if m != nil {
		return m.DestinationTxHash
	}
	return ""
}

func (m *HyperlaneTrackingInfo) GetProcessed() bool {
	if m != nil {
		return m.Processed
	}
	return false
}

// AUMOracleUpdate represents an oracle price update received via cross-chain messaging
type AUMOracleUpdate struct {
	// Position identifier this update is for
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	// Current share price
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
	// Number of shares held
	SharesHeld cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=shares_held,json=sharesHeld,proto3,customtype=cosmossdk.io/math.Int" json:"shares_held"`
	// Timestamp of the update
	Timestamp time.Time `protobuf:"bytes,4,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Source chain identifier
	SourceChain string `protobuf:"bytes,5,opt,name=source_chain,json=sourceChain,proto3" json:"source_chain,omitempty"`
	// Message ID (Hyperlane message ID or IBC packet)
	MessageId string `protobuf:"bytes,6,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Update status
	Status OracleUpdateStatus `protobuf:"varint,7,opt,name=status,proto3,enum=noble.dollar.vaults.v2.OracleUpdateStatus" json:"status,omitempty"`
}

func (m *AUMOracleUpdate) Reset()         { *m = AUMOracleUpdate{} }
func (m *AUMOracleUpdate) String() string { return proto.CompactTextString(m) }
func (*AUMOracleUpdate) ProtoMessage()    {}
func (*AUMOracleUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{4}
}
func (m *AUMOracleUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AUMOracleUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AUMOracleUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AUMOracleUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AUMOracleUpdate.Merge(m, src)
}
func (m *AUMOracleUpdate) XXX_Size() int {
	return m.Size()
}
func (m *AUMOracleUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_AUMOracleUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_AUMOracleUpdate proto.InternalMessageInfo

func (m *AUMOracleUpdate) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *AUMOracleUpdate) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *AUMOracleUpdate) GetSourceChain() string {
	if m != nil {
		return m.SourceChain
	}
	return ""
}

func (m *AUMOracleUpdate) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

func (m *AUMOracleUpdate) GetStatus() OracleUpdateStatus {
	if m != nil {
		return m.Status
	}
	return ORACLE_UPDATE_VALIDATED
}

// CrossChainPositionSnapshot provides a snapshot of all cross-chain positions
type CrossChainPositionSnapshot struct {
	// Total value of all remote positions
	TotalRemoteValue cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_remote_value,json=totalRemoteValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_remote_value"`
	// Total value of inflight funds
	TotalInflightValue cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_inflight_value,json=totalInflightValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_inflight_value"`
	// Number of active remote positions
	ActivePositions int64 `protobuf:"varint,3,opt,name=active_positions,json=activePositions,proto3" json:"active_positions,omitempty"`
	// Number of positions with stale data
	StalePositions int64 `protobuf:"varint,4,opt,name=stale_positions,json=stalePositions,proto3" json:"stale_positions,omitempty"`
	// Snapshot block height
	BlockHeight int64 `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Breakdown by route
	ValueByRoute map[uint32]string `protobuf:"bytes,6,rep,name=value_by_route,json=valueByRoute,proto3" json:"value_by_route,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CrossChainPositionSnapshot) Reset()         { *m = CrossChainPositionSnapshot{} }
func (m *CrossChainPositionSnapshot) String() string { return proto.CompactTextString(m) }
func (*CrossChainPositionSnapshot) ProtoMessage()    {}
func (*CrossChainPositionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{5}
}
func (m *CrossChainPositionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainPositionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainPositionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainPositionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainPositionSnapshot.Merge(m, src)
}
func (m *CrossChainPositionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainPositionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainPositionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainPositionSnapshot proto.InternalMessageInfo

func (m *CrossChainPositionSnapshot) GetActivePositions() int64 {
	if m != nil {
		return m.ActivePositions
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetStalePositions() int64 {
	if m != nil {
		return m.StalePositions
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetValueByRoute() map[uint32]string {
	if m != nil {
		return m.ValueByRoute
	}
	return nil
}

// CrossChainConfig defines global configuration for cross-chain operations
type CrossChainConfig struct {
	// Maximum total remote position value as percentage of vault (basis points)
	MaxRemoteExposure int32 `protobuf:"varint,1,opt,name=max_remote_exposure,json=maxRemoteExposure,proto3" json:"max_remote_exposure,omitempty"`
	// Default operation timeout (seconds)
	DefaultTimeout int64 `protobuf:"varint,2,opt,name=default_timeout,json=defaultTimeout,proto3" json:"default_timeout,omitempty"`
	// Position update frequency (seconds)
	UpdateFrequency int64 `protobuf:"varint,3,opt,name=update_frequency,json=updateFrequency,proto3" json:"update_frequency,omitempty"`
	// Maximum number of remote positions
	MaxRemotePositions uint32 `protobuf:"varint,4,opt,name=max_remote_positions,json=maxRemotePositions,proto3" json:"max_remote_positions,omitempty"`
	// Allowed chains (can be Hyperlane domains or IBC chain IDs)
	AllowedChains []string `protobuf:"bytes,5,rep,name=allowed_chains,json=allowedChains,proto3" json:"allowed_chains,omitempty"`
	// Whether cross-chain operations are enabled
	Enabled bool `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Maximum duration funds can be inflight (seconds)
	MaxInflightDuration int64 `protobuf:"varint,7,opt,name=max_inflight_duration,json=maxInflightDuration,proto3" json:"max_inflight_duration,omitempty"`
	// Maximum total value allowed inflight
	MaxInflightValue cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=max_inflight_value,json=maxInflightValue,proto3,customtype=cosmossdk.io/math.Int" json:"max_inflight_value"`
}

func (m *CrossChainConfig) Reset()         { *m = CrossChainConfig{} }
func (m *CrossChainConfig) String() string { return proto.CompactTextString(m) }
func (*CrossChainConfig) ProtoMessage()    {}
func (*CrossChainConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{6}
}
func (m *CrossChainConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainConfig.Merge(m, src)
}
func (m *CrossChainConfig) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainConfig proto.InternalMessageInfo

func (m *CrossChainConfig) GetMaxRemoteExposure() int32 {
	if m != nil {
		return m.MaxRemoteExposure
	}
	return 0
}

func (m *CrossChainConfig) GetDefaultTimeout() int64 {
	if m != nil {
		return m.DefaultTimeout
	}
	return 0
}

func (m *CrossChainConfig) GetUpdateFrequency() int64 {
	if m != nil {
		return m.UpdateFrequency
	}
	return 0
}

func (m *CrossChainConfig) GetMaxRemotePositions() uint32 {
	if m != nil {
		return m.MaxRemotePositions
	}
	return 0
}

func (m *CrossChainConfig) GetAllowedChains() []string {
	if m != nil {
		return m.AllowedChains
	}
	return nil
}

func (m *CrossChainConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *CrossChainConfig) GetMaxInflightDuration() int64 {
	if m != nil {
		return m.MaxInflightDuration
	}
	return 0
}

// StaleInflightAlert represents an alert for inflight funds exceeding expected duration
type StaleInflightAlert struct {
	// Route ID
	RouteId uint32 `protobuf:"varint,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
	// Transaction ID
	TransactionId string `protobuf:"bytes,2,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
	// Hours overdue
	HoursOverdue float64 `protobuf:"fixed64,3,opt,name=hours_overdue,json=hoursOverdue,proto3" json:"hours_overdue,omitempty"`
	// Alert timestamp
	Timestamp time.Time `protobuf:"bytes,4,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Amount stuck in transit
	Amount cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
}

func (m *StaleInflightAlert) Reset()         { *m = StaleInflightAlert{} }
func (m *StaleInflightAlert) String() string { return proto.CompactTextString(m) }
func (*StaleInflightAlert) ProtoMessage()    {}
func (*StaleInflightAlert) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{7}
}
func (m *StaleInflightAlert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaleInflightAlert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StaleInflightAlert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StaleInflightAlert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaleInflightAlert.Merge(m, src)
}
func (m *StaleInflightAlert) XXX_Size() int {
	return m.Size()
}
func (m *StaleInflightAlert) XXX_DiscardUnknown() {
	xxx_messageInfo_StaleInflightAlert.DiscardUnknown(m)
}

var xxx_messageInfo_StaleInflightAlert proto.InternalMessageInfo

func (m *StaleInflightAlert) GetRouteId() uint32 {
	if m != nil {
		return m.RouteId
	}
	return 0
}

func (m *StaleInflightAlert) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *StaleInflightAlert) GetHoursOverdue() float64 {
	if m != nil {
		return m.HoursOverdue
	}
	return 0
}

func (m *StaleInflightAlert) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v2.RemotePositionStatus", RemotePositionStatus_name, RemotePositionStatus_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.OperationType", OperationType_name, OperationType_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.InflightStatus", InflightStatus_name, InflightStatus_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.OracleUpdateStatus", OracleUpdateStatus_name, OracleUpdateStatus_value)
	proto.RegisterType((*CrossChainRoute)(nil), "noble.dollar.vaults.v2.CrossChainRoute")
	proto.RegisterType((*RemotePosition)(nil), "noble.dollar.vaults.v2.RemotePosition")
	proto.RegisterType((*InflightFund)(nil), "noble.dollar.vaults.v2.InflightFund")
	proto.RegisterType((*HyperlaneTrackingInfo)(nil), "noble.dollar.vaults.v2.HyperlaneTrackingInfo")
	proto.RegisterType((*AUMOracleUpdate)(nil), "noble.dollar.vaults.v2.AUMOracleUpdate")
	proto.RegisterType((*CrossChainPositionSnapshot)(nil), "noble.dollar.vaults.v2.CrossChainPositionSnapshot")
	proto.RegisterMapType((map[uint32]string)(nil), "noble.dollar.vaults.v2.CrossChainPositionSnapshot.ValueByRouteEntry")
	proto.RegisterType((*CrossChainConfig)(nil), "noble.dollar.vaults.v2.CrossChainConfig")
	proto.RegisterType((*StaleInflightAlert)(nil), "noble.dollar.vaults.v2.StaleInflightAlert")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v2/cross_chain.proto", fileDescriptor_4abec74535b2c22a)
}

var fileDescriptor_4abec74535b2c22a = []byte{
	// 1698 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x6f, 0x23, 0x49,
	0x15, 0x4f, 0xdb, 0xf9, 0x2c, 0x7f, 0xa4, 0x53, 0x49, 0x66, 0x3c, 0x99, 0x99, 0x24, 0x9b, 0x65,
	0x21, 0x8c, 0x36, 0xf6, 0x92, 0x95, 0x10, 0x02, 0x01, 0xea, 0xd8, 0x3d, 0xe3, 0x46, 0x9e, 0xd8,
	0xd4, 0x78, 0x66, 0xc4, 0x1e, 0x68, 0xca, 0xdd, 0x15, 0x77, 0x93, 0x76, 0x57, 0xd3, 0x5d, 0xed,
	0xb5, 0xe1, 0xca, 0x01, 0x6e, 0x7b, 0xe4, 0xc2, 0x89, 0xcb, 0xde, 0x40, 0x88, 0x3f, 0x62, 0xb9,
	0xad, 0x38, 0x21, 0x0e, 0x0b, 0x9a, 0x39, 0xf0, 0x5f, 0x20, 0x54, 0x1f, 0xed, 0xaf, 0x24, 0xd2,
	0x12, 0xb2, 0x97, 0xc8, 0xfd, 0xab, 0xf7, 0x7e, 0xef, 0xd5, 0xfb, 0xaa, 0xa7, 0x80, 0xe3, 0x90,
	0xf6, 0x02, 0x52, 0x73, 0x69, 0x10, 0xe0, 0xb8, 0x36, 0xc4, 0x69, 0xc0, 0x92, 0xda, 0xf0, 0xb4,
	0xe6, 0xc4, 0x34, 0x49, 0x6c, 0xc7, 0xc3, 0x7e, 0x58, 0x8d, 0x62, 0xca, 0x28, 0xbc, 0x27, 0x24,
	0xab, 0x52, 0xb2, 0x2a, 0x25, 0xab, 0xc3, 0xd3, 0xbd, 0x2d, 0x3c, 0xf0, 0x43, 0x5a, 0x13, 0x7f,
	0xa5, 0xe8, 0xde, 0x03, 0x87, 0x26, 0x03, 0x9a, 0xd8, 0xe2, 0xab, 0x26, 0x3f, 0xd4, 0xd1, 0x4e,
	0x9f, 0xf6, 0xa9, 0xc4, 0xf9, 0x2f, 0x85, 0x1e, 0xf4, 0x29, 0xed, 0x07, 0xa4, 0x26, 0xbe, 0x7a,
	0xe9, 0x45, 0x8d, 0xf9, 0x03, 0x92, 0x30, 0x3c, 0x88, 0x94, 0xc0, 0x63, 0x6f, 0x1c, 0x91, 0x38,
	0xc0, 0x21, 0xa9, 0x7d, 0x8c, 0xe3, 0xa8, 0x36, 0xfc, 0x56, 0x8d, 0x8d, 0x23, 0xa2, 0x58, 0x8f,
	0xfe, 0x9a, 0x07, 0x9b, 0x75, 0xee, 0x71, 0x9d, 0x3b, 0x8c, 0x68, 0xca, 0x08, 0x74, 0x41, 0xc1,
	0x1b, 0x47, 0x8c, 0x5e, 0x92, 0xd0, 0xf6, 0xdd, 0x8a, 0x76, 0xa8, 0x1d, 0x6f, 0x9c, 0xd5, 0x3f,
	0xfb, 0xe2, 0x60, 0xe9, 0x1f, 0x5f, 0x1c, 0x7c, 0xaf, 0xef, 0x33, 0x2f, 0xed, 0x55, 0x1d, 0x3a,
	0xa8, 0xf5, 0x9c, 0xe8, 0xc4, 0x0f, 0x43, 0x3a, 0xc4, 0xcc, 0xa7, 0x61, 0x52, 0x9b, 0x98, 0x3a,
	0x91, 0x9e, 0xd7, 0x52, 0xe6, 0x07, 0xd5, 0x26, 0x19, 0x19, 0xae, 0x1b, 0x93, 0x24, 0x41, 0x20,
	0xe3, 0xb5, 0x5c, 0x98, 0x80, 0xed, 0x98, 0x38, 0xc4, 0x1f, 0x92, 0x58, 0x46, 0xcb, 0xf6, 0x28,
	0xbd, 0xac, 0xe4, 0xee, 0xce, 0xda, 0x56, 0xc6, 0x2f, 0xee, 0xd6, 0xa4, 0xf4, 0x12, 0xfe, 0x0a,
	0xdc, 0x8f, 0xc9, 0x80, 0x32, 0x62, 0x47, 0x34, 0xf1, 0x39, 0x8f, 0x8d, 0xa5, 0x74, 0x25, 0x7f,
	0x77, 0x86, 0x77, 0xa5, 0x8d, 0x8e, 0x32, 0xa1, 0x60, 0xf8, 0x53, 0x00, 0x07, 0x78, 0x64, 0xfb,
	0xe1, 0x45, 0xe0, 0xf7, 0x3d, 0x66, 0x0f, 0x71, 0x90, 0x92, 0xca, 0xb2, 0xb0, 0xfb, 0x81, 0xb2,
	0xbb, 0x2b, 0x29, 0x13, 0xf7, 0xb2, 0xea, 0xd3, 0xda, 0x00, 0x33, 0xaf, 0x6a, 0x85, 0xec, 0x6f,
	0x7f, 0x39, 0x01, 0xaa, 0x18, 0xac, 0x90, 0x7d, 0xfa, 0xef, 0x3f, 0x3d, 0xd1, 0x90, 0x3e, 0xc0,
	0x23, 0x4b, 0x51, 0xbd, 0xe2, 0x4c, 0x47, 0xbf, 0x5b, 0x05, 0x65, 0x34, 0x67, 0x19, 0x96, 0x41,
	0x4e, 0x65, 0x70, 0x19, 0xe5, 0x7c, 0x77, 0x31, 0xb5, 0xb9, 0xaf, 0x26, 0xb5, 0x1e, 0x28, 0x89,
	0x2a, 0x9f, 0x8b, 0x6d, 0xf1, 0x6e, 0xec, 0x14, 0x05, 0x73, 0x16, 0xd2, 0x1f, 0x83, 0x42, 0xe2,
	0xe1, 0x98, 0x24, 0xb6, 0x47, 0x02, 0xf7, 0xd6, 0xb1, 0x04, 0x92, 0xa4, 0x49, 0x02, 0x17, 0x9e,
	0x83, 0x8d, 0x28, 0xf6, 0x43, 0xc7, 0x8f, 0x70, 0x50, 0x59, 0xb9, 0x25, 0xe1, 0x94, 0x02, 0xbe,
	0x56, 0x2e, 0xda, 0x51, 0xec, 0x3b, 0xa4, 0xb2, 0x2a, 0x18, 0xbf, 0xad, 0x18, 0x1f, 0x5e, 0x65,
	0x6c, 0x91, 0x3e, 0x76, 0xc6, 0x0d, 0xe2, 0xcc, 0xf0, 0x36, 0x88, 0x33, 0xeb, 0x68, 0x87, 0x33,
	0xf1, 0xbb, 0x33, 0xca, 0x70, 0xa0, 0xea, 0x68, 0xed, 0xb6, 0x77, 0x17, 0x24, 0xa2, 0x82, 0xa0,
	0x09, 0x0a, 0x01, 0x4e, 0x98, 0x9d, 0x46, 0x2e, 0x66, 0xa4, 0xb2, 0x7e, 0xa8, 0x1d, 0x17, 0x4e,
	0xf7, 0xaa, 0x72, 0xc6, 0x54, 0xb3, 0x19, 0x53, 0xed, 0x66, 0x33, 0xe6, 0x6c, 0x9d, 0x9b, 0xfb,
	0xe4, 0x9f, 0x07, 0x1a, 0x02, 0x5c, 0xf1, 0xa5, 0xd0, 0x83, 0x0d, 0xb0, 0x9a, 0x30, 0xcc, 0xd2,
	0xa4, 0xb2, 0x71, 0xa8, 0x1d, 0x97, 0x4f, 0xdf, 0xaf, 0x5e, 0x3f, 0x01, 0xab, 0xf3, 0xd5, 0xfa,
	0x42, 0xe8, 0x20, 0xa5, 0x0b, 0xdf, 0x03, 0x65, 0x1a, 0x63, 0x27, 0x20, 0x93, 0x32, 0x02, 0xfc,
	0x8a, 0xa8, 0x24, 0xd1, 0xac, 0x04, 0xde, 0x05, 0x25, 0xde, 0x55, 0x09, 0xc3, 0x01, 0x09, 0xb9,
	0x54, 0xe1, 0x50, 0x3b, 0xce, 0xa3, 0xe2, 0x00, 0x8f, 0x5e, 0x64, 0xd8, 0xd1, 0x1f, 0x97, 0x41,
	0x31, 0x6b, 0x96, 0xa7, 0x69, 0xe8, 0x5e, 0x69, 0x8c, 0xf7, 0x01, 0x5c, 0x1c, 0x0c, 0xaa, 0x3f,
	0x96, 0x91, 0x3e, 0xdf, 0xce, 0x96, 0x0b, 0x9b, 0x60, 0x15, 0x0f, 0x68, 0x1a, 0xb2, 0x5b, 0x57,
	0x9c, 0xd2, 0x87, 0xcf, 0x40, 0xd1, 0x0f, 0x7d, 0xe6, 0x63, 0x46, 0x5c, 0x1b, 0x33, 0x11, 0xb0,
	0x2f, 0x1b, 0xf2, 0xc2, 0x44, 0xd3, 0x60, 0x3c, 0x75, 0x64, 0x14, 0x11, 0x47, 0xf1, 0x80, 0xff,
	0x25, 0x75, 0x99, 0xa2, 0xc1, 0xe0, 0x0f, 0x26, 0xa9, 0x2b, 0x88, 0xd4, 0x7d, 0xfd, 0xa6, 0xd4,
	0x65, 0xd1, 0x5c, 0x48, 0xda, 0xcf, 0xc0, 0xb6, 0x28, 0x47, 0x1b, 0x33, 0x5b, 0xb9, 0xe7, 0xd3,
	0xb0, 0x52, 0xbc, 0x65, 0x98, 0xb6, 0x04, 0x99, 0xc1, 0xac, 0x09, 0x15, 0x24, 0xe0, 0xfe, 0x64,
	0x48, 0xd8, 0x2c, 0xc6, 0xce, 0xa5, 0x1f, 0xf6, 0xf9, 0x50, 0xa5, 0x95, 0x92, 0xb8, 0xf4, 0xc9,
	0x4d, 0x2e, 0x37, 0x33, 0xb5, 0xae, 0xd2, 0xb2, 0xc2, 0x0b, 0x8a, 0x76, 0xbd, 0xeb, 0xe0, 0xa3,
	0xff, 0x68, 0x60, 0xf7, 0x5a, 0x05, 0xf8, 0x18, 0x80, 0x01, 0x49, 0x12, 0xdc, 0x27, 0xd9, 0xeb,
	0x58, 0x44, 0x1b, 0x0a, 0xb1, 0x5c, 0x5e, 0x8f, 0x34, 0xf6, 0xfb, 0x7e, 0x68, 0xbb, 0x74, 0x80,
	0xfd, 0x50, 0x14, 0x51, 0x09, 0x15, 0x25, 0xd8, 0x10, 0x18, 0x3c, 0x01, 0xd0, 0x25, 0x09, 0xf3,
	0x43, 0x71, 0xa7, 0x4c, 0x32, 0x2f, 0x24, 0xb7, 0x66, 0x4e, 0x94, 0xf8, 0xd7, 0x78, 0x2b, 0x08,
	0x4e, 0x36, 0xb2, 0x3d, 0x9c, 0x78, 0x72, 0x30, 0x65, 0xa4, 0xdd, 0x51, 0x13, 0x27, 0x1e, 0xac,
	0x82, 0xed, 0x59, 0xd2, 0x4c, 0x54, 0x4c, 0x9c, 0x39, 0x56, 0x25, 0xff, 0x88, 0x4f, 0x3a, 0xea,
	0x90, 0x24, 0x21, 0xae, 0x18, 0x1f, 0xeb, 0x68, 0x0a, 0x1c, 0x7d, 0x9a, 0x07, 0x9b, 0xc6, 0xcb,
	0xe7, 0x6d, 0xd1, 0x6c, 0xaa, 0xb1, 0x0f, 0x40, 0x61, 0xb6, 0x3d, 0x64, 0xfb, 0x80, 0x68, 0xda,
	0x18, 0x0b, 0xc3, 0x2e, 0x77, 0x97, 0xc3, 0x6e, 0x76, 0xd0, 0xe7, 0xef, 0x60, 0xd0, 0x9f, 0x81,
	0x8d, 0xc9, 0xb2, 0x24, 0xfa, 0xf8, 0xcb, 0xf6, 0xcb, 0x54, 0x0d, 0xbe, 0x03, 0x8a, 0x09, 0x4d,
	0x63, 0x87, 0xc8, 0x15, 0x46, 0xa5, 0xa5, 0x20, 0x31, 0xb1, 0x76, 0x2c, 0x94, 0x8b, 0x4c, 0xc6,
	0x4c, 0xb9, 0x9c, 0x4d, 0x1a, 0x6e, 0x4d, 0x34, 0xdc, 0x93, 0x9b, 0xaa, 0x77, 0x36, 0x11, 0xf3,
	0x4d, 0x77, 0xf4, 0xeb, 0x65, 0xb0, 0x37, 0x5d, 0xe2, 0x26, 0xe3, 0x34, 0xc4, 0x51, 0xe2, 0x51,
	0xc6, 0xf7, 0x0e, 0xf9, 0x50, 0xa8, 0x09, 0x27, 0xdf, 0x0b, 0xed, 0xb6, 0x7b, 0x87, 0xe0, 0x92,
	0x93, 0x5b, 0xbe, 0x1a, 0x3d, 0xb0, 0x23, 0xf9, 0x17, 0x36, 0x9b, 0xdc, 0x2d, 0x2d, 0x48, 0x6f,
	0xe7, 0x76, 0x1b, 0xf8, 0x4d, 0xa0, 0x63, 0x87, 0xf9, 0xc3, 0xe9, 0x7c, 0x96, 0x5b, 0x45, 0x1e,
	0x6d, 0x4a, 0x3c, 0xbb, 0x75, 0x02, 0xbf, 0x01, 0x36, 0xc5, 0x63, 0x30, 0x23, 0xb9, 0x2c, 0x24,
	0xcb, 0x02, 0x9e, 0x0a, 0xbe, 0x03, 0x8a, 0xbd, 0x80, 0x3a, 0x97, 0xb6, 0x47, 0xb8, 0x21, 0x91,
	0xbc, 0x3c, 0x2a, 0x08, 0xac, 0x29, 0x20, 0xf8, 0x73, 0x50, 0x96, 0xe3, 0xac, 0x37, 0xb6, 0x63,
	0xbe, 0x1c, 0x57, 0x56, 0x0f, 0xf3, 0xc7, 0x85, 0xd3, 0xc6, 0x4d, 0x59, 0xba, 0x39, 0x0d, 0x55,
	0x71, 0x91, 0xb3, 0xb1, 0xd8, 0xb1, 0xcd, 0x90, 0xc5, 0x63, 0xbe, 0xcb, 0x4c, 0xa1, 0xbd, 0x1f,
	0x82, 0xad, 0x2b, 0x22, 0x50, 0x07, 0xf9, 0x4b, 0x32, 0x16, 0xc9, 0x2a, 0x21, 0xfe, 0x13, 0xee,
	0x80, 0x95, 0x99, 0xf0, 0x22, 0xf9, 0xf1, 0xdd, 0xdc, 0x77, 0xb4, 0xa3, 0xdf, 0xe7, 0x81, 0x3e,
	0xb5, 0x5f, 0xa7, 0xe1, 0x85, 0xdf, 0xe7, 0x43, 0x81, 0x3f, 0x8f, 0x2a, 0xf5, 0x64, 0x14, 0xd1,
	0x24, 0x8d, 0x65, 0xf6, 0x57, 0xd0, 0xd6, 0x00, 0x8f, 0x64, 0x26, 0x4d, 0x75, 0xc0, 0xa3, 0xe7,
	0x92, 0x0b, 0xb1, 0xbd, 0xf1, 0x32, 0xa7, 0x29, 0x13, 0x86, 0xf2, 0xa8, 0xac, 0xe0, 0xae, 0x44,
	0x79, 0x46, 0xe4, 0x9a, 0x60, 0x5f, 0xc4, 0xe4, 0x17, 0x29, 0x09, 0x9d, 0x71, 0x96, 0x11, 0x89,
	0x3f, 0xcd, 0x60, 0xf8, 0x01, 0xd8, 0x99, 0xf1, 0x61, 0x3e, 0x2d, 0x25, 0x04, 0x27, 0x4e, 0x4c,
	0x53, 0xf3, 0x1e, 0x28, 0xe3, 0x20, 0xa0, 0x1f, 0x13, 0x57, 0x36, 0x56, 0x52, 0x59, 0x39, 0xcc,
	0xf3, 0xb7, 0x5f, 0xa1, 0xe2, 0x86, 0x09, 0xac, 0x80, 0x35, 0x12, 0xe2, 0x5e, 0x40, 0x64, 0x63,
	0xad, 0xa3, 0xec, 0x13, 0x9e, 0x82, 0xdd, 0xb9, 0x5d, 0xdb, 0x4d, 0x63, 0xf9, 0x12, 0xad, 0x09,
	0x17, 0xb7, 0x67, 0x96, 0xe7, 0x86, 0x3a, 0xba, 0x61, 0x3f, 0x5f, 0xbf, 0xb3, 0xfd, 0xfc, 0xb7,
	0x39, 0x00, 0xc5, 0x4a, 0x92, 0xc1, 0x46, 0x40, 0x62, 0x06, 0x1f, 0x80, 0x75, 0x51, 0x5a, 0xd9,
	0x44, 0x2d, 0xa1, 0x35, 0xf1, 0x6d, 0xb9, 0x3c, 0x0c, 0x2c, 0xc6, 0x61, 0xc2, 0x4b, 0x7c, 0xba,
	0x91, 0x6c, 0xa0, 0xd2, 0x0c, 0x2a, 0x9f, 0x1c, 0x8f, 0xa6, 0x71, 0x62, 0xd3, 0x21, 0x89, 0xdd,
	0x94, 0x88, 0x3c, 0x68, 0xa8, 0x28, 0xc0, 0xb6, 0xc4, 0xee, 0x64, 0xdc, 0x4d, 0xf7, 0x9e, 0x95,
	0xff, 0x6f, 0xef, 0x79, 0xf2, 0x67, 0x0d, 0xec, 0x5c, 0xb7, 0xfd, 0xc1, 0x43, 0xf0, 0x08, 0x99,
	0xcf, 0xdb, 0x5d, 0xd3, 0xee, 0xb4, 0x5f, 0x58, 0x5d, 0xab, 0x7d, 0x6e, 0x5b, 0xe7, 0x56, 0xd7,
	0x32, 0x5a, 0xd6, 0x47, 0xd6, 0xf9, 0x33, 0x7d, 0x09, 0xee, 0x81, 0x7b, 0x8b, 0x12, 0x46, 0xbd,
	0x6b, 0xbd, 0x32, 0x75, 0x0d, 0x1e, 0x80, 0x87, 0x8b, 0x67, 0xaf, 0xad, 0x6e, 0xb3, 0x81, 0x8c,
	0xd7, 0x5c, 0x39, 0x77, 0x9d, 0x72, 0xbd, 0xd5, 0x7e, 0x61, 0x36, 0xf4, 0x3c, 0x7c, 0x00, 0x76,
	0x17, 0xcf, 0x4c, 0x84, 0xda, 0x48, 0x5f, 0xde, 0x5b, 0xfe, 0xcd, 0x1f, 0xf6, 0x97, 0x9e, 0x84,
	0xa0, 0xd4, 0x8e, 0x88, 0xac, 0x96, 0xee, 0x38, 0x22, 0x9c, 0xad, 0xdd, 0x31, 0x91, 0x21, 0x64,
	0xbb, 0x3f, 0xe9, 0x98, 0x76, 0xc3, 0x14, 0xba, 0xfa, 0x12, 0x7c, 0x0c, 0x1e, 0x2c, 0x9c, 0x65,
	0x9e, 0x18, 0x2d, 0x5d, 0x83, 0x8f, 0x40, 0x65, 0xe1, 0x18, 0x99, 0x67, 0x46, 0xcb, 0x38, 0xaf,
	0x9b, 0x7a, 0x4e, 0xd9, 0xa3, 0xa0, 0x3c, 0xbf, 0x66, 0xc1, 0x1d, 0xa0, 0x5b, 0xe7, 0x4f, 0x5b,
	0xd6, 0xb3, 0x66, 0xd7, 0xee, 0x98, 0xe7, 0x0d, 0x19, 0x91, 0x7b, 0x00, 0x4e, 0xd0, 0x7a, 0xfb,
	0x79, 0xa7, 0x65, 0x76, 0xcd, 0x86, 0xae, 0xc1, 0x6d, 0xb0, 0x39, 0xc1, 0x9f, 0x1a, 0x56, 0xcb,
	0x6c, 0xe8, 0xb9, 0x39, 0x8a, 0xae, 0xf5, 0xdc, 0x6c, 0xbf, 0xec, 0xea, 0xf9, 0xc9, 0x05, 0xe1,
	0xd5, 0x67, 0x06, 0x3e, 0x04, 0xf7, 0xdb, 0xc8, 0xa8, 0xb7, 0x4c, 0xfb, 0x65, 0xa7, 0x61, 0x74,
	0x4d, 0xfb, 0x95, 0xd1, 0xb2, 0xf8, 0x8f, 0x86, 0xbe, 0xc4, 0x83, 0x36, 0x7f, 0x68, 0x74, 0x3a,
	0x2d, 0x4b, 0x98, 0xe7, 0xd1, 0x99, 0x3b, 0x42, 0xe6, 0x8f, 0xcc, 0x3a, 0x57, 0x53, 0x17, 0x3c,
	0xfb, 0xfe, 0x67, 0x6f, 0xf6, 0xb5, 0xcf, 0xdf, 0xec, 0x6b, 0xff, 0x7a, 0xb3, 0xaf, 0x7d, 0xf2,
	0x76, 0x7f, 0xe9, 0xf3, 0xb7, 0xfb, 0x4b, 0x7f, 0x7f, 0xbb, 0xbf, 0xf4, 0xd1, 0xbb, 0x6a, 0xb2,
	0xca, 0x31, 0x3b, 0x1a, 0xff, 0xb2, 0x36, 0xfc, 0x50, 0xfe, 0xe3, 0x62, 0xfa, 0xaf, 0x96, 0xde,
	0xaa, 0xa8, 0xdb, 0x0f, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xe9, 0xd1, 0x6d, 0xfa, 0x8b, 0x11,
	0x00, 0x00,
}

func (m *CrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxInflightValue.Size()
		i -= size
		if _, err := m.MaxInflightValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.RemotePositionAddress.Size()
		i -= size
		if _, err := m.RemotePositionAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.ReceiverChainHook.Size()
		i -= size
		if _, err := m.ReceiverChainHook.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.HyptokenId.Size()
		i -= size
		if _, err := m.HyptokenId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RemotePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemotePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemotePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxStaleness != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxStaleness))
		i--
		dAtA[i] = 0x58
	}
	if len(m.OracleAddress) > 0 {
		i -= len(m.OracleAddress)
		copy(dAtA[i:], m.OracleAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.OracleAddress)))
		i--
		dAtA[i] = 0x52
	}
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastUpdate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintCrossChain(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x42
	{
		size := m.TotalValue.Size()
		i -= size
		if _, err := m.TotalValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Principal.Size()
		i -= size
		if _, err := m.Principal.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.SharesHeld.Size()
		i -= size
		if _, err := m.SharesHeld.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.VaultAddress.Size()
		i -= size
		if _, err := m.VaultAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.HyptokenId.Size()
		i -= size
		if _, err := m.HyptokenId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Id != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InflightFund) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InflightFund) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InflightFund) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HyperlaneTrackingInfo != nil {
		{
			size, err := m.HyperlaneTrackingInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	{
		size := m.ValueAtInitiation.Size()
		i -= size
		if _, err := m.ValueAtInitiation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x58
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintCrossChain(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x52
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.InitiatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintCrossChain(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x4a
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.RemotePositionId != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.RemotePositionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HyperlaneTrackingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HyperlaneTrackingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HyperlaneTrackingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Processed {
		i--
		if m.Processed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.DestinationTxHash) > 0 {
		i -= len(m.DestinationTxHash)
		copy(dAtA[i:], m.DestinationTxHash)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.DestinationTxHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OriginTxHash) > 0 {
		i -= len(m.OriginTxHash)
		copy(dAtA[i:], m.OriginTxHash)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.OriginTxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x18
	}
	if m.OriginDomain != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.OriginDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MessageId) > 0 {
		i -= len(m.MessageId)
		copy(dAtA[i:], m.MessageId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.MessageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AUMOracleUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AUMOracleUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AUMOracleUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.MessageId) > 0 {
		i -= len(m.MessageId)
		copy(dAtA[i:], m.MessageId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.MessageId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SourceChain) > 0 {
		i -= len(m.SourceChain)
		copy(dAtA[i:], m.SourceChain)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.SourceChain)))
		i--
		dAtA[i] = 0x2a
	}
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintCrossChain(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x22
	{
		size := m.SharesHeld.Size()
		i -= size
		if _, err := m.SharesHeld.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PositionId != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainPositionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainPositionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainPositionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValueByRoute) > 0 {
		for k := range m.ValueByRoute {
			v := m.ValueByRoute[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCrossChain(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintCrossChain(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCrossChain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.BlockHeight != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.StalePositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.StalePositions))
		i--
		dAtA[i] = 0x20
	}
	if m.ActivePositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.ActivePositions))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalInflightValue.Size()
		i -= size
		if _, err := m.TotalInflightValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalRemoteValue.Size()
		i -= size
		if _, err := m.TotalRemoteValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CrossChainConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxInflightValue.Size()
		i -= size
		if _, err := m.MaxInflightValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.MaxInflightDuration != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxInflightDuration))
		i--
		dAtA[i] = 0x38
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.AllowedChains) > 0 {
		for iNdEx := len(m.AllowedChains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedChains[iNdEx])
			copy(dAtA[i:], m.AllowedChains[iNdEx])
			i = encodeVarintCrossChain(dAtA, i, uint64(len(m.AllowedChains[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxRemotePositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxRemotePositions))
		i--
		dAtA[i] = 0x20
	}
	if m.UpdateFrequency != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.UpdateFrequency))
		i--
		dAtA[i] = 0x18
	}
	if m.DefaultTimeout != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DefaultTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxRemoteExposure != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxRemoteExposure))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StaleInflightAlert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaleInflightAlert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaleInflightAlert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintCrossChain(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x22
	if m.HoursOverdue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.HoursOverdue))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.TransactionId) > 0 {
		i -= len(m.TransactionId)
		copy(dAtA[i:], m.TransactionId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.TransactionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.RouteId != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.RouteId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCrossChain(dAtA []byte, offset int, v uint64) int {
	offset -= sovCrossChain(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.HyptokenId.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.ReceiverChainHook.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.RemotePositionAddress.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.MaxInflightValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	return n
}

func (m *RemotePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCrossChain(uint64(m.Id))
	}
	l = m.HyptokenId.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.VaultAddress.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.SharesHeld.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.Principal.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.TotalValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate)
	n += 1 + l + sovCrossChain(uint64(l))
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	l = len(m.OracleAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.MaxStaleness != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxStaleness))
	}
	return n
}

func (m *InflightFund) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCrossChain(uint64(m.Id))
	}
	if m.RemotePositionId != 0 {
		n += 1 + sovCrossChain(uint64(m.RemotePositionId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt)
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedAt)
	n += 1 + l + sovCrossChain(uint64(l))
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	l = m.ValueAtInitiation.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.HyperlaneTrackingInfo != nil {
		l = m.HyperlaneTrackingInfo.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}

func (m *HyperlaneTrackingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.OriginDomain != 0 {
		n += 1 + sovCrossChain(uint64(m.OriginDomain))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovCrossChain(uint64(m.DestinationDomain))
	}
	l = len(m.OriginTxHash)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.DestinationTxHash)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Processed {
		n += 2
	}
	return n
}

func (m *AUMOracleUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovCrossChain(uint64(m.PositionId))
	}
	l = m.SharePrice.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.SharesHeld.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovCrossChain(uint64(l))
	l = len(m.SourceChain)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	return n
}

func (m *CrossChainPositionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalRemoteValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.TotalInflightValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.ActivePositions != 0 {
		n += 1 + sovCrossChain(uint64(m.ActivePositions))
	}
	if m.StalePositions != 0 {
		n += 1 + sovCrossChain(uint64(m.StalePositions))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovCrossChain(uint64(m.BlockHeight))
	}
	if len(m.ValueByRoute) > 0 {
		for k, v := range m.ValueByRoute {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCrossChain(uint64(k)) + 1 + len(v) + sovCrossChain(uint64(len(v)))
			n += mapEntrySize + 1 + sovCrossChain(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CrossChainConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRemoteExposure != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxRemoteExposure))
	}
	if m.DefaultTimeout != 0 {
		n += 1 + sovCrossChain(uint64(m.DefaultTimeout))
	}
	if m.UpdateFrequency != 0 {
		n += 1 + sovCrossChain(uint64(m.UpdateFrequency))
	}
	if m.MaxRemotePositions != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxRemotePositions))
	}
	if len(m.AllowedChains) > 0 {
		for _, s := range m.AllowedChains {
			l = len(s)
			n += 1 + l + sovCrossChain(uint64(l))
		}
	}
	if m.Enabled {
		n += 2
	}
	if m.MaxInflightDuration != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxInflightDuration))
	}
	l = m.MaxInflightValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	return n
}

func (m *StaleInflightAlert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteId != 0 {
		n += 1 + sovCrossChain(uint64(m.RouteId))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.HoursOverdue != 0 {
		n += 9
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.Amount.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	return n
}

func sovCrossChain(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCrossChain(x uint64) (n int) {
	return sovCrossChain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyptokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HyptokenId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverChainHook", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReceiverChainHook.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePositionAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemotePositionAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInflightValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxInflightValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemotePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemotePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemotePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyptokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HyptokenId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VaultAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesHeld", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesHeld.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Principal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RemotePositionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStaleness", wireType)
			}
			m.MaxStaleness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxStaleness |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InflightFund) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InflightFund: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InflightFund: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePositionId", wireType)
			}
			m.RemotePositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemotePositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.InitiatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InflightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueAtInitiation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValueAtInitiation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyperlaneTrackingInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HyperlaneTrackingInfo == nil {
				m.HyperlaneTrackingInfo = &HyperlaneTrackingInfo{}
			}
			if err := m.HyperlaneTrackingInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HyperlaneTrackingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HyperlaneTrackingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HyperlaneTrackingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = append(m.MessageId[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageId == nil {
				m.MessageId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginDomain", wireType)
			}
			m.OriginDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Processed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AUMOracleUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AUMOracleUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AUMOracleUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesHeld", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesHeld.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OracleUpdateStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainPositionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainPositionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainPositionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRemoteValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRemoteValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalInflightValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalInflightValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePositions", wireType)
			}
			m.ActivePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivePositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalePositions", wireType)
			}
			m.StalePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StalePositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueByRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValueByRoute == nil {
				m.ValueByRoute = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCrossChain
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCrossChain
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCrossChain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCrossChain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ValueByRoute[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRemoteExposure", wireType)
			}
			m.MaxRemoteExposure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRemoteExposure |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTimeout", wireType)
			}
			m.DefaultTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateFrequency", wireType)
			}
			m.UpdateFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateFrequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRemotePositions", wireType)
			}
			m.MaxRemotePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRemotePositions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedChains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedChains = append(m.AllowedChains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInflightDuration", wireType)
			}
			m.MaxInflightDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInflightDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInflightValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxInflightValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaleInflightAlert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaleInflightAlert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaleInflightAlert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteId", wireType)
			}
			m.RouteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoursOverdue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.HoursOverdue = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrossChain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCrossChain
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCrossChain
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCrossChain
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCrossChain        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrossChain          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCrossChain = fmt.Errorf("proto: unexpected end of group")
)
