// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noble/dollar/vaults/v2/cross_chain.proto

package v2

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_bcp_innovations_hyperlane_cosmos_util "github.com/bcp-innovations/hyperlane-cosmos/util"
	_ "github.com/bcp-innovations/hyperlane-cosmos/x/warp/types"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// OperationType represents the type of cross-chain operation
type OperationType int32

const (
	// Deposit operation
	OPERATION_TYPE_DEPOSIT OperationType = 0
	// Withdrawal operation
	OPERATION_TYPE_WITHDRAWAL OperationType = 1
)

var OperationType_name = map[int32]string{
	0: "OPERATION_TYPE_DEPOSIT",
	1: "OPERATION_TYPE_WITHDRAWAL",
}

var OperationType_value = map[string]int32{
	"OPERATION_TYPE_DEPOSIT":    0,
	"OPERATION_TYPE_WITHDRAWAL": 1,
}

func (x OperationType) String() string {
	return proto.EnumName(OperationType_name, int32(x))
}

func (OperationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{0}
}

// InflightDirection represents the direction of funds in transit
type InflightDirection int32

const (
	// Funds leaving vault (deploying to remote position)
	INFLIGHT_OUTGOING InflightDirection = 0
	// Funds returning to vault (withdrawing from remote position)
	INFLIGHT_INCOMING InflightDirection = 1
)

var InflightDirection_name = map[int32]string{
	0: "INFLIGHT_OUTGOING",
	1: "INFLIGHT_INCOMING",
}

var InflightDirection_value = map[string]int32{
	"INFLIGHT_OUTGOING": 0,
	"INFLIGHT_INCOMING": 1,
}

func (x InflightDirection) String() string {
	return proto.EnumName(InflightDirection_name, int32(x))
}

func (InflightDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{1}
}

// InflightStatus represents the status of inflight funds
type InflightStatus int32

const (
	// Transaction is pending
	INFLIGHT_PENDING InflightStatus = 0
	// Transaction completed successfully
	INFLIGHT_COMPLETED InflightStatus = 1
	// Transaction failed
	INFLIGHT_FAILED InflightStatus = 2
	// Transaction timed out
	INFLIGHT_TIMEOUT InflightStatus = 3
)

var InflightStatus_name = map[int32]string{
	0: "INFLIGHT_PENDING",
	1: "INFLIGHT_COMPLETED",
	2: "INFLIGHT_FAILED",
	3: "INFLIGHT_TIMEOUT",
}

var InflightStatus_value = map[string]int32{
	"INFLIGHT_PENDING":   0,
	"INFLIGHT_COMPLETED": 1,
	"INFLIGHT_FAILED":    2,
	"INFLIGHT_TIMEOUT":   3,
}

func (x InflightStatus) String() string {
	return proto.EnumName(InflightStatus_name, int32(x))
}

func (InflightStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{2}
}

// CrossChainRoute defines a route for cross-chain operations
// Currently supports Hyperlane, with potential for future IBC support
type CrossChainRoute struct {
	// HypToken
	HyptokenId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,1,opt,name=hyptoken_id,json=hyptokenId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"hyptoken_id"`
	// Reciever chain hook;
	ReceiverChainHook github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,2,opt,name=receiver_chain_hook,json=receiverChainHook,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"receiver_chain_hook"`
	// Vault
	RemotePositionAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,3,opt,name=remote_position_address,json=remotePositionAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"remote_position_address"`
	// Maximum value allowed inflight on this route
	MaxInflightValue cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=max_inflight_value,json=maxInflightValue,proto3,customtype=cosmossdk.io/math.Int" json:"max_inflight_value"`
}

func (m *CrossChainRoute) Reset()         { *m = CrossChainRoute{} }
func (m *CrossChainRoute) String() string { return proto.CompactTextString(m) }
func (*CrossChainRoute) ProtoMessage()    {}
func (*CrossChainRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{0}
}
func (m *CrossChainRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainRoute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainRoute.Merge(m, src)
}
func (m *CrossChainRoute) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainRoute.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainRoute proto.InternalMessageInfo

// RemotePosition represents a position in an ERC-4626 compatible vault on another chain
type RemotePosition struct {
	// Remote Position ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// HypToken
	HyptokenId github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,2,opt,name=hyptoken_id,json=hyptokenId,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"hyptoken_id"`
	// Address of the ERC-4626 compatible vault
	VaultAddress github_com_bcp_innovations_hyperlane_cosmos_util.HexAddress `protobuf:"bytes,3,opt,name=vault_address,json=vaultAddress,proto3,customtype=github.com/bcp-innovations/hyperlane-cosmos/util.HexAddress" json:"vault_address"`
	// Number of vault shares held
	SharesHeld cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=shares_held,json=sharesHeld,proto3,customtype=cosmossdk.io/math.Int" json:"shares_held"`
	// Principal amount initially deposited (in USDN)
	Principal cosmossdk_io_math.Int `protobuf:"bytes,5,opt,name=principal,proto3,customtype=cosmossdk.io/math.Int" json:"principal"`
	// Current share price from oracle
	SharePrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=share_price,json=sharePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"share_price"`
	// Total value of position (shares * price)
	TotalValue cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=total_value,json=totalValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_value"`
	// Last oracle update timestamp
	LastUpdate time.Time `protobuf:"bytes,8,opt,name=last_update,json=lastUpdate,proto3,stdtime" json:"last_update"`
	// Oracle configuration for this position
	OracleAddress string `protobuf:"bytes,10,opt,name=oracle_address,json=oracleAddress,proto3" json:"oracle_address,omitempty"`
	// Maximum staleness for oracle data (seconds)
	MaxStaleness int64 `protobuf:"varint,11,opt,name=max_staleness,json=maxStaleness,proto3" json:"max_staleness,omitempty"`
}

func (m *RemotePosition) Reset()         { *m = RemotePosition{} }
func (m *RemotePosition) String() string { return proto.CompactTextString(m) }
func (*RemotePosition) ProtoMessage()    {}
func (*RemotePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{1}
}
func (m *RemotePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemotePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemotePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemotePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemotePosition.Merge(m, src)
}
func (m *RemotePosition) XXX_Size() int {
	return m.Size()
}
func (m *RemotePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_RemotePosition.DiscardUnknown(m)
}

var xxx_messageInfo_RemotePosition proto.InternalMessageInfo

func (m *RemotePosition) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RemotePosition) GetLastUpdate() time.Time {
	if m != nil {
		return m.LastUpdate
	}
	return time.Time{}
}

func (m *RemotePosition) GetOracleAddress() string {
	if m != nil {
		return m.OracleAddress
	}
	return ""
}

func (m *RemotePosition) GetMaxStaleness() int64 {
	if m != nil {
		return m.MaxStaleness
	}
	return 0
}

// InflightFund represents funds in transit between Noble and remote positions
type InflightFund struct {
	// Unique identifier for this inflight transaction
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Id of the corresponding RemotePosition
	RemotePositionId uint64 `protobuf:"varint,2,opt,name=remote_position_id,json=remotePositionId,proto3" json:"remote_position_id,omitempty"`
	// Direction of funds (outgoing to remote or incoming to vault)
	Direction InflightDirection `protobuf:"varint,3,opt,name=direction,proto3,enum=noble.dollar.vaults.v2.InflightDirection" json:"direction,omitempty"`
	// Amount in USDN (always USDN, never shares)
	Amount cosmossdk_io_math.Int `protobuf:"bytes,4,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	// When the operation was initiated
	InitiatedAt time.Time `protobuf:"bytes,9,opt,name=initiated_at,json=initiatedAt,proto3,stdtime" json:"initiated_at"`
	// Expected completion time
	ExpectedAt time.Time `protobuf:"bytes,10,opt,name=expected_at,json=expectedAt,proto3,stdtime" json:"expected_at"`
	// Current status
	Status InflightStatus `protobuf:"varint,11,opt,name=status,proto3,enum=noble.dollar.vaults.v2.InflightStatus" json:"status,omitempty"`
	// Value at initiation (for AUM calculation)
	ValueAtInitiation     cosmossdk_io_math.Int  `protobuf:"bytes,12,opt,name=value_at_initiation,json=valueAtInitiation,proto3,customtype=cosmossdk.io/math.Int" json:"value_at_initiation"`
	HyperlaneTrackingInfo *HyperlaneTrackingInfo `protobuf:"bytes,13,opt,name=hyperlane_tracking_info,json=hyperlaneTrackingInfo,proto3" json:"hyperlane_tracking_info,omitempty"`
}

func (m *InflightFund) Reset()         { *m = InflightFund{} }
func (m *InflightFund) String() string { return proto.CompactTextString(m) }
func (*InflightFund) ProtoMessage()    {}
func (*InflightFund) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{2}
}
func (m *InflightFund) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InflightFund) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InflightFund.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InflightFund) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InflightFund.Merge(m, src)
}
func (m *InflightFund) XXX_Size() int {
	return m.Size()
}
func (m *InflightFund) XXX_DiscardUnknown() {
	xxx_messageInfo_InflightFund.DiscardUnknown(m)
}

var xxx_messageInfo_InflightFund proto.InternalMessageInfo

func (m *InflightFund) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *InflightFund) GetRemotePositionId() uint64 {
	if m != nil {
		return m.RemotePositionId
	}
	return 0
}

func (m *InflightFund) GetDirection() InflightDirection {
	if m != nil {
		return m.Direction
	}
	return INFLIGHT_OUTGOING
}

func (m *InflightFund) GetInitiatedAt() time.Time {
	if m != nil {
		return m.InitiatedAt
	}
	return time.Time{}
}

func (m *InflightFund) GetExpectedAt() time.Time {
	if m != nil {
		return m.ExpectedAt
	}
	return time.Time{}
}

func (m *InflightFund) GetStatus() InflightStatus {
	if m != nil {
		return m.Status
	}
	return INFLIGHT_PENDING
}

func (m *InflightFund) GetHyperlaneTrackingInfo() *HyperlaneTrackingInfo {
	if m != nil {
		return m.HyperlaneTrackingInfo
	}
	return nil
}

// HyperlaneTrackingInfo contains Hyperlane-specific tracking data
type HyperlaneTrackingInfo struct {
	// Hyperlane message ID
	MessageId []byte `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Origin domain
	OriginDomain uint32 `protobuf:"varint,2,opt,name=origin_domain,json=originDomain,proto3" json:"origin_domain,omitempty"`
	// Destination domain
	DestinationDomain uint32 `protobuf:"varint,3,opt,name=destination_domain,json=destinationDomain,proto3" json:"destination_domain,omitempty"`
	// Transaction hash on origin chain
	OriginTxHash string `protobuf:"bytes,5,opt,name=origin_tx_hash,json=originTxHash,proto3" json:"origin_tx_hash,omitempty"`
	// Transaction hash on destination chain
	DestinationTxHash string `protobuf:"bytes,6,opt,name=destination_tx_hash,json=destinationTxHash,proto3" json:"destination_tx_hash,omitempty"`
	// Whether message has been processed
	Processed bool `protobuf:"varint,7,opt,name=processed,proto3" json:"processed,omitempty"`
}

func (m *HyperlaneTrackingInfo) Reset()         { *m = HyperlaneTrackingInfo{} }
func (m *HyperlaneTrackingInfo) String() string { return proto.CompactTextString(m) }
func (*HyperlaneTrackingInfo) ProtoMessage()    {}
func (*HyperlaneTrackingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{3}
}
func (m *HyperlaneTrackingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HyperlaneTrackingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HyperlaneTrackingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HyperlaneTrackingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HyperlaneTrackingInfo.Merge(m, src)
}
func (m *HyperlaneTrackingInfo) XXX_Size() int {
	return m.Size()
}
func (m *HyperlaneTrackingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HyperlaneTrackingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HyperlaneTrackingInfo proto.InternalMessageInfo

func (m *HyperlaneTrackingInfo) GetMessageId() []byte {
	if m != nil {
		return m.MessageId
	}
	return nil
}

func (m *HyperlaneTrackingInfo) GetOriginDomain() uint32 {
	if m != nil {
		return m.OriginDomain
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *HyperlaneTrackingInfo) GetOriginTxHash() string {
	if m != nil {
		return m.OriginTxHash
	}
	return ""
}

func (m *HyperlaneTrackingInfo) GetDestinationTxHash() string {
	if m != nil {
		return m.DestinationTxHash
	}
	return ""
}

func (m *HyperlaneTrackingInfo) GetProcessed() bool {
	if m != nil {
		return m.Processed
	}
	return false
}

// CrossChainPositionSnapshot provides a snapshot of all cross-chain positions
type CrossChainPositionSnapshot struct {
	// Total value of all remote positions
	TotalRemoteValue cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=total_remote_value,json=totalRemoteValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_remote_value"`
	// Total value of inflight funds
	TotalInflightValue cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=total_inflight_value,json=totalInflightValue,proto3,customtype=cosmossdk.io/math.Int" json:"total_inflight_value"`
	// Number of active remote positions
	ActivePositions int64 `protobuf:"varint,3,opt,name=active_positions,json=activePositions,proto3" json:"active_positions,omitempty"`
	// Number of positions with stale data
	StalePositions int64 `protobuf:"varint,4,opt,name=stale_positions,json=stalePositions,proto3" json:"stale_positions,omitempty"`
	// Snapshot block height
	BlockHeight int64 `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Breakdown by route
	ValueByRoute map[uint32]string `protobuf:"bytes,6,rep,name=value_by_route,json=valueByRoute,proto3" json:"value_by_route,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CrossChainPositionSnapshot) Reset()         { *m = CrossChainPositionSnapshot{} }
func (m *CrossChainPositionSnapshot) String() string { return proto.CompactTextString(m) }
func (*CrossChainPositionSnapshot) ProtoMessage()    {}
func (*CrossChainPositionSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_4abec74535b2c22a, []int{4}
}
func (m *CrossChainPositionSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossChainPositionSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossChainPositionSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossChainPositionSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossChainPositionSnapshot.Merge(m, src)
}
func (m *CrossChainPositionSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CrossChainPositionSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossChainPositionSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CrossChainPositionSnapshot proto.InternalMessageInfo

func (m *CrossChainPositionSnapshot) GetActivePositions() int64 {
	if m != nil {
		return m.ActivePositions
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetStalePositions() int64 {
	if m != nil {
		return m.StalePositions
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *CrossChainPositionSnapshot) GetValueByRoute() map[uint32]string {
	if m != nil {
		return m.ValueByRoute
	}
	return nil
}

func init() {
	proto.RegisterEnum("noble.dollar.vaults.v2.OperationType", OperationType_name, OperationType_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.InflightDirection", InflightDirection_name, InflightDirection_value)
	proto.RegisterEnum("noble.dollar.vaults.v2.InflightStatus", InflightStatus_name, InflightStatus_value)
	proto.RegisterType((*CrossChainRoute)(nil), "noble.dollar.vaults.v2.CrossChainRoute")
	proto.RegisterType((*RemotePosition)(nil), "noble.dollar.vaults.v2.RemotePosition")
	proto.RegisterType((*InflightFund)(nil), "noble.dollar.vaults.v2.InflightFund")
	proto.RegisterType((*HyperlaneTrackingInfo)(nil), "noble.dollar.vaults.v2.HyperlaneTrackingInfo")
	proto.RegisterType((*CrossChainPositionSnapshot)(nil), "noble.dollar.vaults.v2.CrossChainPositionSnapshot")
	proto.RegisterMapType((map[uint32]string)(nil), "noble.dollar.vaults.v2.CrossChainPositionSnapshot.ValueByRouteEntry")
}

func init() {
	proto.RegisterFile("noble/dollar/vaults/v2/cross_chain.proto", fileDescriptor_4abec74535b2c22a)
}

var fileDescriptor_4abec74535b2c22a = []byte{
	// 1279 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4f, 0x73, 0xdb, 0xc4,
	0x1b, 0xb6, 0x6c, 0x37, 0xbf, 0x66, 0xfd, 0x27, 0xf6, 0x26, 0x69, 0x5d, 0xff, 0xa8, 0x13, 0x52,
	0xfe, 0xa4, 0x1d, 0x22, 0x41, 0x3a, 0xc3, 0x30, 0x30, 0xc0, 0x38, 0xb1, 0x1b, 0x6b, 0x26, 0x8d,
	0x8d, 0xe2, 0xd2, 0x81, 0x03, 0x62, 0x2d, 0x6d, 0xad, 0xc5, 0x92, 0x56, 0xa3, 0x5d, 0x1b, 0x1b,
	0xae, 0x1c, 0x38, 0xf6, 0x3b, 0x70, 0xe1, 0xc8, 0x81, 0x0f, 0x51, 0x6e, 0x9d, 0x9e, 0x18, 0x0e,
	0x85, 0x69, 0x0f, 0x7c, 0x05, 0x4e, 0x0c, 0xa3, 0x5d, 0xc9, 0x7f, 0x92, 0x76, 0x98, 0x7a, 0xca,
	0x25, 0x63, 0x3d, 0x7a, 0xde, 0xe7, 0xdd, 0x7d, 0xdf, 0x77, 0x9f, 0x55, 0xc0, 0xae, 0x4f, 0x7b,
	0x2e, 0xd6, 0x6c, 0xea, 0xba, 0x28, 0xd4, 0x46, 0x68, 0xe8, 0x72, 0xa6, 0x8d, 0xf6, 0x35, 0x2b,
	0xa4, 0x8c, 0x99, 0x96, 0x83, 0x88, 0xaf, 0x06, 0x21, 0xe5, 0x14, 0x5e, 0x12, 0x4c, 0x55, 0x32,
	0x55, 0xc9, 0x54, 0x47, 0xfb, 0xd5, 0x32, 0xf2, 0x88, 0x4f, 0x35, 0xf1, 0x57, 0x52, 0xab, 0x57,
	0x2c, 0xca, 0x3c, 0xca, 0x4c, 0xf1, 0xa4, 0xc9, 0x87, 0xf8, 0xd5, 0x46, 0x9f, 0xf6, 0xa9, 0xc4,
	0xa3, 0x5f, 0x31, 0xba, 0xd5, 0xa7, 0xb4, 0xef, 0x62, 0x4d, 0x3c, 0xf5, 0x86, 0xf7, 0x34, 0x4e,
	0x3c, 0xcc, 0x38, 0xf2, 0x82, 0x98, 0x70, 0xd5, 0x99, 0x04, 0x38, 0x74, 0x91, 0x8f, 0xb5, 0xaf,
	0x51, 0x18, 0x68, 0xa3, 0x77, 0x34, 0x3e, 0x09, 0x70, 0xac, 0xba, 0xf3, 0x4b, 0x06, 0xac, 0x1d,
	0x46, 0x2b, 0x3e, 0x8c, 0x16, 0x6c, 0xd0, 0x21, 0xc7, 0xd0, 0x06, 0x39, 0x67, 0x12, 0x70, 0x3a,
	0xc0, 0xbe, 0x49, 0xec, 0x8a, 0xb2, 0xad, 0xec, 0xae, 0x1e, 0x1c, 0x3e, 0x78, 0xbc, 0x95, 0xfa,
	0xed, 0xf1, 0xd6, 0x07, 0x7d, 0xc2, 0x9d, 0x61, 0x4f, 0xb5, 0xa8, 0xa7, 0xf5, 0xac, 0x60, 0x8f,
	0xf8, 0x3e, 0x1d, 0x21, 0x4e, 0xa8, 0xcf, 0xb4, 0x69, 0xaa, 0x3d, 0xb9, 0x72, 0x6d, 0xc8, 0x89,
	0xab, 0xb6, 0xf0, 0xb8, 0x6e, 0xdb, 0x21, 0x66, 0xcc, 0x00, 0x89, 0xae, 0x6e, 0x43, 0x06, 0xd6,
	0x43, 0x6c, 0x61, 0x32, 0xc2, 0xa1, 0xac, 0x96, 0xe9, 0x50, 0x3a, 0xa8, 0xa4, 0x5f, 0x5e, 0xb6,
	0x72, 0xa2, 0x2f, 0xf6, 0xd6, 0xa2, 0x74, 0x00, 0xbf, 0x05, 0x97, 0x43, 0xec, 0x51, 0x8e, 0xcd,
	0x80, 0x32, 0x12, 0xe9, 0x98, 0x48, 0xb2, 0x2b, 0x99, 0x97, 0x97, 0x78, 0x53, 0xe6, 0xe8, 0xc4,
	0x29, 0x62, 0x18, 0x7e, 0x01, 0xa0, 0x87, 0xc6, 0x26, 0xf1, 0xef, 0xb9, 0xa4, 0xef, 0x70, 0x73,
	0x84, 0xdc, 0x21, 0xae, 0x64, 0x45, 0xde, 0xb7, 0xe3, 0xbc, 0x9b, 0x52, 0x92, 0xd9, 0x03, 0x95,
	0x50, 0xcd, 0x43, 0xdc, 0x51, 0x75, 0x9f, 0x3f, 0xfa, 0x79, 0x0f, 0xc4, 0xc3, 0xa0, 0xfb, 0xfc,
	0xc7, 0x3f, 0x7f, 0xba, 0xa1, 0x18, 0x25, 0x0f, 0x8d, 0xf5, 0x58, 0xea, 0xd3, 0x48, 0x69, 0xe7,
	0xd1, 0x05, 0x50, 0x34, 0x16, 0x32, 0xc3, 0x22, 0x48, 0xc7, 0x1d, 0xcc, 0x1a, 0x69, 0x62, 0x9f,
	0x6d, 0x6d, 0xfa, 0xbf, 0x69, 0xad, 0x03, 0x0a, 0x62, 0xca, 0x17, 0x6a, 0x9b, 0x7f, 0x39, 0x79,
	0xf2, 0x42, 0x39, 0x29, 0xe9, 0x27, 0x20, 0xc7, 0x1c, 0x14, 0x62, 0x66, 0x3a, 0xd8, 0xb5, 0x97,
	0xae, 0x25, 0x90, 0x22, 0x2d, 0xec, 0xda, 0xf0, 0x04, 0xac, 0x06, 0x21, 0xf1, 0x2d, 0x12, 0x20,
	0xb7, 0x72, 0x61, 0x49, 0xc1, 0x99, 0x04, 0xbc, 0x1b, 0x2f, 0xd1, 0x0c, 0x42, 0x62, 0xe1, 0xca,
	0x8a, 0x50, 0x7c, 0x37, 0x56, 0xfc, 0xff, 0x79, 0xc5, 0x63, 0xdc, 0x47, 0xd6, 0xa4, 0x81, 0xad,
	0x39, 0xdd, 0x06, 0xb6, 0xe6, 0x17, 0xda, 0x89, 0x94, 0xa2, 0xbd, 0x73, 0xca, 0x91, 0x1b, 0xcf,
	0xd1, 0xff, 0x96, 0xdd, 0xbb, 0x10, 0x11, 0x13, 0x04, 0x9b, 0x20, 0xe7, 0x22, 0xc6, 0xcd, 0x61,
	0x60, 0x23, 0x8e, 0x2b, 0x17, 0xb7, 0x95, 0xdd, 0xdc, 0x7e, 0x55, 0x95, 0x1e, 0xa3, 0x26, 0x1e,
	0xa3, 0x76, 0x13, 0x8f, 0x39, 0xb8, 0x18, 0xa5, 0xbb, 0xff, 0xfb, 0x96, 0x62, 0x80, 0x28, 0xf0,
	0x8e, 0x88, 0x83, 0xaf, 0x83, 0x22, 0x0d, 0x91, 0xe5, 0xe2, 0xe9, 0x00, 0x80, 0x68, 0x71, 0x46,
	0x41, 0xa2, 0x49, 0xf3, 0xae, 0x81, 0x42, 0x74, 0x1e, 0x18, 0x47, 0x2e, 0xf6, 0x23, 0x56, 0x6e,
	0x5b, 0xd9, 0xcd, 0x18, 0x79, 0x0f, 0x8d, 0x4f, 0x13, 0x6c, 0xe7, 0xaf, 0x2c, 0xc8, 0x27, 0x63,
	0x7e, 0x6b, 0xe8, 0xdb, 0xe7, 0x46, 0xfa, 0x2d, 0x00, 0xcf, 0x1e, 0xe9, 0x78, 0xb2, 0xb3, 0x46,
	0x69, 0xf1, 0x20, 0xea, 0x36, 0x3c, 0x02, 0xab, 0x36, 0x09, 0xb1, 0x15, 0x3d, 0x8a, 0xb1, 0x2c,
	0xee, 0x5f, 0x57, 0x9f, 0xed, 0xcf, 0x6a, 0x92, 0xb6, 0x91, 0x04, 0x18, 0xb3, 0x58, 0xd8, 0x02,
	0x2b, 0xc8, 0xa3, 0x43, 0x9f, 0x2f, 0x3d, 0x74, 0x71, 0x3c, 0x3c, 0x02, 0x79, 0xe2, 0x13, 0x4e,
	0x10, 0xc7, 0xb6, 0x89, 0x78, 0x65, 0xf5, 0x05, 0xaa, 0x9e, 0x9b, 0x46, 0xd6, 0x79, 0xd4, 0x3d,
	0x3c, 0x0e, 0xb0, 0x15, 0xeb, 0x80, 0x17, 0xe9, 0x5e, 0x12, 0x58, 0xe7, 0xf0, 0x23, 0xb0, 0xc2,
	0x38, 0xe2, 0x43, 0xd9, 0x8f, 0xe2, 0xfe, 0x1b, 0xff, 0x56, 0x9f, 0x53, 0xc1, 0x36, 0xe2, 0x28,
	0xf8, 0x25, 0x58, 0x17, 0x13, 0x69, 0x22, 0x6e, 0xc6, 0xcb, 0x8b, 0x8a, 0x9d, 0x5f, 0xb2, 0x4c,
	0x65, 0x21, 0x56, 0xe7, 0xfa, 0x54, 0x0a, 0x62, 0x70, 0x79, 0xea, 0x13, 0x26, 0x0f, 0x91, 0x35,
	0x20, 0x7e, 0x3f, 0xf2, 0x55, 0x5a, 0x29, 0x88, 0x4d, 0xef, 0x3d, 0x6f, 0xc9, 0xad, 0x24, 0xac,
	0x1b, 0x47, 0xe9, 0xfe, 0x3d, 0x6a, 0x6c, 0x3a, 0xcf, 0x82, 0x77, 0xfe, 0x56, 0xc0, 0xe6, 0x33,
	0x03, 0xe0, 0x55, 0x00, 0x3c, 0xcc, 0x18, 0xea, 0xe3, 0xe4, 0x82, 0xcc, 0x1b, 0xab, 0x31, 0xa2,
	0xdb, 0xd1, 0x60, 0xd3, 0x90, 0xf4, 0x89, 0x6f, 0xda, 0xd4, 0x43, 0xc4, 0x17, 0xd3, 0x58, 0x30,
	0xf2, 0x12, 0x6c, 0x08, 0x0c, 0xee, 0x01, 0x68, 0x63, 0xc6, 0x89, 0x2f, 0xf6, 0x94, 0x30, 0x33,
	0x82, 0x59, 0x9e, 0x7b, 0x13, 0xd3, 0x5f, 0x8b, 0xce, 0x94, 0xd0, 0xe4, 0x63, 0xd3, 0x41, 0xcc,
	0x91, 0xde, 0x94, 0x88, 0x76, 0xc7, 0x2d, 0xc4, 0x1c, 0xa8, 0x82, 0xf5, 0x79, 0xd1, 0x84, 0x2a,
	0x4c, 0x67, 0x41, 0x35, 0xe6, 0xbf, 0x12, 0x99, 0x1d, 0xb5, 0x30, 0x63, 0xd8, 0x16, 0x0e, 0x72,
	0xd1, 0x98, 0x01, 0x3b, 0xdf, 0x65, 0x41, 0x75, 0xf6, 0x71, 0x90, 0x9c, 0xa2, 0x53, 0x1f, 0x05,
	0xcc, 0xa1, 0x3c, 0xba, 0xcf, 0xa4, 0x01, 0xc5, 0xe7, 0x4f, 0xfa, 0x90, 0xb2, 0xec, 0x7d, 0x26,
	0xb4, 0xe4, 0xfd, 0x25, 0xdd, 0xa8, 0x07, 0x36, 0xa4, 0xfe, 0x99, 0x1b, 0x33, 0xbd, 0x64, 0x06,
	0xb9, 0xda, 0x85, 0x3b, 0x13, 0x5e, 0x07, 0x25, 0x64, 0x71, 0x32, 0x9a, 0xb9, 0x87, 0xbc, 0xad,
	0x32, 0xc6, 0x9a, 0xc4, 0x93, 0x5d, 0x33, 0xf8, 0x26, 0x58, 0x13, 0x56, 0x35, 0xc7, 0xcc, 0x0a,
	0x66, 0x51, 0xc0, 0x33, 0xe2, 0xab, 0x20, 0xdf, 0x73, 0xa9, 0x35, 0x30, 0x1d, 0x1c, 0x25, 0x12,
	0x8d, 0xca, 0x18, 0x39, 0x81, 0xb5, 0x04, 0x04, 0xbf, 0x02, 0x45, 0x79, 0x46, 0x7a, 0x13, 0x33,
	0x8c, 0x3e, 0xba, 0x2a, 0x2b, 0xdb, 0x99, 0xdd, 0xdc, 0x7e, 0xe3, 0x79, 0x83, 0xfb, 0xfc, 0x36,
	0xa8, 0x62, 0x23, 0x07, 0x13, 0xf1, 0xed, 0xd6, 0xf4, 0x79, 0x38, 0x89, 0xee, 0xc8, 0x19, 0x54,
	0xfd, 0x18, 0x94, 0xcf, 0x51, 0x60, 0x09, 0x64, 0x06, 0x78, 0x22, 0x9a, 0x55, 0x30, 0xa2, 0x9f,
	0x70, 0x03, 0x5c, 0x98, 0x2b, 0xaf, 0x21, 0x1f, 0xde, 0x4f, 0xbf, 0xa7, 0xdc, 0xe8, 0x80, 0x42,
	0x3b, 0xc0, 0xa1, 0x9c, 0x9b, 0x49, 0x80, 0x61, 0x15, 0x5c, 0x6a, 0x77, 0x9a, 0x46, 0xbd, 0xab,
	0xb7, 0x4f, 0xcc, 0xee, 0x67, 0x9d, 0xa6, 0xd9, 0x68, 0x76, 0xda, 0xa7, 0x7a, 0xb7, 0x94, 0x82,
	0x57, 0xc1, 0x95, 0x33, 0xef, 0xee, 0xea, 0xdd, 0x56, 0xc3, 0xa8, 0xdf, 0xad, 0x1f, 0x97, 0x94,
	0x6a, 0xf6, 0xfb, 0x1f, 0x6a, 0xa9, 0x1b, 0x47, 0xa0, 0x7c, 0xce, 0x5c, 0xe1, 0x26, 0x28, 0xeb,
	0x27, 0xb7, 0x8e, 0xf5, 0xa3, 0x56, 0xd7, 0x6c, 0xdf, 0xe9, 0x1e, 0xb5, 0xf5, 0x93, 0xa3, 0x52,
	0x6a, 0x01, 0xd6, 0x4f, 0x0e, 0xdb, 0xb7, 0x23, 0x38, 0x11, 0xa2, 0xa0, 0xb8, 0xe8, 0x42, 0x70,
	0x03, 0x94, 0xa6, 0xf4, 0x4e, 0xf3, 0xa4, 0x21, 0x45, 0x2e, 0x01, 0x38, 0x45, 0x0f, 0xdb, 0xb7,
	0x3b, 0xc7, 0xcd, 0x6e, 0xb3, 0x51, 0x52, 0xe0, 0x3a, 0x58, 0x9b, 0xe2, 0xb7, 0xea, 0xfa, 0x71,
	0xb3, 0x51, 0x4a, 0x2f, 0x48, 0x74, 0xf5, 0xdb, 0xcd, 0xf6, 0x9d, 0x6e, 0x29, 0x23, 0x13, 0x1e,
	0x7c, 0xf8, 0xe0, 0x49, 0x4d, 0x79, 0xf8, 0xa4, 0xa6, 0xfc, 0xf1, 0xa4, 0xa6, 0xdc, 0x7f, 0x5a,
	0x4b, 0x3d, 0x7c, 0x5a, 0x4b, 0xfd, 0xfa, 0xb4, 0x96, 0xfa, 0xfc, 0x5a, 0xdc, 0x33, 0xd9, 0xc0,
	0xf1, 0xe4, 0x1b, 0x6d, 0x74, 0x53, 0x7e, 0x6a, 0xcf, 0xfe, 0x39, 0xe8, 0xad, 0x08, 0x17, 0xbe,
	0xf9, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x38, 0x71, 0x2d, 0x3d, 0x0c, 0x00, 0x00,
}

func (m *CrossChainRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxInflightValue.Size()
		i -= size
		if _, err := m.MaxInflightValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.RemotePositionAddress.Size()
		i -= size
		if _, err := m.RemotePositionAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.ReceiverChainHook.Size()
		i -= size
		if _, err := m.ReceiverChainHook.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.HyptokenId.Size()
		i -= size
		if _, err := m.HyptokenId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RemotePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemotePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemotePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxStaleness != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.MaxStaleness))
		i--
		dAtA[i] = 0x58
	}
	if len(m.OracleAddress) > 0 {
		i -= len(m.OracleAddress)
		copy(dAtA[i:], m.OracleAddress)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.OracleAddress)))
		i--
		dAtA[i] = 0x52
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastUpdate, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintCrossChain(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x42
	{
		size := m.TotalValue.Size()
		i -= size
		if _, err := m.TotalValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.SharePrice.Size()
		i -= size
		if _, err := m.SharePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Principal.Size()
		i -= size
		if _, err := m.Principal.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.SharesHeld.Size()
		i -= size
		if _, err := m.SharesHeld.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.VaultAddress.Size()
		i -= size
		if _, err := m.VaultAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.HyptokenId.Size()
		i -= size
		if _, err := m.HyptokenId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Id != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InflightFund) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InflightFund) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InflightFund) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HyperlaneTrackingInfo != nil {
		{
			size, err := m.HyperlaneTrackingInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCrossChain(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	{
		size := m.ValueAtInitiation.Size()
		i -= size
		if _, err := m.ValueAtInitiation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.Status != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x58
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExpectedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintCrossChain(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x52
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.InitiatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintCrossChain(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x4a
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Direction != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x18
	}
	if m.RemotePositionId != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.RemotePositionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HyperlaneTrackingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HyperlaneTrackingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HyperlaneTrackingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Processed {
		i--
		if m.Processed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.DestinationTxHash) > 0 {
		i -= len(m.DestinationTxHash)
		copy(dAtA[i:], m.DestinationTxHash)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.DestinationTxHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OriginTxHash) > 0 {
		i -= len(m.OriginTxHash)
		copy(dAtA[i:], m.OriginTxHash)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.OriginTxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x18
	}
	if m.OriginDomain != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.OriginDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MessageId) > 0 {
		i -= len(m.MessageId)
		copy(dAtA[i:], m.MessageId)
		i = encodeVarintCrossChain(dAtA, i, uint64(len(m.MessageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrossChainPositionSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossChainPositionSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossChainPositionSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValueByRoute) > 0 {
		for k := range m.ValueByRoute {
			v := m.ValueByRoute[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCrossChain(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintCrossChain(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintCrossChain(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.BlockHeight != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.StalePositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.StalePositions))
		i--
		dAtA[i] = 0x20
	}
	if m.ActivePositions != 0 {
		i = encodeVarintCrossChain(dAtA, i, uint64(m.ActivePositions))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalInflightValue.Size()
		i -= size
		if _, err := m.TotalInflightValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalRemoteValue.Size()
		i -= size
		if _, err := m.TotalRemoteValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCrossChain(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintCrossChain(dAtA []byte, offset int, v uint64) int {
	offset -= sovCrossChain(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CrossChainRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.HyptokenId.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.ReceiverChainHook.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.RemotePositionAddress.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.MaxInflightValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	return n
}

func (m *RemotePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCrossChain(uint64(m.Id))
	}
	l = m.HyptokenId.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.VaultAddress.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.SharesHeld.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.Principal.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.SharePrice.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.TotalValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastUpdate)
	n += 1 + l + sovCrossChain(uint64(l))
	l = len(m.OracleAddress)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.MaxStaleness != 0 {
		n += 1 + sovCrossChain(uint64(m.MaxStaleness))
	}
	return n
}

func (m *InflightFund) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCrossChain(uint64(m.Id))
	}
	if m.RemotePositionId != 0 {
		n += 1 + sovCrossChain(uint64(m.RemotePositionId))
	}
	if m.Direction != 0 {
		n += 1 + sovCrossChain(uint64(m.Direction))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt)
	n += 1 + l + sovCrossChain(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExpectedAt)
	n += 1 + l + sovCrossChain(uint64(l))
	if m.Status != 0 {
		n += 1 + sovCrossChain(uint64(m.Status))
	}
	l = m.ValueAtInitiation.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.HyperlaneTrackingInfo != nil {
		l = m.HyperlaneTrackingInfo.Size()
		n += 1 + l + sovCrossChain(uint64(l))
	}
	return n
}

func (m *HyperlaneTrackingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.OriginDomain != 0 {
		n += 1 + sovCrossChain(uint64(m.OriginDomain))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovCrossChain(uint64(m.DestinationDomain))
	}
	l = len(m.OriginTxHash)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	l = len(m.DestinationTxHash)
	if l > 0 {
		n += 1 + l + sovCrossChain(uint64(l))
	}
	if m.Processed {
		n += 2
	}
	return n
}

func (m *CrossChainPositionSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalRemoteValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	l = m.TotalInflightValue.Size()
	n += 1 + l + sovCrossChain(uint64(l))
	if m.ActivePositions != 0 {
		n += 1 + sovCrossChain(uint64(m.ActivePositions))
	}
	if m.StalePositions != 0 {
		n += 1 + sovCrossChain(uint64(m.StalePositions))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovCrossChain(uint64(m.BlockHeight))
	}
	if len(m.ValueByRoute) > 0 {
		for k, v := range m.ValueByRoute {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCrossChain(uint64(k)) + 1 + len(v) + sovCrossChain(uint64(len(v)))
			n += mapEntrySize + 1 + sovCrossChain(uint64(mapEntrySize))
		}
	}
	return n
}

func sovCrossChain(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCrossChain(x uint64) (n int) {
	return sovCrossChain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CrossChainRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyptokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HyptokenId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverChainHook", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReceiverChainHook.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePositionAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemotePositionAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInflightValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxInflightValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemotePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemotePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemotePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyptokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HyptokenId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VaultAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesHeld", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharesHeld.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Principal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SharePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastUpdate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxStaleness", wireType)
			}
			m.MaxStaleness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxStaleness |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InflightFund) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InflightFund: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InflightFund: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePositionId", wireType)
			}
			m.RemotePositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemotePositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= InflightDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.InitiatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExpectedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InflightStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueAtInitiation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValueAtInitiation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyperlaneTrackingInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HyperlaneTrackingInfo == nil {
				m.HyperlaneTrackingInfo = &HyperlaneTrackingInfo{}
			}
			if err := m.HyperlaneTrackingInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HyperlaneTrackingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HyperlaneTrackingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HyperlaneTrackingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = append(m.MessageId[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageId == nil {
				m.MessageId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginDomain", wireType)
			}
			m.OriginDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Processed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossChainPositionSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossChainPositionSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossChainPositionSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRemoteValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalRemoteValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalInflightValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalInflightValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePositions", wireType)
			}
			m.ActivePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivePositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalePositions", wireType)
			}
			m.StalePositions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StalePositions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueByRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCrossChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCrossChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValueByRoute == nil {
				m.ValueByRoute = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCrossChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCrossChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCrossChain
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCrossChain
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCrossChain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCrossChain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ValueByRoute[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCrossChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCrossChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCrossChain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCrossChain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCrossChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCrossChain
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCrossChain
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCrossChain
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCrossChain        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCrossChain          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCrossChain = fmt.Errorf("proto: unexpected end of group")
)
